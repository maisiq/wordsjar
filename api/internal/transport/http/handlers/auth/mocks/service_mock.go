// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/transport/http/handlers/auth.Service -o service_mock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
	authService "github.com/maisiq/go-words-jar/internal/service/auth"
)

// ServiceMock implements mm_auth.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAuthenticate          func(ctx context.Context, username string, plainPassword string) (t1 authService.Tokens, err error)
	funcAuthenticateOrigin    string
	inspectFuncAuthenticate   func(ctx context.Context, username string, plainPassword string)
	afterAuthenticateCounter  uint64
	beforeAuthenticateCounter uint64
	AuthenticateMock          mServiceMockAuthenticate

	funcCreateUser          func(ctx context.Context, username string, password string) (err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, username string, password string)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mServiceMockCreateUser

	funcGetUser          func(ctx context.Context, username string) (u1 models.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, username string)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mServiceMockGetUser

	funcUserInfo          func(ctx context.Context, username string) (u1 authService.UserInfo, err error)
	funcUserInfoOrigin    string
	inspectFuncUserInfo   func(ctx context.Context, username string)
	afterUserInfoCounter  uint64
	beforeUserInfoCounter uint64
	UserInfoMock          mServiceMockUserInfo
}

// NewServiceMock returns a mock for mm_auth.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AuthenticateMock = mServiceMockAuthenticate{mock: m}
	m.AuthenticateMock.callArgs = []*ServiceMockAuthenticateParams{}

	m.CreateUserMock = mServiceMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*ServiceMockCreateUserParams{}

	m.GetUserMock = mServiceMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*ServiceMockGetUserParams{}

	m.UserInfoMock = mServiceMockUserInfo{mock: m}
	m.UserInfoMock.callArgs = []*ServiceMockUserInfoParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockAuthenticate struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockAuthenticateExpectation
	expectations       []*ServiceMockAuthenticateExpectation

	callArgs []*ServiceMockAuthenticateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockAuthenticateExpectation specifies expectation struct of the Service.Authenticate
type ServiceMockAuthenticateExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockAuthenticateParams
	paramPtrs          *ServiceMockAuthenticateParamPtrs
	expectationOrigins ServiceMockAuthenticateExpectationOrigins
	results            *ServiceMockAuthenticateResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockAuthenticateParams contains parameters of the Service.Authenticate
type ServiceMockAuthenticateParams struct {
	ctx           context.Context
	username      string
	plainPassword string
}

// ServiceMockAuthenticateParamPtrs contains pointers to parameters of the Service.Authenticate
type ServiceMockAuthenticateParamPtrs struct {
	ctx           *context.Context
	username      *string
	plainPassword *string
}

// ServiceMockAuthenticateResults contains results of the Service.Authenticate
type ServiceMockAuthenticateResults struct {
	t1  authService.Tokens
	err error
}

// ServiceMockAuthenticateOrigins contains origins of expectations of the Service.Authenticate
type ServiceMockAuthenticateExpectationOrigins struct {
	origin              string
	originCtx           string
	originUsername      string
	originPlainPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAuthenticate *mServiceMockAuthenticate) Optional() *mServiceMockAuthenticate {
	mmAuthenticate.optional = true
	return mmAuthenticate
}

// Expect sets up expected params for Service.Authenticate
func (mmAuthenticate *mServiceMockAuthenticate) Expect(ctx context.Context, username string, plainPassword string) *mServiceMockAuthenticate {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by Set")
	}

	if mmAuthenticate.defaultExpectation == nil {
		mmAuthenticate.defaultExpectation = &ServiceMockAuthenticateExpectation{}
	}

	if mmAuthenticate.defaultExpectation.paramPtrs != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by ExpectParams functions")
	}

	mmAuthenticate.defaultExpectation.params = &ServiceMockAuthenticateParams{ctx, username, plainPassword}
	mmAuthenticate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAuthenticate.expectations {
		if minimock.Equal(e.params, mmAuthenticate.defaultExpectation.params) {
			mmAuthenticate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAuthenticate.defaultExpectation.params)
		}
	}

	return mmAuthenticate
}

// ExpectCtxParam1 sets up expected param ctx for Service.Authenticate
func (mmAuthenticate *mServiceMockAuthenticate) ExpectCtxParam1(ctx context.Context) *mServiceMockAuthenticate {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by Set")
	}

	if mmAuthenticate.defaultExpectation == nil {
		mmAuthenticate.defaultExpectation = &ServiceMockAuthenticateExpectation{}
	}

	if mmAuthenticate.defaultExpectation.params != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by Expect")
	}

	if mmAuthenticate.defaultExpectation.paramPtrs == nil {
		mmAuthenticate.defaultExpectation.paramPtrs = &ServiceMockAuthenticateParamPtrs{}
	}
	mmAuthenticate.defaultExpectation.paramPtrs.ctx = &ctx
	mmAuthenticate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAuthenticate
}

// ExpectUsernameParam2 sets up expected param username for Service.Authenticate
func (mmAuthenticate *mServiceMockAuthenticate) ExpectUsernameParam2(username string) *mServiceMockAuthenticate {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by Set")
	}

	if mmAuthenticate.defaultExpectation == nil {
		mmAuthenticate.defaultExpectation = &ServiceMockAuthenticateExpectation{}
	}

	if mmAuthenticate.defaultExpectation.params != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by Expect")
	}

	if mmAuthenticate.defaultExpectation.paramPtrs == nil {
		mmAuthenticate.defaultExpectation.paramPtrs = &ServiceMockAuthenticateParamPtrs{}
	}
	mmAuthenticate.defaultExpectation.paramPtrs.username = &username
	mmAuthenticate.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmAuthenticate
}

// ExpectPlainPasswordParam3 sets up expected param plainPassword for Service.Authenticate
func (mmAuthenticate *mServiceMockAuthenticate) ExpectPlainPasswordParam3(plainPassword string) *mServiceMockAuthenticate {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by Set")
	}

	if mmAuthenticate.defaultExpectation == nil {
		mmAuthenticate.defaultExpectation = &ServiceMockAuthenticateExpectation{}
	}

	if mmAuthenticate.defaultExpectation.params != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by Expect")
	}

	if mmAuthenticate.defaultExpectation.paramPtrs == nil {
		mmAuthenticate.defaultExpectation.paramPtrs = &ServiceMockAuthenticateParamPtrs{}
	}
	mmAuthenticate.defaultExpectation.paramPtrs.plainPassword = &plainPassword
	mmAuthenticate.defaultExpectation.expectationOrigins.originPlainPassword = minimock.CallerInfo(1)

	return mmAuthenticate
}

// Inspect accepts an inspector function that has same arguments as the Service.Authenticate
func (mmAuthenticate *mServiceMockAuthenticate) Inspect(f func(ctx context.Context, username string, plainPassword string)) *mServiceMockAuthenticate {
	if mmAuthenticate.mock.inspectFuncAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("Inspect function is already set for ServiceMock.Authenticate")
	}

	mmAuthenticate.mock.inspectFuncAuthenticate = f

	return mmAuthenticate
}

// Return sets up results that will be returned by Service.Authenticate
func (mmAuthenticate *mServiceMockAuthenticate) Return(t1 authService.Tokens, err error) *ServiceMock {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by Set")
	}

	if mmAuthenticate.defaultExpectation == nil {
		mmAuthenticate.defaultExpectation = &ServiceMockAuthenticateExpectation{mock: mmAuthenticate.mock}
	}
	mmAuthenticate.defaultExpectation.results = &ServiceMockAuthenticateResults{t1, err}
	mmAuthenticate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAuthenticate.mock
}

// Set uses given function f to mock the Service.Authenticate method
func (mmAuthenticate *mServiceMockAuthenticate) Set(f func(ctx context.Context, username string, plainPassword string) (t1 authService.Tokens, err error)) *ServiceMock {
	if mmAuthenticate.defaultExpectation != nil {
		mmAuthenticate.mock.t.Fatalf("Default expectation is already set for the Service.Authenticate method")
	}

	if len(mmAuthenticate.expectations) > 0 {
		mmAuthenticate.mock.t.Fatalf("Some expectations are already set for the Service.Authenticate method")
	}

	mmAuthenticate.mock.funcAuthenticate = f
	mmAuthenticate.mock.funcAuthenticateOrigin = minimock.CallerInfo(1)
	return mmAuthenticate.mock
}

// When sets expectation for the Service.Authenticate which will trigger the result defined by the following
// Then helper
func (mmAuthenticate *mServiceMockAuthenticate) When(ctx context.Context, username string, plainPassword string) *ServiceMockAuthenticateExpectation {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("ServiceMock.Authenticate mock is already set by Set")
	}

	expectation := &ServiceMockAuthenticateExpectation{
		mock:               mmAuthenticate.mock,
		params:             &ServiceMockAuthenticateParams{ctx, username, plainPassword},
		expectationOrigins: ServiceMockAuthenticateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAuthenticate.expectations = append(mmAuthenticate.expectations, expectation)
	return expectation
}

// Then sets up Service.Authenticate return parameters for the expectation previously defined by the When method
func (e *ServiceMockAuthenticateExpectation) Then(t1 authService.Tokens, err error) *ServiceMock {
	e.results = &ServiceMockAuthenticateResults{t1, err}
	return e.mock
}

// Times sets number of times Service.Authenticate should be invoked
func (mmAuthenticate *mServiceMockAuthenticate) Times(n uint64) *mServiceMockAuthenticate {
	if n == 0 {
		mmAuthenticate.mock.t.Fatalf("Times of ServiceMock.Authenticate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAuthenticate.expectedInvocations, n)
	mmAuthenticate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAuthenticate
}

func (mmAuthenticate *mServiceMockAuthenticate) invocationsDone() bool {
	if len(mmAuthenticate.expectations) == 0 && mmAuthenticate.defaultExpectation == nil && mmAuthenticate.mock.funcAuthenticate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAuthenticate.mock.afterAuthenticateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAuthenticate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Authenticate implements mm_auth.Service
func (mmAuthenticate *ServiceMock) Authenticate(ctx context.Context, username string, plainPassword string) (t1 authService.Tokens, err error) {
	mm_atomic.AddUint64(&mmAuthenticate.beforeAuthenticateCounter, 1)
	defer mm_atomic.AddUint64(&mmAuthenticate.afterAuthenticateCounter, 1)

	mmAuthenticate.t.Helper()

	if mmAuthenticate.inspectFuncAuthenticate != nil {
		mmAuthenticate.inspectFuncAuthenticate(ctx, username, plainPassword)
	}

	mm_params := ServiceMockAuthenticateParams{ctx, username, plainPassword}

	// Record call args
	mmAuthenticate.AuthenticateMock.mutex.Lock()
	mmAuthenticate.AuthenticateMock.callArgs = append(mmAuthenticate.AuthenticateMock.callArgs, &mm_params)
	mmAuthenticate.AuthenticateMock.mutex.Unlock()

	for _, e := range mmAuthenticate.AuthenticateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmAuthenticate.AuthenticateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAuthenticate.AuthenticateMock.defaultExpectation.Counter, 1)
		mm_want := mmAuthenticate.AuthenticateMock.defaultExpectation.params
		mm_want_ptrs := mmAuthenticate.AuthenticateMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockAuthenticateParams{ctx, username, plainPassword}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAuthenticate.t.Errorf("ServiceMock.Authenticate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAuthenticate.AuthenticateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmAuthenticate.t.Errorf("ServiceMock.Authenticate got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAuthenticate.AuthenticateMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.plainPassword != nil && !minimock.Equal(*mm_want_ptrs.plainPassword, mm_got.plainPassword) {
				mmAuthenticate.t.Errorf("ServiceMock.Authenticate got unexpected parameter plainPassword, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAuthenticate.AuthenticateMock.defaultExpectation.expectationOrigins.originPlainPassword, *mm_want_ptrs.plainPassword, mm_got.plainPassword, minimock.Diff(*mm_want_ptrs.plainPassword, mm_got.plainPassword))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAuthenticate.t.Errorf("ServiceMock.Authenticate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAuthenticate.AuthenticateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAuthenticate.AuthenticateMock.defaultExpectation.results
		if mm_results == nil {
			mmAuthenticate.t.Fatal("No results are set for the ServiceMock.Authenticate")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmAuthenticate.funcAuthenticate != nil {
		return mmAuthenticate.funcAuthenticate(ctx, username, plainPassword)
	}
	mmAuthenticate.t.Fatalf("Unexpected call to ServiceMock.Authenticate. %v %v %v", ctx, username, plainPassword)
	return
}

// AuthenticateAfterCounter returns a count of finished ServiceMock.Authenticate invocations
func (mmAuthenticate *ServiceMock) AuthenticateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthenticate.afterAuthenticateCounter)
}

// AuthenticateBeforeCounter returns a count of ServiceMock.Authenticate invocations
func (mmAuthenticate *ServiceMock) AuthenticateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthenticate.beforeAuthenticateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Authenticate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAuthenticate *mServiceMockAuthenticate) Calls() []*ServiceMockAuthenticateParams {
	mmAuthenticate.mutex.RLock()

	argCopy := make([]*ServiceMockAuthenticateParams, len(mmAuthenticate.callArgs))
	copy(argCopy, mmAuthenticate.callArgs)

	mmAuthenticate.mutex.RUnlock()

	return argCopy
}

// MinimockAuthenticateDone returns true if the count of the Authenticate invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockAuthenticateDone() bool {
	if m.AuthenticateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AuthenticateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AuthenticateMock.invocationsDone()
}

// MinimockAuthenticateInspect logs each unmet expectation
func (m *ServiceMock) MinimockAuthenticateInspect() {
	for _, e := range m.AuthenticateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Authenticate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAuthenticateCounter := mm_atomic.LoadUint64(&m.afterAuthenticateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AuthenticateMock.defaultExpectation != nil && afterAuthenticateCounter < 1 {
		if m.AuthenticateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Authenticate at\n%s", m.AuthenticateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Authenticate at\n%s with params: %#v", m.AuthenticateMock.defaultExpectation.expectationOrigins.origin, *m.AuthenticateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuthenticate != nil && afterAuthenticateCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Authenticate at\n%s", m.funcAuthenticateOrigin)
	}

	if !m.AuthenticateMock.invocationsDone() && afterAuthenticateCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Authenticate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AuthenticateMock.expectedInvocations), m.AuthenticateMock.expectedInvocationsOrigin, afterAuthenticateCounter)
	}
}

type mServiceMockCreateUser struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateUserExpectation
	expectations       []*ServiceMockCreateUserExpectation

	callArgs []*ServiceMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCreateUserExpectation specifies expectation struct of the Service.CreateUser
type ServiceMockCreateUserExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCreateUserParams
	paramPtrs          *ServiceMockCreateUserParamPtrs
	expectationOrigins ServiceMockCreateUserExpectationOrigins
	results            *ServiceMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCreateUserParams contains parameters of the Service.CreateUser
type ServiceMockCreateUserParams struct {
	ctx      context.Context
	username string
	password string
}

// ServiceMockCreateUserParamPtrs contains pointers to parameters of the Service.CreateUser
type ServiceMockCreateUserParamPtrs struct {
	ctx      *context.Context
	username *string
	password *string
}

// ServiceMockCreateUserResults contains results of the Service.CreateUser
type ServiceMockCreateUserResults struct {
	err error
}

// ServiceMockCreateUserOrigins contains origins of expectations of the Service.CreateUser
type ServiceMockCreateUserExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mServiceMockCreateUser) Optional() *mServiceMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) Expect(ctx context.Context, username string, password string) *mServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &ServiceMockCreateUserParams{ctx, username, password}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) ExpectCtxParam1(ctx context.Context) *mServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUsernameParam2 sets up expected param username for Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) ExpectUsernameParam2(username string) *mServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.username = &username
	mmCreateUser.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectPasswordParam3 sets up expected param password for Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) ExpectPasswordParam3(password string) *mServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.password = &password
	mmCreateUser.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) Inspect(f func(ctx context.Context, username string, password string)) *mServiceMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for ServiceMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) Return(err error) *ServiceMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ServiceMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &ServiceMockCreateUserResults{err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the Service.CreateUser method
func (mmCreateUser *mServiceMockCreateUser) Set(f func(ctx context.Context, username string, password string) (err error)) *ServiceMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Service.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Service.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the Service.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mServiceMockCreateUser) When(ctx context.Context, username string, password string) *ServiceMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	expectation := &ServiceMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &ServiceMockCreateUserParams{ctx, username, password},
		expectationOrigins: ServiceMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Service.CreateUser return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateUserExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCreateUserResults{err}
	return e.mock
}

// Times sets number of times Service.CreateUser should be invoked
func (mmCreateUser *mServiceMockCreateUser) Times(n uint64) *mServiceMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of ServiceMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mServiceMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_auth.Service
func (mmCreateUser *ServiceMock) CreateUser(ctx context.Context, username string, password string) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, username, password)
	}

	mm_params := ServiceMockCreateUserParams{ctx, username, password}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCreateUserParams{ctx, username, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("ServiceMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmCreateUser.t.Errorf("ServiceMock.CreateUser got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmCreateUser.t.Errorf("ServiceMock.CreateUser got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("ServiceMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the ServiceMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, username, password)
	}
	mmCreateUser.t.Fatalf("Unexpected call to ServiceMock.CreateUser. %v %v %v", ctx, username, password)
	return
}

// CreateUserAfterCounter returns a count of finished ServiceMock.CreateUser invocations
func (mmCreateUser *ServiceMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of ServiceMock.CreateUser invocations
func (mmCreateUser *ServiceMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mServiceMockCreateUser) Calls() []*ServiceMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*ServiceMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mServiceMockGetUser struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetUserExpectation
	expectations       []*ServiceMockGetUserExpectation

	callArgs []*ServiceMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetUserExpectation specifies expectation struct of the Service.GetUser
type ServiceMockGetUserExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetUserParams
	paramPtrs          *ServiceMockGetUserParamPtrs
	expectationOrigins ServiceMockGetUserExpectationOrigins
	results            *ServiceMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetUserParams contains parameters of the Service.GetUser
type ServiceMockGetUserParams struct {
	ctx      context.Context
	username string
}

// ServiceMockGetUserParamPtrs contains pointers to parameters of the Service.GetUser
type ServiceMockGetUserParamPtrs struct {
	ctx      *context.Context
	username *string
}

// ServiceMockGetUserResults contains results of the Service.GetUser
type ServiceMockGetUserResults struct {
	u1  models.User
	err error
}

// ServiceMockGetUserOrigins contains origins of expectations of the Service.GetUser
type ServiceMockGetUserExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mServiceMockGetUser) Optional() *mServiceMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for Service.GetUser
func (mmGetUser *mServiceMockGetUser) Expect(ctx context.Context, username string) *mServiceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ServiceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &ServiceMockGetUserParams{ctx, username}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetUser
func (mmGetUser *mServiceMockGetUser) ExpectCtxParam1(ctx context.Context) *mServiceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ServiceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ServiceMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectUsernameParam2 sets up expected param username for Service.GetUser
func (mmGetUser *mServiceMockGetUser) ExpectUsernameParam2(username string) *mServiceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ServiceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ServiceMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.username = &username
	mmGetUser.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Service.GetUser
func (mmGetUser *mServiceMockGetUser) Inspect(f func(ctx context.Context, username string)) *mServiceMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Service.GetUser
func (mmGetUser *mServiceMockGetUser) Return(u1 models.User, err error) *ServiceMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ServiceMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &ServiceMockGetUserResults{u1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the Service.GetUser method
func (mmGetUser *mServiceMockGetUser) Set(f func(ctx context.Context, username string) (u1 models.User, err error)) *ServiceMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Service.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Service.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the Service.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mServiceMockGetUser) When(ctx context.Context, username string) *ServiceMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	expectation := &ServiceMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &ServiceMockGetUserParams{ctx, username},
		expectationOrigins: ServiceMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up Service.GetUser return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetUserExpectation) Then(u1 models.User, err error) *ServiceMock {
	e.results = &ServiceMockGetUserResults{u1, err}
	return e.mock
}

// Times sets number of times Service.GetUser should be invoked
func (mmGetUser *mServiceMockGetUser) Times(n uint64) *mServiceMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of ServiceMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mServiceMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_auth.Service
func (mmGetUser *ServiceMock) GetUser(ctx context.Context, username string) (u1 models.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, username)
	}

	mm_params := ServiceMockGetUserParams{ctx, username}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetUserParams{ctx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("ServiceMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUser.t.Errorf("ServiceMock.GetUser got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("ServiceMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the ServiceMock.GetUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, username)
	}
	mmGetUser.t.Fatalf("Unexpected call to ServiceMock.GetUser. %v %v", ctx, username)
	return
}

// GetUserAfterCounter returns a count of finished ServiceMock.GetUser invocations
func (mmGetUser *ServiceMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of ServiceMock.GetUser invocations
func (mmGetUser *ServiceMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mServiceMockGetUser) Calls() []*ServiceMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*ServiceMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mServiceMockUserInfo struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockUserInfoExpectation
	expectations       []*ServiceMockUserInfoExpectation

	callArgs []*ServiceMockUserInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockUserInfoExpectation specifies expectation struct of the Service.UserInfo
type ServiceMockUserInfoExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockUserInfoParams
	paramPtrs          *ServiceMockUserInfoParamPtrs
	expectationOrigins ServiceMockUserInfoExpectationOrigins
	results            *ServiceMockUserInfoResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockUserInfoParams contains parameters of the Service.UserInfo
type ServiceMockUserInfoParams struct {
	ctx      context.Context
	username string
}

// ServiceMockUserInfoParamPtrs contains pointers to parameters of the Service.UserInfo
type ServiceMockUserInfoParamPtrs struct {
	ctx      *context.Context
	username *string
}

// ServiceMockUserInfoResults contains results of the Service.UserInfo
type ServiceMockUserInfoResults struct {
	u1  authService.UserInfo
	err error
}

// ServiceMockUserInfoOrigins contains origins of expectations of the Service.UserInfo
type ServiceMockUserInfoExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserInfo *mServiceMockUserInfo) Optional() *mServiceMockUserInfo {
	mmUserInfo.optional = true
	return mmUserInfo
}

// Expect sets up expected params for Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) Expect(ctx context.Context, username string) *mServiceMockUserInfo {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &ServiceMockUserInfoExpectation{}
	}

	if mmUserInfo.defaultExpectation.paramPtrs != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by ExpectParams functions")
	}

	mmUserInfo.defaultExpectation.params = &ServiceMockUserInfoParams{ctx, username}
	mmUserInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserInfo.expectations {
		if minimock.Equal(e.params, mmUserInfo.defaultExpectation.params) {
			mmUserInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserInfo.defaultExpectation.params)
		}
	}

	return mmUserInfo
}

// ExpectCtxParam1 sets up expected param ctx for Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) ExpectCtxParam1(ctx context.Context) *mServiceMockUserInfo {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &ServiceMockUserInfoExpectation{}
	}

	if mmUserInfo.defaultExpectation.params != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Expect")
	}

	if mmUserInfo.defaultExpectation.paramPtrs == nil {
		mmUserInfo.defaultExpectation.paramPtrs = &ServiceMockUserInfoParamPtrs{}
	}
	mmUserInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserInfo
}

// ExpectUsernameParam2 sets up expected param username for Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) ExpectUsernameParam2(username string) *mServiceMockUserInfo {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &ServiceMockUserInfoExpectation{}
	}

	if mmUserInfo.defaultExpectation.params != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Expect")
	}

	if mmUserInfo.defaultExpectation.paramPtrs == nil {
		mmUserInfo.defaultExpectation.paramPtrs = &ServiceMockUserInfoParamPtrs{}
	}
	mmUserInfo.defaultExpectation.paramPtrs.username = &username
	mmUserInfo.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmUserInfo
}

// Inspect accepts an inspector function that has same arguments as the Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) Inspect(f func(ctx context.Context, username string)) *mServiceMockUserInfo {
	if mmUserInfo.mock.inspectFuncUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("Inspect function is already set for ServiceMock.UserInfo")
	}

	mmUserInfo.mock.inspectFuncUserInfo = f

	return mmUserInfo
}

// Return sets up results that will be returned by Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) Return(u1 authService.UserInfo, err error) *ServiceMock {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &ServiceMockUserInfoExpectation{mock: mmUserInfo.mock}
	}
	mmUserInfo.defaultExpectation.results = &ServiceMockUserInfoResults{u1, err}
	mmUserInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserInfo.mock
}

// Set uses given function f to mock the Service.UserInfo method
func (mmUserInfo *mServiceMockUserInfo) Set(f func(ctx context.Context, username string) (u1 authService.UserInfo, err error)) *ServiceMock {
	if mmUserInfo.defaultExpectation != nil {
		mmUserInfo.mock.t.Fatalf("Default expectation is already set for the Service.UserInfo method")
	}

	if len(mmUserInfo.expectations) > 0 {
		mmUserInfo.mock.t.Fatalf("Some expectations are already set for the Service.UserInfo method")
	}

	mmUserInfo.mock.funcUserInfo = f
	mmUserInfo.mock.funcUserInfoOrigin = minimock.CallerInfo(1)
	return mmUserInfo.mock
}

// When sets expectation for the Service.UserInfo which will trigger the result defined by the following
// Then helper
func (mmUserInfo *mServiceMockUserInfo) When(ctx context.Context, username string) *ServiceMockUserInfoExpectation {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	expectation := &ServiceMockUserInfoExpectation{
		mock:               mmUserInfo.mock,
		params:             &ServiceMockUserInfoParams{ctx, username},
		expectationOrigins: ServiceMockUserInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserInfo.expectations = append(mmUserInfo.expectations, expectation)
	return expectation
}

// Then sets up Service.UserInfo return parameters for the expectation previously defined by the When method
func (e *ServiceMockUserInfoExpectation) Then(u1 authService.UserInfo, err error) *ServiceMock {
	e.results = &ServiceMockUserInfoResults{u1, err}
	return e.mock
}

// Times sets number of times Service.UserInfo should be invoked
func (mmUserInfo *mServiceMockUserInfo) Times(n uint64) *mServiceMockUserInfo {
	if n == 0 {
		mmUserInfo.mock.t.Fatalf("Times of ServiceMock.UserInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserInfo.expectedInvocations, n)
	mmUserInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserInfo
}

func (mmUserInfo *mServiceMockUserInfo) invocationsDone() bool {
	if len(mmUserInfo.expectations) == 0 && mmUserInfo.defaultExpectation == nil && mmUserInfo.mock.funcUserInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserInfo.mock.afterUserInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserInfo implements mm_auth.Service
func (mmUserInfo *ServiceMock) UserInfo(ctx context.Context, username string) (u1 authService.UserInfo, err error) {
	mm_atomic.AddUint64(&mmUserInfo.beforeUserInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmUserInfo.afterUserInfoCounter, 1)

	mmUserInfo.t.Helper()

	if mmUserInfo.inspectFuncUserInfo != nil {
		mmUserInfo.inspectFuncUserInfo(ctx, username)
	}

	mm_params := ServiceMockUserInfoParams{ctx, username}

	// Record call args
	mmUserInfo.UserInfoMock.mutex.Lock()
	mmUserInfo.UserInfoMock.callArgs = append(mmUserInfo.UserInfoMock.callArgs, &mm_params)
	mmUserInfo.UserInfoMock.mutex.Unlock()

	for _, e := range mmUserInfo.UserInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmUserInfo.UserInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserInfo.UserInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmUserInfo.UserInfoMock.defaultExpectation.params
		mm_want_ptrs := mmUserInfo.UserInfoMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockUserInfoParams{ctx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserInfo.t.Errorf("ServiceMock.UserInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserInfo.UserInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmUserInfo.t.Errorf("ServiceMock.UserInfo got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserInfo.UserInfoMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserInfo.t.Errorf("ServiceMock.UserInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserInfo.UserInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserInfo.UserInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmUserInfo.t.Fatal("No results are set for the ServiceMock.UserInfo")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmUserInfo.funcUserInfo != nil {
		return mmUserInfo.funcUserInfo(ctx, username)
	}
	mmUserInfo.t.Fatalf("Unexpected call to ServiceMock.UserInfo. %v %v", ctx, username)
	return
}

// UserInfoAfterCounter returns a count of finished ServiceMock.UserInfo invocations
func (mmUserInfo *ServiceMock) UserInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserInfo.afterUserInfoCounter)
}

// UserInfoBeforeCounter returns a count of ServiceMock.UserInfo invocations
func (mmUserInfo *ServiceMock) UserInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserInfo.beforeUserInfoCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.UserInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserInfo *mServiceMockUserInfo) Calls() []*ServiceMockUserInfoParams {
	mmUserInfo.mutex.RLock()

	argCopy := make([]*ServiceMockUserInfoParams, len(mmUserInfo.callArgs))
	copy(argCopy, mmUserInfo.callArgs)

	mmUserInfo.mutex.RUnlock()

	return argCopy
}

// MinimockUserInfoDone returns true if the count of the UserInfo invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUserInfoDone() bool {
	if m.UserInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserInfoMock.invocationsDone()
}

// MinimockUserInfoInspect logs each unmet expectation
func (m *ServiceMock) MinimockUserInfoInspect() {
	for _, e := range m.UserInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.UserInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserInfoCounter := mm_atomic.LoadUint64(&m.afterUserInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserInfoMock.defaultExpectation != nil && afterUserInfoCounter < 1 {
		if m.UserInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.UserInfo at\n%s", m.UserInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.UserInfo at\n%s with params: %#v", m.UserInfoMock.defaultExpectation.expectationOrigins.origin, *m.UserInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserInfo != nil && afterUserInfoCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.UserInfo at\n%s", m.funcUserInfoOrigin)
	}

	if !m.UserInfoMock.invocationsDone() && afterUserInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.UserInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserInfoMock.expectedInvocations), m.UserInfoMock.expectedInvocationsOrigin, afterUserInfoCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAuthenticateInspect()

			m.MinimockCreateUserInspect()

			m.MinimockGetUserInspect()

			m.MinimockUserInfoInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAuthenticateDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockUserInfoDone()
}
