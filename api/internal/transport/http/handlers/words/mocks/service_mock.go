// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/transport/http/handlers/words.Service -o service_mock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
	"github.com/maisiq/go-words-jar/internal/service"
)

// ServiceMock implements mm_words.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddWord          func(ctx context.Context, en string, ru []string, transcription string) (err error)
	funcAddWordOrigin    string
	inspectFuncAddWord   func(ctx context.Context, en string, ru []string, transcription string)
	afterAddWordCounter  uint64
	beforeAddWordCounter uint64
	AddWordMock          mServiceMockAddWord

	funcGetWordByName          func(ctx context.Context, s1 string) (w1 models.Word, err error)
	funcGetWordByNameOrigin    string
	inspectFuncGetWordByName   func(ctx context.Context, s1 string)
	afterGetWordByNameCounter  uint64
	beforeGetWordByNameCounter uint64
	GetWordByNameMock          mServiceMockGetWordByName

	funcWordList          func(ctx context.Context, q1 service.QueryParams) (wa1 []models.Word, err error)
	funcWordListOrigin    string
	inspectFuncWordList   func(ctx context.Context, q1 service.QueryParams)
	afterWordListCounter  uint64
	beforeWordListCounter uint64
	WordListMock          mServiceMockWordList
}

// NewServiceMock returns a mock for mm_words.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddWordMock = mServiceMockAddWord{mock: m}
	m.AddWordMock.callArgs = []*ServiceMockAddWordParams{}

	m.GetWordByNameMock = mServiceMockGetWordByName{mock: m}
	m.GetWordByNameMock.callArgs = []*ServiceMockGetWordByNameParams{}

	m.WordListMock = mServiceMockWordList{mock: m}
	m.WordListMock.callArgs = []*ServiceMockWordListParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockAddWord struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockAddWordExpectation
	expectations       []*ServiceMockAddWordExpectation

	callArgs []*ServiceMockAddWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockAddWordExpectation specifies expectation struct of the Service.AddWord
type ServiceMockAddWordExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockAddWordParams
	paramPtrs          *ServiceMockAddWordParamPtrs
	expectationOrigins ServiceMockAddWordExpectationOrigins
	results            *ServiceMockAddWordResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockAddWordParams contains parameters of the Service.AddWord
type ServiceMockAddWordParams struct {
	ctx           context.Context
	en            string
	ru            []string
	transcription string
}

// ServiceMockAddWordParamPtrs contains pointers to parameters of the Service.AddWord
type ServiceMockAddWordParamPtrs struct {
	ctx           *context.Context
	en            *string
	ru            *[]string
	transcription *string
}

// ServiceMockAddWordResults contains results of the Service.AddWord
type ServiceMockAddWordResults struct {
	err error
}

// ServiceMockAddWordOrigins contains origins of expectations of the Service.AddWord
type ServiceMockAddWordExpectationOrigins struct {
	origin              string
	originCtx           string
	originEn            string
	originRu            string
	originTranscription string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddWord *mServiceMockAddWord) Optional() *mServiceMockAddWord {
	mmAddWord.optional = true
	return mmAddWord
}

// Expect sets up expected params for Service.AddWord
func (mmAddWord *mServiceMockAddWord) Expect(ctx context.Context, en string, ru []string, transcription string) *mServiceMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &ServiceMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.paramPtrs != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by ExpectParams functions")
	}

	mmAddWord.defaultExpectation.params = &ServiceMockAddWordParams{ctx, en, ru, transcription}
	mmAddWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddWord.expectations {
		if minimock.Equal(e.params, mmAddWord.defaultExpectation.params) {
			mmAddWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddWord.defaultExpectation.params)
		}
	}

	return mmAddWord
}

// ExpectCtxParam1 sets up expected param ctx for Service.AddWord
func (mmAddWord *mServiceMockAddWord) ExpectCtxParam1(ctx context.Context) *mServiceMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &ServiceMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.params != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Expect")
	}

	if mmAddWord.defaultExpectation.paramPtrs == nil {
		mmAddWord.defaultExpectation.paramPtrs = &ServiceMockAddWordParamPtrs{}
	}
	mmAddWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddWord
}

// ExpectEnParam2 sets up expected param en for Service.AddWord
func (mmAddWord *mServiceMockAddWord) ExpectEnParam2(en string) *mServiceMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &ServiceMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.params != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Expect")
	}

	if mmAddWord.defaultExpectation.paramPtrs == nil {
		mmAddWord.defaultExpectation.paramPtrs = &ServiceMockAddWordParamPtrs{}
	}
	mmAddWord.defaultExpectation.paramPtrs.en = &en
	mmAddWord.defaultExpectation.expectationOrigins.originEn = minimock.CallerInfo(1)

	return mmAddWord
}

// ExpectRuParam3 sets up expected param ru for Service.AddWord
func (mmAddWord *mServiceMockAddWord) ExpectRuParam3(ru []string) *mServiceMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &ServiceMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.params != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Expect")
	}

	if mmAddWord.defaultExpectation.paramPtrs == nil {
		mmAddWord.defaultExpectation.paramPtrs = &ServiceMockAddWordParamPtrs{}
	}
	mmAddWord.defaultExpectation.paramPtrs.ru = &ru
	mmAddWord.defaultExpectation.expectationOrigins.originRu = minimock.CallerInfo(1)

	return mmAddWord
}

// ExpectTranscriptionParam4 sets up expected param transcription for Service.AddWord
func (mmAddWord *mServiceMockAddWord) ExpectTranscriptionParam4(transcription string) *mServiceMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &ServiceMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.params != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Expect")
	}

	if mmAddWord.defaultExpectation.paramPtrs == nil {
		mmAddWord.defaultExpectation.paramPtrs = &ServiceMockAddWordParamPtrs{}
	}
	mmAddWord.defaultExpectation.paramPtrs.transcription = &transcription
	mmAddWord.defaultExpectation.expectationOrigins.originTranscription = minimock.CallerInfo(1)

	return mmAddWord
}

// Inspect accepts an inspector function that has same arguments as the Service.AddWord
func (mmAddWord *mServiceMockAddWord) Inspect(f func(ctx context.Context, en string, ru []string, transcription string)) *mServiceMockAddWord {
	if mmAddWord.mock.inspectFuncAddWord != nil {
		mmAddWord.mock.t.Fatalf("Inspect function is already set for ServiceMock.AddWord")
	}

	mmAddWord.mock.inspectFuncAddWord = f

	return mmAddWord
}

// Return sets up results that will be returned by Service.AddWord
func (mmAddWord *mServiceMockAddWord) Return(err error) *ServiceMock {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &ServiceMockAddWordExpectation{mock: mmAddWord.mock}
	}
	mmAddWord.defaultExpectation.results = &ServiceMockAddWordResults{err}
	mmAddWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddWord.mock
}

// Set uses given function f to mock the Service.AddWord method
func (mmAddWord *mServiceMockAddWord) Set(f func(ctx context.Context, en string, ru []string, transcription string) (err error)) *ServiceMock {
	if mmAddWord.defaultExpectation != nil {
		mmAddWord.mock.t.Fatalf("Default expectation is already set for the Service.AddWord method")
	}

	if len(mmAddWord.expectations) > 0 {
		mmAddWord.mock.t.Fatalf("Some expectations are already set for the Service.AddWord method")
	}

	mmAddWord.mock.funcAddWord = f
	mmAddWord.mock.funcAddWordOrigin = minimock.CallerInfo(1)
	return mmAddWord.mock
}

// When sets expectation for the Service.AddWord which will trigger the result defined by the following
// Then helper
func (mmAddWord *mServiceMockAddWord) When(ctx context.Context, en string, ru []string, transcription string) *ServiceMockAddWordExpectation {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("ServiceMock.AddWord mock is already set by Set")
	}

	expectation := &ServiceMockAddWordExpectation{
		mock:               mmAddWord.mock,
		params:             &ServiceMockAddWordParams{ctx, en, ru, transcription},
		expectationOrigins: ServiceMockAddWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddWord.expectations = append(mmAddWord.expectations, expectation)
	return expectation
}

// Then sets up Service.AddWord return parameters for the expectation previously defined by the When method
func (e *ServiceMockAddWordExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockAddWordResults{err}
	return e.mock
}

// Times sets number of times Service.AddWord should be invoked
func (mmAddWord *mServiceMockAddWord) Times(n uint64) *mServiceMockAddWord {
	if n == 0 {
		mmAddWord.mock.t.Fatalf("Times of ServiceMock.AddWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddWord.expectedInvocations, n)
	mmAddWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddWord
}

func (mmAddWord *mServiceMockAddWord) invocationsDone() bool {
	if len(mmAddWord.expectations) == 0 && mmAddWord.defaultExpectation == nil && mmAddWord.mock.funcAddWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddWord.mock.afterAddWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddWord implements mm_words.Service
func (mmAddWord *ServiceMock) AddWord(ctx context.Context, en string, ru []string, transcription string) (err error) {
	mm_atomic.AddUint64(&mmAddWord.beforeAddWordCounter, 1)
	defer mm_atomic.AddUint64(&mmAddWord.afterAddWordCounter, 1)

	mmAddWord.t.Helper()

	if mmAddWord.inspectFuncAddWord != nil {
		mmAddWord.inspectFuncAddWord(ctx, en, ru, transcription)
	}

	mm_params := ServiceMockAddWordParams{ctx, en, ru, transcription}

	// Record call args
	mmAddWord.AddWordMock.mutex.Lock()
	mmAddWord.AddWordMock.callArgs = append(mmAddWord.AddWordMock.callArgs, &mm_params)
	mmAddWord.AddWordMock.mutex.Unlock()

	for _, e := range mmAddWord.AddWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddWord.AddWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddWord.AddWordMock.defaultExpectation.Counter, 1)
		mm_want := mmAddWord.AddWordMock.defaultExpectation.params
		mm_want_ptrs := mmAddWord.AddWordMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockAddWordParams{ctx, en, ru, transcription}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddWord.t.Errorf("ServiceMock.AddWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.en != nil && !minimock.Equal(*mm_want_ptrs.en, mm_got.en) {
				mmAddWord.t.Errorf("ServiceMock.AddWord got unexpected parameter en, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.originEn, *mm_want_ptrs.en, mm_got.en, minimock.Diff(*mm_want_ptrs.en, mm_got.en))
			}

			if mm_want_ptrs.ru != nil && !minimock.Equal(*mm_want_ptrs.ru, mm_got.ru) {
				mmAddWord.t.Errorf("ServiceMock.AddWord got unexpected parameter ru, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.originRu, *mm_want_ptrs.ru, mm_got.ru, minimock.Diff(*mm_want_ptrs.ru, mm_got.ru))
			}

			if mm_want_ptrs.transcription != nil && !minimock.Equal(*mm_want_ptrs.transcription, mm_got.transcription) {
				mmAddWord.t.Errorf("ServiceMock.AddWord got unexpected parameter transcription, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.originTranscription, *mm_want_ptrs.transcription, mm_got.transcription, minimock.Diff(*mm_want_ptrs.transcription, mm_got.transcription))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddWord.t.Errorf("ServiceMock.AddWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddWord.AddWordMock.defaultExpectation.results
		if mm_results == nil {
			mmAddWord.t.Fatal("No results are set for the ServiceMock.AddWord")
		}
		return (*mm_results).err
	}
	if mmAddWord.funcAddWord != nil {
		return mmAddWord.funcAddWord(ctx, en, ru, transcription)
	}
	mmAddWord.t.Fatalf("Unexpected call to ServiceMock.AddWord. %v %v %v %v", ctx, en, ru, transcription)
	return
}

// AddWordAfterCounter returns a count of finished ServiceMock.AddWord invocations
func (mmAddWord *ServiceMock) AddWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWord.afterAddWordCounter)
}

// AddWordBeforeCounter returns a count of ServiceMock.AddWord invocations
func (mmAddWord *ServiceMock) AddWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWord.beforeAddWordCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.AddWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddWord *mServiceMockAddWord) Calls() []*ServiceMockAddWordParams {
	mmAddWord.mutex.RLock()

	argCopy := make([]*ServiceMockAddWordParams, len(mmAddWord.callArgs))
	copy(argCopy, mmAddWord.callArgs)

	mmAddWord.mutex.RUnlock()

	return argCopy
}

// MinimockAddWordDone returns true if the count of the AddWord invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockAddWordDone() bool {
	if m.AddWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddWordMock.invocationsDone()
}

// MinimockAddWordInspect logs each unmet expectation
func (m *ServiceMock) MinimockAddWordInspect() {
	for _, e := range m.AddWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.AddWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddWordCounter := mm_atomic.LoadUint64(&m.afterAddWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddWordMock.defaultExpectation != nil && afterAddWordCounter < 1 {
		if m.AddWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.AddWord at\n%s", m.AddWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.AddWord at\n%s with params: %#v", m.AddWordMock.defaultExpectation.expectationOrigins.origin, *m.AddWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddWord != nil && afterAddWordCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.AddWord at\n%s", m.funcAddWordOrigin)
	}

	if !m.AddWordMock.invocationsDone() && afterAddWordCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.AddWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddWordMock.expectedInvocations), m.AddWordMock.expectedInvocationsOrigin, afterAddWordCounter)
	}
}

type mServiceMockGetWordByName struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetWordByNameExpectation
	expectations       []*ServiceMockGetWordByNameExpectation

	callArgs []*ServiceMockGetWordByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetWordByNameExpectation specifies expectation struct of the Service.GetWordByName
type ServiceMockGetWordByNameExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetWordByNameParams
	paramPtrs          *ServiceMockGetWordByNameParamPtrs
	expectationOrigins ServiceMockGetWordByNameExpectationOrigins
	results            *ServiceMockGetWordByNameResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetWordByNameParams contains parameters of the Service.GetWordByName
type ServiceMockGetWordByNameParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockGetWordByNameParamPtrs contains pointers to parameters of the Service.GetWordByName
type ServiceMockGetWordByNameParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockGetWordByNameResults contains results of the Service.GetWordByName
type ServiceMockGetWordByNameResults struct {
	w1  models.Word
	err error
}

// ServiceMockGetWordByNameOrigins contains origins of expectations of the Service.GetWordByName
type ServiceMockGetWordByNameExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetWordByName *mServiceMockGetWordByName) Optional() *mServiceMockGetWordByName {
	mmGetWordByName.optional = true
	return mmGetWordByName
}

// Expect sets up expected params for Service.GetWordByName
func (mmGetWordByName *mServiceMockGetWordByName) Expect(ctx context.Context, s1 string) *mServiceMockGetWordByName {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("ServiceMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &ServiceMockGetWordByNameExpectation{}
	}

	if mmGetWordByName.defaultExpectation.paramPtrs != nil {
		mmGetWordByName.mock.t.Fatalf("ServiceMock.GetWordByName mock is already set by ExpectParams functions")
	}

	mmGetWordByName.defaultExpectation.params = &ServiceMockGetWordByNameParams{ctx, s1}
	mmGetWordByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetWordByName.expectations {
		if minimock.Equal(e.params, mmGetWordByName.defaultExpectation.params) {
			mmGetWordByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWordByName.defaultExpectation.params)
		}
	}

	return mmGetWordByName
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetWordByName
func (mmGetWordByName *mServiceMockGetWordByName) ExpectCtxParam1(ctx context.Context) *mServiceMockGetWordByName {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("ServiceMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &ServiceMockGetWordByNameExpectation{}
	}

	if mmGetWordByName.defaultExpectation.params != nil {
		mmGetWordByName.mock.t.Fatalf("ServiceMock.GetWordByName mock is already set by Expect")
	}

	if mmGetWordByName.defaultExpectation.paramPtrs == nil {
		mmGetWordByName.defaultExpectation.paramPtrs = &ServiceMockGetWordByNameParamPtrs{}
	}
	mmGetWordByName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetWordByName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetWordByName
}

// ExpectS1Param2 sets up expected param s1 for Service.GetWordByName
func (mmGetWordByName *mServiceMockGetWordByName) ExpectS1Param2(s1 string) *mServiceMockGetWordByName {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("ServiceMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &ServiceMockGetWordByNameExpectation{}
	}

	if mmGetWordByName.defaultExpectation.params != nil {
		mmGetWordByName.mock.t.Fatalf("ServiceMock.GetWordByName mock is already set by Expect")
	}

	if mmGetWordByName.defaultExpectation.paramPtrs == nil {
		mmGetWordByName.defaultExpectation.paramPtrs = &ServiceMockGetWordByNameParamPtrs{}
	}
	mmGetWordByName.defaultExpectation.paramPtrs.s1 = &s1
	mmGetWordByName.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetWordByName
}

// Inspect accepts an inspector function that has same arguments as the Service.GetWordByName
func (mmGetWordByName *mServiceMockGetWordByName) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockGetWordByName {
	if mmGetWordByName.mock.inspectFuncGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetWordByName")
	}

	mmGetWordByName.mock.inspectFuncGetWordByName = f

	return mmGetWordByName
}

// Return sets up results that will be returned by Service.GetWordByName
func (mmGetWordByName *mServiceMockGetWordByName) Return(w1 models.Word, err error) *ServiceMock {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("ServiceMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &ServiceMockGetWordByNameExpectation{mock: mmGetWordByName.mock}
	}
	mmGetWordByName.defaultExpectation.results = &ServiceMockGetWordByNameResults{w1, err}
	mmGetWordByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetWordByName.mock
}

// Set uses given function f to mock the Service.GetWordByName method
func (mmGetWordByName *mServiceMockGetWordByName) Set(f func(ctx context.Context, s1 string) (w1 models.Word, err error)) *ServiceMock {
	if mmGetWordByName.defaultExpectation != nil {
		mmGetWordByName.mock.t.Fatalf("Default expectation is already set for the Service.GetWordByName method")
	}

	if len(mmGetWordByName.expectations) > 0 {
		mmGetWordByName.mock.t.Fatalf("Some expectations are already set for the Service.GetWordByName method")
	}

	mmGetWordByName.mock.funcGetWordByName = f
	mmGetWordByName.mock.funcGetWordByNameOrigin = minimock.CallerInfo(1)
	return mmGetWordByName.mock
}

// When sets expectation for the Service.GetWordByName which will trigger the result defined by the following
// Then helper
func (mmGetWordByName *mServiceMockGetWordByName) When(ctx context.Context, s1 string) *ServiceMockGetWordByNameExpectation {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("ServiceMock.GetWordByName mock is already set by Set")
	}

	expectation := &ServiceMockGetWordByNameExpectation{
		mock:               mmGetWordByName.mock,
		params:             &ServiceMockGetWordByNameParams{ctx, s1},
		expectationOrigins: ServiceMockGetWordByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetWordByName.expectations = append(mmGetWordByName.expectations, expectation)
	return expectation
}

// Then sets up Service.GetWordByName return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetWordByNameExpectation) Then(w1 models.Word, err error) *ServiceMock {
	e.results = &ServiceMockGetWordByNameResults{w1, err}
	return e.mock
}

// Times sets number of times Service.GetWordByName should be invoked
func (mmGetWordByName *mServiceMockGetWordByName) Times(n uint64) *mServiceMockGetWordByName {
	if n == 0 {
		mmGetWordByName.mock.t.Fatalf("Times of ServiceMock.GetWordByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetWordByName.expectedInvocations, n)
	mmGetWordByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetWordByName
}

func (mmGetWordByName *mServiceMockGetWordByName) invocationsDone() bool {
	if len(mmGetWordByName.expectations) == 0 && mmGetWordByName.defaultExpectation == nil && mmGetWordByName.mock.funcGetWordByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetWordByName.mock.afterGetWordByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetWordByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetWordByName implements mm_words.Service
func (mmGetWordByName *ServiceMock) GetWordByName(ctx context.Context, s1 string) (w1 models.Word, err error) {
	mm_atomic.AddUint64(&mmGetWordByName.beforeGetWordByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWordByName.afterGetWordByNameCounter, 1)

	mmGetWordByName.t.Helper()

	if mmGetWordByName.inspectFuncGetWordByName != nil {
		mmGetWordByName.inspectFuncGetWordByName(ctx, s1)
	}

	mm_params := ServiceMockGetWordByNameParams{ctx, s1}

	// Record call args
	mmGetWordByName.GetWordByNameMock.mutex.Lock()
	mmGetWordByName.GetWordByNameMock.callArgs = append(mmGetWordByName.GetWordByNameMock.callArgs, &mm_params)
	mmGetWordByName.GetWordByNameMock.mutex.Unlock()

	for _, e := range mmGetWordByName.GetWordByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1, e.results.err
		}
	}

	if mmGetWordByName.GetWordByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWordByName.GetWordByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWordByName.GetWordByNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetWordByName.GetWordByNameMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetWordByNameParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetWordByName.t.Errorf("ServiceMock.GetWordByName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByName.GetWordByNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetWordByName.t.Errorf("ServiceMock.GetWordByName got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByName.GetWordByNameMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWordByName.t.Errorf("ServiceMock.GetWordByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetWordByName.GetWordByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWordByName.GetWordByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWordByName.t.Fatal("No results are set for the ServiceMock.GetWordByName")
		}
		return (*mm_results).w1, (*mm_results).err
	}
	if mmGetWordByName.funcGetWordByName != nil {
		return mmGetWordByName.funcGetWordByName(ctx, s1)
	}
	mmGetWordByName.t.Fatalf("Unexpected call to ServiceMock.GetWordByName. %v %v", ctx, s1)
	return
}

// GetWordByNameAfterCounter returns a count of finished ServiceMock.GetWordByName invocations
func (mmGetWordByName *ServiceMock) GetWordByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByName.afterGetWordByNameCounter)
}

// GetWordByNameBeforeCounter returns a count of ServiceMock.GetWordByName invocations
func (mmGetWordByName *ServiceMock) GetWordByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByName.beforeGetWordByNameCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetWordByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWordByName *mServiceMockGetWordByName) Calls() []*ServiceMockGetWordByNameParams {
	mmGetWordByName.mutex.RLock()

	argCopy := make([]*ServiceMockGetWordByNameParams, len(mmGetWordByName.callArgs))
	copy(argCopy, mmGetWordByName.callArgs)

	mmGetWordByName.mutex.RUnlock()

	return argCopy
}

// MinimockGetWordByNameDone returns true if the count of the GetWordByName invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetWordByNameDone() bool {
	if m.GetWordByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetWordByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetWordByNameMock.invocationsDone()
}

// MinimockGetWordByNameInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetWordByNameInspect() {
	for _, e := range m.GetWordByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetWordByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetWordByNameCounter := mm_atomic.LoadUint64(&m.afterGetWordByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetWordByNameMock.defaultExpectation != nil && afterGetWordByNameCounter < 1 {
		if m.GetWordByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetWordByName at\n%s", m.GetWordByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetWordByName at\n%s with params: %#v", m.GetWordByNameMock.defaultExpectation.expectationOrigins.origin, *m.GetWordByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWordByName != nil && afterGetWordByNameCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetWordByName at\n%s", m.funcGetWordByNameOrigin)
	}

	if !m.GetWordByNameMock.invocationsDone() && afterGetWordByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetWordByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetWordByNameMock.expectedInvocations), m.GetWordByNameMock.expectedInvocationsOrigin, afterGetWordByNameCounter)
	}
}

type mServiceMockWordList struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockWordListExpectation
	expectations       []*ServiceMockWordListExpectation

	callArgs []*ServiceMockWordListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockWordListExpectation specifies expectation struct of the Service.WordList
type ServiceMockWordListExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockWordListParams
	paramPtrs          *ServiceMockWordListParamPtrs
	expectationOrigins ServiceMockWordListExpectationOrigins
	results            *ServiceMockWordListResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockWordListParams contains parameters of the Service.WordList
type ServiceMockWordListParams struct {
	ctx context.Context
	q1  service.QueryParams
}

// ServiceMockWordListParamPtrs contains pointers to parameters of the Service.WordList
type ServiceMockWordListParamPtrs struct {
	ctx *context.Context
	q1  *service.QueryParams
}

// ServiceMockWordListResults contains results of the Service.WordList
type ServiceMockWordListResults struct {
	wa1 []models.Word
	err error
}

// ServiceMockWordListOrigins contains origins of expectations of the Service.WordList
type ServiceMockWordListExpectationOrigins struct {
	origin    string
	originCtx string
	originQ1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWordList *mServiceMockWordList) Optional() *mServiceMockWordList {
	mmWordList.optional = true
	return mmWordList
}

// Expect sets up expected params for Service.WordList
func (mmWordList *mServiceMockWordList) Expect(ctx context.Context, q1 service.QueryParams) *mServiceMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("ServiceMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &ServiceMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.paramPtrs != nil {
		mmWordList.mock.t.Fatalf("ServiceMock.WordList mock is already set by ExpectParams functions")
	}

	mmWordList.defaultExpectation.params = &ServiceMockWordListParams{ctx, q1}
	mmWordList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWordList.expectations {
		if minimock.Equal(e.params, mmWordList.defaultExpectation.params) {
			mmWordList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWordList.defaultExpectation.params)
		}
	}

	return mmWordList
}

// ExpectCtxParam1 sets up expected param ctx for Service.WordList
func (mmWordList *mServiceMockWordList) ExpectCtxParam1(ctx context.Context) *mServiceMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("ServiceMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &ServiceMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.params != nil {
		mmWordList.mock.t.Fatalf("ServiceMock.WordList mock is already set by Expect")
	}

	if mmWordList.defaultExpectation.paramPtrs == nil {
		mmWordList.defaultExpectation.paramPtrs = &ServiceMockWordListParamPtrs{}
	}
	mmWordList.defaultExpectation.paramPtrs.ctx = &ctx
	mmWordList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWordList
}

// ExpectQ1Param2 sets up expected param q1 for Service.WordList
func (mmWordList *mServiceMockWordList) ExpectQ1Param2(q1 service.QueryParams) *mServiceMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("ServiceMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &ServiceMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.params != nil {
		mmWordList.mock.t.Fatalf("ServiceMock.WordList mock is already set by Expect")
	}

	if mmWordList.defaultExpectation.paramPtrs == nil {
		mmWordList.defaultExpectation.paramPtrs = &ServiceMockWordListParamPtrs{}
	}
	mmWordList.defaultExpectation.paramPtrs.q1 = &q1
	mmWordList.defaultExpectation.expectationOrigins.originQ1 = minimock.CallerInfo(1)

	return mmWordList
}

// Inspect accepts an inspector function that has same arguments as the Service.WordList
func (mmWordList *mServiceMockWordList) Inspect(f func(ctx context.Context, q1 service.QueryParams)) *mServiceMockWordList {
	if mmWordList.mock.inspectFuncWordList != nil {
		mmWordList.mock.t.Fatalf("Inspect function is already set for ServiceMock.WordList")
	}

	mmWordList.mock.inspectFuncWordList = f

	return mmWordList
}

// Return sets up results that will be returned by Service.WordList
func (mmWordList *mServiceMockWordList) Return(wa1 []models.Word, err error) *ServiceMock {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("ServiceMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &ServiceMockWordListExpectation{mock: mmWordList.mock}
	}
	mmWordList.defaultExpectation.results = &ServiceMockWordListResults{wa1, err}
	mmWordList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWordList.mock
}

// Set uses given function f to mock the Service.WordList method
func (mmWordList *mServiceMockWordList) Set(f func(ctx context.Context, q1 service.QueryParams) (wa1 []models.Word, err error)) *ServiceMock {
	if mmWordList.defaultExpectation != nil {
		mmWordList.mock.t.Fatalf("Default expectation is already set for the Service.WordList method")
	}

	if len(mmWordList.expectations) > 0 {
		mmWordList.mock.t.Fatalf("Some expectations are already set for the Service.WordList method")
	}

	mmWordList.mock.funcWordList = f
	mmWordList.mock.funcWordListOrigin = minimock.CallerInfo(1)
	return mmWordList.mock
}

// When sets expectation for the Service.WordList which will trigger the result defined by the following
// Then helper
func (mmWordList *mServiceMockWordList) When(ctx context.Context, q1 service.QueryParams) *ServiceMockWordListExpectation {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("ServiceMock.WordList mock is already set by Set")
	}

	expectation := &ServiceMockWordListExpectation{
		mock:               mmWordList.mock,
		params:             &ServiceMockWordListParams{ctx, q1},
		expectationOrigins: ServiceMockWordListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWordList.expectations = append(mmWordList.expectations, expectation)
	return expectation
}

// Then sets up Service.WordList return parameters for the expectation previously defined by the When method
func (e *ServiceMockWordListExpectation) Then(wa1 []models.Word, err error) *ServiceMock {
	e.results = &ServiceMockWordListResults{wa1, err}
	return e.mock
}

// Times sets number of times Service.WordList should be invoked
func (mmWordList *mServiceMockWordList) Times(n uint64) *mServiceMockWordList {
	if n == 0 {
		mmWordList.mock.t.Fatalf("Times of ServiceMock.WordList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWordList.expectedInvocations, n)
	mmWordList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWordList
}

func (mmWordList *mServiceMockWordList) invocationsDone() bool {
	if len(mmWordList.expectations) == 0 && mmWordList.defaultExpectation == nil && mmWordList.mock.funcWordList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWordList.mock.afterWordListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWordList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WordList implements mm_words.Service
func (mmWordList *ServiceMock) WordList(ctx context.Context, q1 service.QueryParams) (wa1 []models.Word, err error) {
	mm_atomic.AddUint64(&mmWordList.beforeWordListCounter, 1)
	defer mm_atomic.AddUint64(&mmWordList.afterWordListCounter, 1)

	mmWordList.t.Helper()

	if mmWordList.inspectFuncWordList != nil {
		mmWordList.inspectFuncWordList(ctx, q1)
	}

	mm_params := ServiceMockWordListParams{ctx, q1}

	// Record call args
	mmWordList.WordListMock.mutex.Lock()
	mmWordList.WordListMock.callArgs = append(mmWordList.WordListMock.callArgs, &mm_params)
	mmWordList.WordListMock.mutex.Unlock()

	for _, e := range mmWordList.WordListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmWordList.WordListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWordList.WordListMock.defaultExpectation.Counter, 1)
		mm_want := mmWordList.WordListMock.defaultExpectation.params
		mm_want_ptrs := mmWordList.WordListMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockWordListParams{ctx, q1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWordList.t.Errorf("ServiceMock.WordList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWordList.WordListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.q1 != nil && !minimock.Equal(*mm_want_ptrs.q1, mm_got.q1) {
				mmWordList.t.Errorf("ServiceMock.WordList got unexpected parameter q1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWordList.WordListMock.defaultExpectation.expectationOrigins.originQ1, *mm_want_ptrs.q1, mm_got.q1, minimock.Diff(*mm_want_ptrs.q1, mm_got.q1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWordList.t.Errorf("ServiceMock.WordList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWordList.WordListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWordList.WordListMock.defaultExpectation.results
		if mm_results == nil {
			mmWordList.t.Fatal("No results are set for the ServiceMock.WordList")
		}
		return (*mm_results).wa1, (*mm_results).err
	}
	if mmWordList.funcWordList != nil {
		return mmWordList.funcWordList(ctx, q1)
	}
	mmWordList.t.Fatalf("Unexpected call to ServiceMock.WordList. %v %v", ctx, q1)
	return
}

// WordListAfterCounter returns a count of finished ServiceMock.WordList invocations
func (mmWordList *ServiceMock) WordListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWordList.afterWordListCounter)
}

// WordListBeforeCounter returns a count of ServiceMock.WordList invocations
func (mmWordList *ServiceMock) WordListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWordList.beforeWordListCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.WordList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWordList *mServiceMockWordList) Calls() []*ServiceMockWordListParams {
	mmWordList.mutex.RLock()

	argCopy := make([]*ServiceMockWordListParams, len(mmWordList.callArgs))
	copy(argCopy, mmWordList.callArgs)

	mmWordList.mutex.RUnlock()

	return argCopy
}

// MinimockWordListDone returns true if the count of the WordList invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockWordListDone() bool {
	if m.WordListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WordListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WordListMock.invocationsDone()
}

// MinimockWordListInspect logs each unmet expectation
func (m *ServiceMock) MinimockWordListInspect() {
	for _, e := range m.WordListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.WordList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWordListCounter := mm_atomic.LoadUint64(&m.afterWordListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WordListMock.defaultExpectation != nil && afterWordListCounter < 1 {
		if m.WordListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.WordList at\n%s", m.WordListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.WordList at\n%s with params: %#v", m.WordListMock.defaultExpectation.expectationOrigins.origin, *m.WordListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWordList != nil && afterWordListCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.WordList at\n%s", m.funcWordListOrigin)
	}

	if !m.WordListMock.invocationsDone() && afterWordListCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.WordList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WordListMock.expectedInvocations), m.WordListMock.expectedInvocationsOrigin, afterWordListCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddWordInspect()

			m.MinimockGetWordByNameInspect()

			m.MinimockWordListInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddWordDone() &&
		m.MinimockGetWordByNameDone() &&
		m.MinimockWordListDone()
}
