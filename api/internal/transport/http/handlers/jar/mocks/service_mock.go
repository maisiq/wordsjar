// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/transport/http/handlers/jar.Service -o service_mock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
	"github.com/maisiq/go-words-jar/internal/service"
)

// ServiceMock implements mm_jar.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddWordsToJar          func(ctx context.Context, username string, withStatus string, words ...string) (i1 int64, err error)
	funcAddWordsToJarOrigin    string
	inspectFuncAddWordsToJar   func(ctx context.Context, username string, withStatus string, words ...string)
	afterAddWordsToJarCounter  uint64
	beforeAddWordsToJarCounter uint64
	AddWordsToJarMock          mServiceMockAddWordsToJar

	funcGetUserWords          func(ctx context.Context, username string, params service.QueryParams) (wa1 []models.Word, err error)
	funcGetUserWordsOrigin    string
	inspectFuncGetUserWords   func(ctx context.Context, username string, params service.QueryParams)
	afterGetUserWordsCounter  uint64
	beforeGetUserWordsCounter uint64
	GetUserWordsMock          mServiceMockGetUserWords
}

// NewServiceMock returns a mock for mm_jar.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddWordsToJarMock = mServiceMockAddWordsToJar{mock: m}
	m.AddWordsToJarMock.callArgs = []*ServiceMockAddWordsToJarParams{}

	m.GetUserWordsMock = mServiceMockGetUserWords{mock: m}
	m.GetUserWordsMock.callArgs = []*ServiceMockGetUserWordsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockAddWordsToJar struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockAddWordsToJarExpectation
	expectations       []*ServiceMockAddWordsToJarExpectation

	callArgs []*ServiceMockAddWordsToJarParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockAddWordsToJarExpectation specifies expectation struct of the Service.AddWordsToJar
type ServiceMockAddWordsToJarExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockAddWordsToJarParams
	paramPtrs          *ServiceMockAddWordsToJarParamPtrs
	expectationOrigins ServiceMockAddWordsToJarExpectationOrigins
	results            *ServiceMockAddWordsToJarResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockAddWordsToJarParams contains parameters of the Service.AddWordsToJar
type ServiceMockAddWordsToJarParams struct {
	ctx        context.Context
	username   string
	withStatus string
	words      []string
}

// ServiceMockAddWordsToJarParamPtrs contains pointers to parameters of the Service.AddWordsToJar
type ServiceMockAddWordsToJarParamPtrs struct {
	ctx        *context.Context
	username   *string
	withStatus *string
	words      *[]string
}

// ServiceMockAddWordsToJarResults contains results of the Service.AddWordsToJar
type ServiceMockAddWordsToJarResults struct {
	i1  int64
	err error
}

// ServiceMockAddWordsToJarOrigins contains origins of expectations of the Service.AddWordsToJar
type ServiceMockAddWordsToJarExpectationOrigins struct {
	origin           string
	originCtx        string
	originUsername   string
	originWithStatus string
	originWords      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddWordsToJar *mServiceMockAddWordsToJar) Optional() *mServiceMockAddWordsToJar {
	mmAddWordsToJar.optional = true
	return mmAddWordsToJar
}

// Expect sets up expected params for Service.AddWordsToJar
func (mmAddWordsToJar *mServiceMockAddWordsToJar) Expect(ctx context.Context, username string, withStatus string, words ...string) *mServiceMockAddWordsToJar {
	if mmAddWordsToJar.mock.funcAddWordsToJar != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Set")
	}

	if mmAddWordsToJar.defaultExpectation == nil {
		mmAddWordsToJar.defaultExpectation = &ServiceMockAddWordsToJarExpectation{}
	}

	if mmAddWordsToJar.defaultExpectation.paramPtrs != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by ExpectParams functions")
	}

	mmAddWordsToJar.defaultExpectation.params = &ServiceMockAddWordsToJarParams{ctx, username, withStatus, words}
	mmAddWordsToJar.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddWordsToJar.expectations {
		if minimock.Equal(e.params, mmAddWordsToJar.defaultExpectation.params) {
			mmAddWordsToJar.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddWordsToJar.defaultExpectation.params)
		}
	}

	return mmAddWordsToJar
}

// ExpectCtxParam1 sets up expected param ctx for Service.AddWordsToJar
func (mmAddWordsToJar *mServiceMockAddWordsToJar) ExpectCtxParam1(ctx context.Context) *mServiceMockAddWordsToJar {
	if mmAddWordsToJar.mock.funcAddWordsToJar != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Set")
	}

	if mmAddWordsToJar.defaultExpectation == nil {
		mmAddWordsToJar.defaultExpectation = &ServiceMockAddWordsToJarExpectation{}
	}

	if mmAddWordsToJar.defaultExpectation.params != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Expect")
	}

	if mmAddWordsToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordsToJar.defaultExpectation.paramPtrs = &ServiceMockAddWordsToJarParamPtrs{}
	}
	mmAddWordsToJar.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddWordsToJar.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddWordsToJar
}

// ExpectUsernameParam2 sets up expected param username for Service.AddWordsToJar
func (mmAddWordsToJar *mServiceMockAddWordsToJar) ExpectUsernameParam2(username string) *mServiceMockAddWordsToJar {
	if mmAddWordsToJar.mock.funcAddWordsToJar != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Set")
	}

	if mmAddWordsToJar.defaultExpectation == nil {
		mmAddWordsToJar.defaultExpectation = &ServiceMockAddWordsToJarExpectation{}
	}

	if mmAddWordsToJar.defaultExpectation.params != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Expect")
	}

	if mmAddWordsToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordsToJar.defaultExpectation.paramPtrs = &ServiceMockAddWordsToJarParamPtrs{}
	}
	mmAddWordsToJar.defaultExpectation.paramPtrs.username = &username
	mmAddWordsToJar.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmAddWordsToJar
}

// ExpectWithStatusParam3 sets up expected param withStatus for Service.AddWordsToJar
func (mmAddWordsToJar *mServiceMockAddWordsToJar) ExpectWithStatusParam3(withStatus string) *mServiceMockAddWordsToJar {
	if mmAddWordsToJar.mock.funcAddWordsToJar != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Set")
	}

	if mmAddWordsToJar.defaultExpectation == nil {
		mmAddWordsToJar.defaultExpectation = &ServiceMockAddWordsToJarExpectation{}
	}

	if mmAddWordsToJar.defaultExpectation.params != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Expect")
	}

	if mmAddWordsToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordsToJar.defaultExpectation.paramPtrs = &ServiceMockAddWordsToJarParamPtrs{}
	}
	mmAddWordsToJar.defaultExpectation.paramPtrs.withStatus = &withStatus
	mmAddWordsToJar.defaultExpectation.expectationOrigins.originWithStatus = minimock.CallerInfo(1)

	return mmAddWordsToJar
}

// ExpectWordsParam4 sets up expected param words for Service.AddWordsToJar
func (mmAddWordsToJar *mServiceMockAddWordsToJar) ExpectWordsParam4(words ...string) *mServiceMockAddWordsToJar {
	if mmAddWordsToJar.mock.funcAddWordsToJar != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Set")
	}

	if mmAddWordsToJar.defaultExpectation == nil {
		mmAddWordsToJar.defaultExpectation = &ServiceMockAddWordsToJarExpectation{}
	}

	if mmAddWordsToJar.defaultExpectation.params != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Expect")
	}

	if mmAddWordsToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordsToJar.defaultExpectation.paramPtrs = &ServiceMockAddWordsToJarParamPtrs{}
	}
	mmAddWordsToJar.defaultExpectation.paramPtrs.words = &words
	mmAddWordsToJar.defaultExpectation.expectationOrigins.originWords = minimock.CallerInfo(1)

	return mmAddWordsToJar
}

// Inspect accepts an inspector function that has same arguments as the Service.AddWordsToJar
func (mmAddWordsToJar *mServiceMockAddWordsToJar) Inspect(f func(ctx context.Context, username string, withStatus string, words ...string)) *mServiceMockAddWordsToJar {
	if mmAddWordsToJar.mock.inspectFuncAddWordsToJar != nil {
		mmAddWordsToJar.mock.t.Fatalf("Inspect function is already set for ServiceMock.AddWordsToJar")
	}

	mmAddWordsToJar.mock.inspectFuncAddWordsToJar = f

	return mmAddWordsToJar
}

// Return sets up results that will be returned by Service.AddWordsToJar
func (mmAddWordsToJar *mServiceMockAddWordsToJar) Return(i1 int64, err error) *ServiceMock {
	if mmAddWordsToJar.mock.funcAddWordsToJar != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Set")
	}

	if mmAddWordsToJar.defaultExpectation == nil {
		mmAddWordsToJar.defaultExpectation = &ServiceMockAddWordsToJarExpectation{mock: mmAddWordsToJar.mock}
	}
	mmAddWordsToJar.defaultExpectation.results = &ServiceMockAddWordsToJarResults{i1, err}
	mmAddWordsToJar.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddWordsToJar.mock
}

// Set uses given function f to mock the Service.AddWordsToJar method
func (mmAddWordsToJar *mServiceMockAddWordsToJar) Set(f func(ctx context.Context, username string, withStatus string, words ...string) (i1 int64, err error)) *ServiceMock {
	if mmAddWordsToJar.defaultExpectation != nil {
		mmAddWordsToJar.mock.t.Fatalf("Default expectation is already set for the Service.AddWordsToJar method")
	}

	if len(mmAddWordsToJar.expectations) > 0 {
		mmAddWordsToJar.mock.t.Fatalf("Some expectations are already set for the Service.AddWordsToJar method")
	}

	mmAddWordsToJar.mock.funcAddWordsToJar = f
	mmAddWordsToJar.mock.funcAddWordsToJarOrigin = minimock.CallerInfo(1)
	return mmAddWordsToJar.mock
}

// When sets expectation for the Service.AddWordsToJar which will trigger the result defined by the following
// Then helper
func (mmAddWordsToJar *mServiceMockAddWordsToJar) When(ctx context.Context, username string, withStatus string, words ...string) *ServiceMockAddWordsToJarExpectation {
	if mmAddWordsToJar.mock.funcAddWordsToJar != nil {
		mmAddWordsToJar.mock.t.Fatalf("ServiceMock.AddWordsToJar mock is already set by Set")
	}

	expectation := &ServiceMockAddWordsToJarExpectation{
		mock:               mmAddWordsToJar.mock,
		params:             &ServiceMockAddWordsToJarParams{ctx, username, withStatus, words},
		expectationOrigins: ServiceMockAddWordsToJarExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddWordsToJar.expectations = append(mmAddWordsToJar.expectations, expectation)
	return expectation
}

// Then sets up Service.AddWordsToJar return parameters for the expectation previously defined by the When method
func (e *ServiceMockAddWordsToJarExpectation) Then(i1 int64, err error) *ServiceMock {
	e.results = &ServiceMockAddWordsToJarResults{i1, err}
	return e.mock
}

// Times sets number of times Service.AddWordsToJar should be invoked
func (mmAddWordsToJar *mServiceMockAddWordsToJar) Times(n uint64) *mServiceMockAddWordsToJar {
	if n == 0 {
		mmAddWordsToJar.mock.t.Fatalf("Times of ServiceMock.AddWordsToJar mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddWordsToJar.expectedInvocations, n)
	mmAddWordsToJar.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddWordsToJar
}

func (mmAddWordsToJar *mServiceMockAddWordsToJar) invocationsDone() bool {
	if len(mmAddWordsToJar.expectations) == 0 && mmAddWordsToJar.defaultExpectation == nil && mmAddWordsToJar.mock.funcAddWordsToJar == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddWordsToJar.mock.afterAddWordsToJarCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddWordsToJar.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddWordsToJar implements mm_jar.Service
func (mmAddWordsToJar *ServiceMock) AddWordsToJar(ctx context.Context, username string, withStatus string, words ...string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmAddWordsToJar.beforeAddWordsToJarCounter, 1)
	defer mm_atomic.AddUint64(&mmAddWordsToJar.afterAddWordsToJarCounter, 1)

	mmAddWordsToJar.t.Helper()

	if mmAddWordsToJar.inspectFuncAddWordsToJar != nil {
		mmAddWordsToJar.inspectFuncAddWordsToJar(ctx, username, withStatus, words...)
	}

	mm_params := ServiceMockAddWordsToJarParams{ctx, username, withStatus, words}

	// Record call args
	mmAddWordsToJar.AddWordsToJarMock.mutex.Lock()
	mmAddWordsToJar.AddWordsToJarMock.callArgs = append(mmAddWordsToJar.AddWordsToJarMock.callArgs, &mm_params)
	mmAddWordsToJar.AddWordsToJarMock.mutex.Unlock()

	for _, e := range mmAddWordsToJar.AddWordsToJarMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddWordsToJar.AddWordsToJarMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddWordsToJar.AddWordsToJarMock.defaultExpectation.Counter, 1)
		mm_want := mmAddWordsToJar.AddWordsToJarMock.defaultExpectation.params
		mm_want_ptrs := mmAddWordsToJar.AddWordsToJarMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockAddWordsToJarParams{ctx, username, withStatus, words}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddWordsToJar.t.Errorf("ServiceMock.AddWordsToJar got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordsToJar.AddWordsToJarMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmAddWordsToJar.t.Errorf("ServiceMock.AddWordsToJar got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordsToJar.AddWordsToJarMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.withStatus != nil && !minimock.Equal(*mm_want_ptrs.withStatus, mm_got.withStatus) {
				mmAddWordsToJar.t.Errorf("ServiceMock.AddWordsToJar got unexpected parameter withStatus, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordsToJar.AddWordsToJarMock.defaultExpectation.expectationOrigins.originWithStatus, *mm_want_ptrs.withStatus, mm_got.withStatus, minimock.Diff(*mm_want_ptrs.withStatus, mm_got.withStatus))
			}

			if mm_want_ptrs.words != nil && !minimock.Equal(*mm_want_ptrs.words, mm_got.words) {
				mmAddWordsToJar.t.Errorf("ServiceMock.AddWordsToJar got unexpected parameter words, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordsToJar.AddWordsToJarMock.defaultExpectation.expectationOrigins.originWords, *mm_want_ptrs.words, mm_got.words, minimock.Diff(*mm_want_ptrs.words, mm_got.words))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddWordsToJar.t.Errorf("ServiceMock.AddWordsToJar got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddWordsToJar.AddWordsToJarMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddWordsToJar.AddWordsToJarMock.defaultExpectation.results
		if mm_results == nil {
			mmAddWordsToJar.t.Fatal("No results are set for the ServiceMock.AddWordsToJar")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddWordsToJar.funcAddWordsToJar != nil {
		return mmAddWordsToJar.funcAddWordsToJar(ctx, username, withStatus, words...)
	}
	mmAddWordsToJar.t.Fatalf("Unexpected call to ServiceMock.AddWordsToJar. %v %v %v %v", ctx, username, withStatus, words)
	return
}

// AddWordsToJarAfterCounter returns a count of finished ServiceMock.AddWordsToJar invocations
func (mmAddWordsToJar *ServiceMock) AddWordsToJarAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordsToJar.afterAddWordsToJarCounter)
}

// AddWordsToJarBeforeCounter returns a count of ServiceMock.AddWordsToJar invocations
func (mmAddWordsToJar *ServiceMock) AddWordsToJarBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordsToJar.beforeAddWordsToJarCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.AddWordsToJar.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddWordsToJar *mServiceMockAddWordsToJar) Calls() []*ServiceMockAddWordsToJarParams {
	mmAddWordsToJar.mutex.RLock()

	argCopy := make([]*ServiceMockAddWordsToJarParams, len(mmAddWordsToJar.callArgs))
	copy(argCopy, mmAddWordsToJar.callArgs)

	mmAddWordsToJar.mutex.RUnlock()

	return argCopy
}

// MinimockAddWordsToJarDone returns true if the count of the AddWordsToJar invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockAddWordsToJarDone() bool {
	if m.AddWordsToJarMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddWordsToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddWordsToJarMock.invocationsDone()
}

// MinimockAddWordsToJarInspect logs each unmet expectation
func (m *ServiceMock) MinimockAddWordsToJarInspect() {
	for _, e := range m.AddWordsToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.AddWordsToJar at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddWordsToJarCounter := mm_atomic.LoadUint64(&m.afterAddWordsToJarCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddWordsToJarMock.defaultExpectation != nil && afterAddWordsToJarCounter < 1 {
		if m.AddWordsToJarMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.AddWordsToJar at\n%s", m.AddWordsToJarMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.AddWordsToJar at\n%s with params: %#v", m.AddWordsToJarMock.defaultExpectation.expectationOrigins.origin, *m.AddWordsToJarMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddWordsToJar != nil && afterAddWordsToJarCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.AddWordsToJar at\n%s", m.funcAddWordsToJarOrigin)
	}

	if !m.AddWordsToJarMock.invocationsDone() && afterAddWordsToJarCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.AddWordsToJar at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddWordsToJarMock.expectedInvocations), m.AddWordsToJarMock.expectedInvocationsOrigin, afterAddWordsToJarCounter)
	}
}

type mServiceMockGetUserWords struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetUserWordsExpectation
	expectations       []*ServiceMockGetUserWordsExpectation

	callArgs []*ServiceMockGetUserWordsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetUserWordsExpectation specifies expectation struct of the Service.GetUserWords
type ServiceMockGetUserWordsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetUserWordsParams
	paramPtrs          *ServiceMockGetUserWordsParamPtrs
	expectationOrigins ServiceMockGetUserWordsExpectationOrigins
	results            *ServiceMockGetUserWordsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetUserWordsParams contains parameters of the Service.GetUserWords
type ServiceMockGetUserWordsParams struct {
	ctx      context.Context
	username string
	params   service.QueryParams
}

// ServiceMockGetUserWordsParamPtrs contains pointers to parameters of the Service.GetUserWords
type ServiceMockGetUserWordsParamPtrs struct {
	ctx      *context.Context
	username *string
	params   *service.QueryParams
}

// ServiceMockGetUserWordsResults contains results of the Service.GetUserWords
type ServiceMockGetUserWordsResults struct {
	wa1 []models.Word
	err error
}

// ServiceMockGetUserWordsOrigins contains origins of expectations of the Service.GetUserWords
type ServiceMockGetUserWordsExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originParams   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserWords *mServiceMockGetUserWords) Optional() *mServiceMockGetUserWords {
	mmGetUserWords.optional = true
	return mmGetUserWords
}

// Expect sets up expected params for Service.GetUserWords
func (mmGetUserWords *mServiceMockGetUserWords) Expect(ctx context.Context, username string, params service.QueryParams) *mServiceMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ServiceMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.paramPtrs != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by ExpectParams functions")
	}

	mmGetUserWords.defaultExpectation.params = &ServiceMockGetUserWordsParams{ctx, username, params}
	mmGetUserWords.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserWords.expectations {
		if minimock.Equal(e.params, mmGetUserWords.defaultExpectation.params) {
			mmGetUserWords.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserWords.defaultExpectation.params)
		}
	}

	return mmGetUserWords
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetUserWords
func (mmGetUserWords *mServiceMockGetUserWords) ExpectCtxParam1(ctx context.Context) *mServiceMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ServiceMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &ServiceMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserWords.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserWords
}

// ExpectUsernameParam2 sets up expected param username for Service.GetUserWords
func (mmGetUserWords *mServiceMockGetUserWords) ExpectUsernameParam2(username string) *mServiceMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ServiceMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &ServiceMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.username = &username
	mmGetUserWords.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserWords
}

// ExpectParamsParam3 sets up expected param params for Service.GetUserWords
func (mmGetUserWords *mServiceMockGetUserWords) ExpectParamsParam3(params service.QueryParams) *mServiceMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ServiceMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &ServiceMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.params = &params
	mmGetUserWords.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmGetUserWords
}

// Inspect accepts an inspector function that has same arguments as the Service.GetUserWords
func (mmGetUserWords *mServiceMockGetUserWords) Inspect(f func(ctx context.Context, username string, params service.QueryParams)) *mServiceMockGetUserWords {
	if mmGetUserWords.mock.inspectFuncGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetUserWords")
	}

	mmGetUserWords.mock.inspectFuncGetUserWords = f

	return mmGetUserWords
}

// Return sets up results that will be returned by Service.GetUserWords
func (mmGetUserWords *mServiceMockGetUserWords) Return(wa1 []models.Word, err error) *ServiceMock {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ServiceMockGetUserWordsExpectation{mock: mmGetUserWords.mock}
	}
	mmGetUserWords.defaultExpectation.results = &ServiceMockGetUserWordsResults{wa1, err}
	mmGetUserWords.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserWords.mock
}

// Set uses given function f to mock the Service.GetUserWords method
func (mmGetUserWords *mServiceMockGetUserWords) Set(f func(ctx context.Context, username string, params service.QueryParams) (wa1 []models.Word, err error)) *ServiceMock {
	if mmGetUserWords.defaultExpectation != nil {
		mmGetUserWords.mock.t.Fatalf("Default expectation is already set for the Service.GetUserWords method")
	}

	if len(mmGetUserWords.expectations) > 0 {
		mmGetUserWords.mock.t.Fatalf("Some expectations are already set for the Service.GetUserWords method")
	}

	mmGetUserWords.mock.funcGetUserWords = f
	mmGetUserWords.mock.funcGetUserWordsOrigin = minimock.CallerInfo(1)
	return mmGetUserWords.mock
}

// When sets expectation for the Service.GetUserWords which will trigger the result defined by the following
// Then helper
func (mmGetUserWords *mServiceMockGetUserWords) When(ctx context.Context, username string, params service.QueryParams) *ServiceMockGetUserWordsExpectation {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ServiceMock.GetUserWords mock is already set by Set")
	}

	expectation := &ServiceMockGetUserWordsExpectation{
		mock:               mmGetUserWords.mock,
		params:             &ServiceMockGetUserWordsParams{ctx, username, params},
		expectationOrigins: ServiceMockGetUserWordsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserWords.expectations = append(mmGetUserWords.expectations, expectation)
	return expectation
}

// Then sets up Service.GetUserWords return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetUserWordsExpectation) Then(wa1 []models.Word, err error) *ServiceMock {
	e.results = &ServiceMockGetUserWordsResults{wa1, err}
	return e.mock
}

// Times sets number of times Service.GetUserWords should be invoked
func (mmGetUserWords *mServiceMockGetUserWords) Times(n uint64) *mServiceMockGetUserWords {
	if n == 0 {
		mmGetUserWords.mock.t.Fatalf("Times of ServiceMock.GetUserWords mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserWords.expectedInvocations, n)
	mmGetUserWords.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserWords
}

func (mmGetUserWords *mServiceMockGetUserWords) invocationsDone() bool {
	if len(mmGetUserWords.expectations) == 0 && mmGetUserWords.defaultExpectation == nil && mmGetUserWords.mock.funcGetUserWords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserWords.mock.afterGetUserWordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserWords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserWords implements mm_jar.Service
func (mmGetUserWords *ServiceMock) GetUserWords(ctx context.Context, username string, params service.QueryParams) (wa1 []models.Word, err error) {
	mm_atomic.AddUint64(&mmGetUserWords.beforeGetUserWordsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserWords.afterGetUserWordsCounter, 1)

	mmGetUserWords.t.Helper()

	if mmGetUserWords.inspectFuncGetUserWords != nil {
		mmGetUserWords.inspectFuncGetUserWords(ctx, username, params)
	}

	mm_params := ServiceMockGetUserWordsParams{ctx, username, params}

	// Record call args
	mmGetUserWords.GetUserWordsMock.mutex.Lock()
	mmGetUserWords.GetUserWordsMock.callArgs = append(mmGetUserWords.GetUserWordsMock.callArgs, &mm_params)
	mmGetUserWords.GetUserWordsMock.mutex.Unlock()

	for _, e := range mmGetUserWords.GetUserWordsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmGetUserWords.GetUserWordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserWords.GetUserWordsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserWords.GetUserWordsMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserWords.GetUserWordsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetUserWordsParams{ctx, username, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserWords.t.Errorf("ServiceMock.GetUserWords got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserWords.t.Errorf("ServiceMock.GetUserWords got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetUserWords.t.Errorf("ServiceMock.GetUserWords got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserWords.t.Errorf("ServiceMock.GetUserWords got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserWords.GetUserWordsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserWords.t.Fatal("No results are set for the ServiceMock.GetUserWords")
		}
		return (*mm_results).wa1, (*mm_results).err
	}
	if mmGetUserWords.funcGetUserWords != nil {
		return mmGetUserWords.funcGetUserWords(ctx, username, params)
	}
	mmGetUserWords.t.Fatalf("Unexpected call to ServiceMock.GetUserWords. %v %v %v", ctx, username, params)
	return
}

// GetUserWordsAfterCounter returns a count of finished ServiceMock.GetUserWords invocations
func (mmGetUserWords *ServiceMock) GetUserWordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWords.afterGetUserWordsCounter)
}

// GetUserWordsBeforeCounter returns a count of ServiceMock.GetUserWords invocations
func (mmGetUserWords *ServiceMock) GetUserWordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWords.beforeGetUserWordsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetUserWords.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserWords *mServiceMockGetUserWords) Calls() []*ServiceMockGetUserWordsParams {
	mmGetUserWords.mutex.RLock()

	argCopy := make([]*ServiceMockGetUserWordsParams, len(mmGetUserWords.callArgs))
	copy(argCopy, mmGetUserWords.callArgs)

	mmGetUserWords.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserWordsDone returns true if the count of the GetUserWords invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetUserWordsDone() bool {
	if m.GetUserWordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserWordsMock.invocationsDone()
}

// MinimockGetUserWordsInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetUserWordsInspect() {
	for _, e := range m.GetUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetUserWords at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserWordsCounter := mm_atomic.LoadUint64(&m.afterGetUserWordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserWordsMock.defaultExpectation != nil && afterGetUserWordsCounter < 1 {
		if m.GetUserWordsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetUserWords at\n%s", m.GetUserWordsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetUserWords at\n%s with params: %#v", m.GetUserWordsMock.defaultExpectation.expectationOrigins.origin, *m.GetUserWordsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserWords != nil && afterGetUserWordsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetUserWords at\n%s", m.funcGetUserWordsOrigin)
	}

	if !m.GetUserWordsMock.invocationsDone() && afterGetUserWordsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetUserWords at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserWordsMock.expectedInvocations), m.GetUserWordsMock.expectedInvocationsOrigin, afterGetUserWordsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddWordsToJarInspect()

			m.MinimockGetUserWordsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddWordsToJarDone() &&
		m.MinimockGetUserWordsDone()
}
