// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/transport/http/handlers/exam.Service -o service_mock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/service"
)

// ServiceMock implements mm_exam.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetTestUserWords          func(ctx context.Context, username string, params service.QueryParams) (ta1 []service.TestWord, err error)
	funcGetTestUserWordsOrigin    string
	inspectFuncGetTestUserWords   func(ctx context.Context, username string, params service.QueryParams)
	afterGetTestUserWordsCounter  uint64
	beforeGetTestUserWordsCounter uint64
	GetTestUserWordsMock          mServiceMockGetTestUserWords

	funcVerifyWord          func(ctx context.Context, username string, wordID string, answer string, enCheck bool) (b1 bool, err error)
	funcVerifyWordOrigin    string
	inspectFuncVerifyWord   func(ctx context.Context, username string, wordID string, answer string, enCheck bool)
	afterVerifyWordCounter  uint64
	beforeVerifyWordCounter uint64
	VerifyWordMock          mServiceMockVerifyWord
}

// NewServiceMock returns a mock for mm_exam.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetTestUserWordsMock = mServiceMockGetTestUserWords{mock: m}
	m.GetTestUserWordsMock.callArgs = []*ServiceMockGetTestUserWordsParams{}

	m.VerifyWordMock = mServiceMockVerifyWord{mock: m}
	m.VerifyWordMock.callArgs = []*ServiceMockVerifyWordParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockGetTestUserWords struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetTestUserWordsExpectation
	expectations       []*ServiceMockGetTestUserWordsExpectation

	callArgs []*ServiceMockGetTestUserWordsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetTestUserWordsExpectation specifies expectation struct of the Service.GetTestUserWords
type ServiceMockGetTestUserWordsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetTestUserWordsParams
	paramPtrs          *ServiceMockGetTestUserWordsParamPtrs
	expectationOrigins ServiceMockGetTestUserWordsExpectationOrigins
	results            *ServiceMockGetTestUserWordsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetTestUserWordsParams contains parameters of the Service.GetTestUserWords
type ServiceMockGetTestUserWordsParams struct {
	ctx      context.Context
	username string
	params   service.QueryParams
}

// ServiceMockGetTestUserWordsParamPtrs contains pointers to parameters of the Service.GetTestUserWords
type ServiceMockGetTestUserWordsParamPtrs struct {
	ctx      *context.Context
	username *string
	params   *service.QueryParams
}

// ServiceMockGetTestUserWordsResults contains results of the Service.GetTestUserWords
type ServiceMockGetTestUserWordsResults struct {
	ta1 []service.TestWord
	err error
}

// ServiceMockGetTestUserWordsOrigins contains origins of expectations of the Service.GetTestUserWords
type ServiceMockGetTestUserWordsExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originParams   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTestUserWords *mServiceMockGetTestUserWords) Optional() *mServiceMockGetTestUserWords {
	mmGetTestUserWords.optional = true
	return mmGetTestUserWords
}

// Expect sets up expected params for Service.GetTestUserWords
func (mmGetTestUserWords *mServiceMockGetTestUserWords) Expect(ctx context.Context, username string, params service.QueryParams) *mServiceMockGetTestUserWords {
	if mmGetTestUserWords.mock.funcGetTestUserWords != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by Set")
	}

	if mmGetTestUserWords.defaultExpectation == nil {
		mmGetTestUserWords.defaultExpectation = &ServiceMockGetTestUserWordsExpectation{}
	}

	if mmGetTestUserWords.defaultExpectation.paramPtrs != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by ExpectParams functions")
	}

	mmGetTestUserWords.defaultExpectation.params = &ServiceMockGetTestUserWordsParams{ctx, username, params}
	mmGetTestUserWords.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTestUserWords.expectations {
		if minimock.Equal(e.params, mmGetTestUserWords.defaultExpectation.params) {
			mmGetTestUserWords.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTestUserWords.defaultExpectation.params)
		}
	}

	return mmGetTestUserWords
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetTestUserWords
func (mmGetTestUserWords *mServiceMockGetTestUserWords) ExpectCtxParam1(ctx context.Context) *mServiceMockGetTestUserWords {
	if mmGetTestUserWords.mock.funcGetTestUserWords != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by Set")
	}

	if mmGetTestUserWords.defaultExpectation == nil {
		mmGetTestUserWords.defaultExpectation = &ServiceMockGetTestUserWordsExpectation{}
	}

	if mmGetTestUserWords.defaultExpectation.params != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by Expect")
	}

	if mmGetTestUserWords.defaultExpectation.paramPtrs == nil {
		mmGetTestUserWords.defaultExpectation.paramPtrs = &ServiceMockGetTestUserWordsParamPtrs{}
	}
	mmGetTestUserWords.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTestUserWords.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTestUserWords
}

// ExpectUsernameParam2 sets up expected param username for Service.GetTestUserWords
func (mmGetTestUserWords *mServiceMockGetTestUserWords) ExpectUsernameParam2(username string) *mServiceMockGetTestUserWords {
	if mmGetTestUserWords.mock.funcGetTestUserWords != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by Set")
	}

	if mmGetTestUserWords.defaultExpectation == nil {
		mmGetTestUserWords.defaultExpectation = &ServiceMockGetTestUserWordsExpectation{}
	}

	if mmGetTestUserWords.defaultExpectation.params != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by Expect")
	}

	if mmGetTestUserWords.defaultExpectation.paramPtrs == nil {
		mmGetTestUserWords.defaultExpectation.paramPtrs = &ServiceMockGetTestUserWordsParamPtrs{}
	}
	mmGetTestUserWords.defaultExpectation.paramPtrs.username = &username
	mmGetTestUserWords.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetTestUserWords
}

// ExpectParamsParam3 sets up expected param params for Service.GetTestUserWords
func (mmGetTestUserWords *mServiceMockGetTestUserWords) ExpectParamsParam3(params service.QueryParams) *mServiceMockGetTestUserWords {
	if mmGetTestUserWords.mock.funcGetTestUserWords != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by Set")
	}

	if mmGetTestUserWords.defaultExpectation == nil {
		mmGetTestUserWords.defaultExpectation = &ServiceMockGetTestUserWordsExpectation{}
	}

	if mmGetTestUserWords.defaultExpectation.params != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by Expect")
	}

	if mmGetTestUserWords.defaultExpectation.paramPtrs == nil {
		mmGetTestUserWords.defaultExpectation.paramPtrs = &ServiceMockGetTestUserWordsParamPtrs{}
	}
	mmGetTestUserWords.defaultExpectation.paramPtrs.params = &params
	mmGetTestUserWords.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmGetTestUserWords
}

// Inspect accepts an inspector function that has same arguments as the Service.GetTestUserWords
func (mmGetTestUserWords *mServiceMockGetTestUserWords) Inspect(f func(ctx context.Context, username string, params service.QueryParams)) *mServiceMockGetTestUserWords {
	if mmGetTestUserWords.mock.inspectFuncGetTestUserWords != nil {
		mmGetTestUserWords.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetTestUserWords")
	}

	mmGetTestUserWords.mock.inspectFuncGetTestUserWords = f

	return mmGetTestUserWords
}

// Return sets up results that will be returned by Service.GetTestUserWords
func (mmGetTestUserWords *mServiceMockGetTestUserWords) Return(ta1 []service.TestWord, err error) *ServiceMock {
	if mmGetTestUserWords.mock.funcGetTestUserWords != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by Set")
	}

	if mmGetTestUserWords.defaultExpectation == nil {
		mmGetTestUserWords.defaultExpectation = &ServiceMockGetTestUserWordsExpectation{mock: mmGetTestUserWords.mock}
	}
	mmGetTestUserWords.defaultExpectation.results = &ServiceMockGetTestUserWordsResults{ta1, err}
	mmGetTestUserWords.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTestUserWords.mock
}

// Set uses given function f to mock the Service.GetTestUserWords method
func (mmGetTestUserWords *mServiceMockGetTestUserWords) Set(f func(ctx context.Context, username string, params service.QueryParams) (ta1 []service.TestWord, err error)) *ServiceMock {
	if mmGetTestUserWords.defaultExpectation != nil {
		mmGetTestUserWords.mock.t.Fatalf("Default expectation is already set for the Service.GetTestUserWords method")
	}

	if len(mmGetTestUserWords.expectations) > 0 {
		mmGetTestUserWords.mock.t.Fatalf("Some expectations are already set for the Service.GetTestUserWords method")
	}

	mmGetTestUserWords.mock.funcGetTestUserWords = f
	mmGetTestUserWords.mock.funcGetTestUserWordsOrigin = minimock.CallerInfo(1)
	return mmGetTestUserWords.mock
}

// When sets expectation for the Service.GetTestUserWords which will trigger the result defined by the following
// Then helper
func (mmGetTestUserWords *mServiceMockGetTestUserWords) When(ctx context.Context, username string, params service.QueryParams) *ServiceMockGetTestUserWordsExpectation {
	if mmGetTestUserWords.mock.funcGetTestUserWords != nil {
		mmGetTestUserWords.mock.t.Fatalf("ServiceMock.GetTestUserWords mock is already set by Set")
	}

	expectation := &ServiceMockGetTestUserWordsExpectation{
		mock:               mmGetTestUserWords.mock,
		params:             &ServiceMockGetTestUserWordsParams{ctx, username, params},
		expectationOrigins: ServiceMockGetTestUserWordsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTestUserWords.expectations = append(mmGetTestUserWords.expectations, expectation)
	return expectation
}

// Then sets up Service.GetTestUserWords return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetTestUserWordsExpectation) Then(ta1 []service.TestWord, err error) *ServiceMock {
	e.results = &ServiceMockGetTestUserWordsResults{ta1, err}
	return e.mock
}

// Times sets number of times Service.GetTestUserWords should be invoked
func (mmGetTestUserWords *mServiceMockGetTestUserWords) Times(n uint64) *mServiceMockGetTestUserWords {
	if n == 0 {
		mmGetTestUserWords.mock.t.Fatalf("Times of ServiceMock.GetTestUserWords mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTestUserWords.expectedInvocations, n)
	mmGetTestUserWords.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTestUserWords
}

func (mmGetTestUserWords *mServiceMockGetTestUserWords) invocationsDone() bool {
	if len(mmGetTestUserWords.expectations) == 0 && mmGetTestUserWords.defaultExpectation == nil && mmGetTestUserWords.mock.funcGetTestUserWords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTestUserWords.mock.afterGetTestUserWordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTestUserWords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTestUserWords implements mm_exam.Service
func (mmGetTestUserWords *ServiceMock) GetTestUserWords(ctx context.Context, username string, params service.QueryParams) (ta1 []service.TestWord, err error) {
	mm_atomic.AddUint64(&mmGetTestUserWords.beforeGetTestUserWordsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTestUserWords.afterGetTestUserWordsCounter, 1)

	mmGetTestUserWords.t.Helper()

	if mmGetTestUserWords.inspectFuncGetTestUserWords != nil {
		mmGetTestUserWords.inspectFuncGetTestUserWords(ctx, username, params)
	}

	mm_params := ServiceMockGetTestUserWordsParams{ctx, username, params}

	// Record call args
	mmGetTestUserWords.GetTestUserWordsMock.mutex.Lock()
	mmGetTestUserWords.GetTestUserWordsMock.callArgs = append(mmGetTestUserWords.GetTestUserWordsMock.callArgs, &mm_params)
	mmGetTestUserWords.GetTestUserWordsMock.mutex.Unlock()

	for _, e := range mmGetTestUserWords.GetTestUserWordsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetTestUserWords.GetTestUserWordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTestUserWords.GetTestUserWordsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTestUserWords.GetTestUserWordsMock.defaultExpectation.params
		mm_want_ptrs := mmGetTestUserWords.GetTestUserWordsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetTestUserWordsParams{ctx, username, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTestUserWords.t.Errorf("ServiceMock.GetTestUserWords got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTestUserWords.GetTestUserWordsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetTestUserWords.t.Errorf("ServiceMock.GetTestUserWords got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTestUserWords.GetTestUserWordsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetTestUserWords.t.Errorf("ServiceMock.GetTestUserWords got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTestUserWords.GetTestUserWordsMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTestUserWords.t.Errorf("ServiceMock.GetTestUserWords got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTestUserWords.GetTestUserWordsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTestUserWords.GetTestUserWordsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTestUserWords.t.Fatal("No results are set for the ServiceMock.GetTestUserWords")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetTestUserWords.funcGetTestUserWords != nil {
		return mmGetTestUserWords.funcGetTestUserWords(ctx, username, params)
	}
	mmGetTestUserWords.t.Fatalf("Unexpected call to ServiceMock.GetTestUserWords. %v %v %v", ctx, username, params)
	return
}

// GetTestUserWordsAfterCounter returns a count of finished ServiceMock.GetTestUserWords invocations
func (mmGetTestUserWords *ServiceMock) GetTestUserWordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTestUserWords.afterGetTestUserWordsCounter)
}

// GetTestUserWordsBeforeCounter returns a count of ServiceMock.GetTestUserWords invocations
func (mmGetTestUserWords *ServiceMock) GetTestUserWordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTestUserWords.beforeGetTestUserWordsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetTestUserWords.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTestUserWords *mServiceMockGetTestUserWords) Calls() []*ServiceMockGetTestUserWordsParams {
	mmGetTestUserWords.mutex.RLock()

	argCopy := make([]*ServiceMockGetTestUserWordsParams, len(mmGetTestUserWords.callArgs))
	copy(argCopy, mmGetTestUserWords.callArgs)

	mmGetTestUserWords.mutex.RUnlock()

	return argCopy
}

// MinimockGetTestUserWordsDone returns true if the count of the GetTestUserWords invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetTestUserWordsDone() bool {
	if m.GetTestUserWordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTestUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTestUserWordsMock.invocationsDone()
}

// MinimockGetTestUserWordsInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetTestUserWordsInspect() {
	for _, e := range m.GetTestUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetTestUserWords at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTestUserWordsCounter := mm_atomic.LoadUint64(&m.afterGetTestUserWordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTestUserWordsMock.defaultExpectation != nil && afterGetTestUserWordsCounter < 1 {
		if m.GetTestUserWordsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetTestUserWords at\n%s", m.GetTestUserWordsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetTestUserWords at\n%s with params: %#v", m.GetTestUserWordsMock.defaultExpectation.expectationOrigins.origin, *m.GetTestUserWordsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTestUserWords != nil && afterGetTestUserWordsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetTestUserWords at\n%s", m.funcGetTestUserWordsOrigin)
	}

	if !m.GetTestUserWordsMock.invocationsDone() && afterGetTestUserWordsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetTestUserWords at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTestUserWordsMock.expectedInvocations), m.GetTestUserWordsMock.expectedInvocationsOrigin, afterGetTestUserWordsCounter)
	}
}

type mServiceMockVerifyWord struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockVerifyWordExpectation
	expectations       []*ServiceMockVerifyWordExpectation

	callArgs []*ServiceMockVerifyWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockVerifyWordExpectation specifies expectation struct of the Service.VerifyWord
type ServiceMockVerifyWordExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockVerifyWordParams
	paramPtrs          *ServiceMockVerifyWordParamPtrs
	expectationOrigins ServiceMockVerifyWordExpectationOrigins
	results            *ServiceMockVerifyWordResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockVerifyWordParams contains parameters of the Service.VerifyWord
type ServiceMockVerifyWordParams struct {
	ctx      context.Context
	username string
	wordID   string
	answer   string
	enCheck  bool
}

// ServiceMockVerifyWordParamPtrs contains pointers to parameters of the Service.VerifyWord
type ServiceMockVerifyWordParamPtrs struct {
	ctx      *context.Context
	username *string
	wordID   *string
	answer   *string
	enCheck  *bool
}

// ServiceMockVerifyWordResults contains results of the Service.VerifyWord
type ServiceMockVerifyWordResults struct {
	b1  bool
	err error
}

// ServiceMockVerifyWordOrigins contains origins of expectations of the Service.VerifyWord
type ServiceMockVerifyWordExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originWordID   string
	originAnswer   string
	originEnCheck  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmVerifyWord *mServiceMockVerifyWord) Optional() *mServiceMockVerifyWord {
	mmVerifyWord.optional = true
	return mmVerifyWord
}

// Expect sets up expected params for Service.VerifyWord
func (mmVerifyWord *mServiceMockVerifyWord) Expect(ctx context.Context, username string, wordID string, answer string, enCheck bool) *mServiceMockVerifyWord {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ServiceMockVerifyWordExpectation{}
	}

	if mmVerifyWord.defaultExpectation.paramPtrs != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by ExpectParams functions")
	}

	mmVerifyWord.defaultExpectation.params = &ServiceMockVerifyWordParams{ctx, username, wordID, answer, enCheck}
	mmVerifyWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmVerifyWord.expectations {
		if minimock.Equal(e.params, mmVerifyWord.defaultExpectation.params) {
			mmVerifyWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVerifyWord.defaultExpectation.params)
		}
	}

	return mmVerifyWord
}

// ExpectCtxParam1 sets up expected param ctx for Service.VerifyWord
func (mmVerifyWord *mServiceMockVerifyWord) ExpectCtxParam1(ctx context.Context) *mServiceMockVerifyWord {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ServiceMockVerifyWordExpectation{}
	}

	if mmVerifyWord.defaultExpectation.params != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Expect")
	}

	if mmVerifyWord.defaultExpectation.paramPtrs == nil {
		mmVerifyWord.defaultExpectation.paramPtrs = &ServiceMockVerifyWordParamPtrs{}
	}
	mmVerifyWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmVerifyWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmVerifyWord
}

// ExpectUsernameParam2 sets up expected param username for Service.VerifyWord
func (mmVerifyWord *mServiceMockVerifyWord) ExpectUsernameParam2(username string) *mServiceMockVerifyWord {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ServiceMockVerifyWordExpectation{}
	}

	if mmVerifyWord.defaultExpectation.params != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Expect")
	}

	if mmVerifyWord.defaultExpectation.paramPtrs == nil {
		mmVerifyWord.defaultExpectation.paramPtrs = &ServiceMockVerifyWordParamPtrs{}
	}
	mmVerifyWord.defaultExpectation.paramPtrs.username = &username
	mmVerifyWord.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmVerifyWord
}

// ExpectWordIDParam3 sets up expected param wordID for Service.VerifyWord
func (mmVerifyWord *mServiceMockVerifyWord) ExpectWordIDParam3(wordID string) *mServiceMockVerifyWord {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ServiceMockVerifyWordExpectation{}
	}

	if mmVerifyWord.defaultExpectation.params != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Expect")
	}

	if mmVerifyWord.defaultExpectation.paramPtrs == nil {
		mmVerifyWord.defaultExpectation.paramPtrs = &ServiceMockVerifyWordParamPtrs{}
	}
	mmVerifyWord.defaultExpectation.paramPtrs.wordID = &wordID
	mmVerifyWord.defaultExpectation.expectationOrigins.originWordID = minimock.CallerInfo(1)

	return mmVerifyWord
}

// ExpectAnswerParam4 sets up expected param answer for Service.VerifyWord
func (mmVerifyWord *mServiceMockVerifyWord) ExpectAnswerParam4(answer string) *mServiceMockVerifyWord {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ServiceMockVerifyWordExpectation{}
	}

	if mmVerifyWord.defaultExpectation.params != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Expect")
	}

	if mmVerifyWord.defaultExpectation.paramPtrs == nil {
		mmVerifyWord.defaultExpectation.paramPtrs = &ServiceMockVerifyWordParamPtrs{}
	}
	mmVerifyWord.defaultExpectation.paramPtrs.answer = &answer
	mmVerifyWord.defaultExpectation.expectationOrigins.originAnswer = minimock.CallerInfo(1)

	return mmVerifyWord
}

// ExpectEnCheckParam5 sets up expected param enCheck for Service.VerifyWord
func (mmVerifyWord *mServiceMockVerifyWord) ExpectEnCheckParam5(enCheck bool) *mServiceMockVerifyWord {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ServiceMockVerifyWordExpectation{}
	}

	if mmVerifyWord.defaultExpectation.params != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Expect")
	}

	if mmVerifyWord.defaultExpectation.paramPtrs == nil {
		mmVerifyWord.defaultExpectation.paramPtrs = &ServiceMockVerifyWordParamPtrs{}
	}
	mmVerifyWord.defaultExpectation.paramPtrs.enCheck = &enCheck
	mmVerifyWord.defaultExpectation.expectationOrigins.originEnCheck = minimock.CallerInfo(1)

	return mmVerifyWord
}

// Inspect accepts an inspector function that has same arguments as the Service.VerifyWord
func (mmVerifyWord *mServiceMockVerifyWord) Inspect(f func(ctx context.Context, username string, wordID string, answer string, enCheck bool)) *mServiceMockVerifyWord {
	if mmVerifyWord.mock.inspectFuncVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("Inspect function is already set for ServiceMock.VerifyWord")
	}

	mmVerifyWord.mock.inspectFuncVerifyWord = f

	return mmVerifyWord
}

// Return sets up results that will be returned by Service.VerifyWord
func (mmVerifyWord *mServiceMockVerifyWord) Return(b1 bool, err error) *ServiceMock {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ServiceMockVerifyWordExpectation{mock: mmVerifyWord.mock}
	}
	mmVerifyWord.defaultExpectation.results = &ServiceMockVerifyWordResults{b1, err}
	mmVerifyWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmVerifyWord.mock
}

// Set uses given function f to mock the Service.VerifyWord method
func (mmVerifyWord *mServiceMockVerifyWord) Set(f func(ctx context.Context, username string, wordID string, answer string, enCheck bool) (b1 bool, err error)) *ServiceMock {
	if mmVerifyWord.defaultExpectation != nil {
		mmVerifyWord.mock.t.Fatalf("Default expectation is already set for the Service.VerifyWord method")
	}

	if len(mmVerifyWord.expectations) > 0 {
		mmVerifyWord.mock.t.Fatalf("Some expectations are already set for the Service.VerifyWord method")
	}

	mmVerifyWord.mock.funcVerifyWord = f
	mmVerifyWord.mock.funcVerifyWordOrigin = minimock.CallerInfo(1)
	return mmVerifyWord.mock
}

// When sets expectation for the Service.VerifyWord which will trigger the result defined by the following
// Then helper
func (mmVerifyWord *mServiceMockVerifyWord) When(ctx context.Context, username string, wordID string, answer string, enCheck bool) *ServiceMockVerifyWordExpectation {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ServiceMock.VerifyWord mock is already set by Set")
	}

	expectation := &ServiceMockVerifyWordExpectation{
		mock:               mmVerifyWord.mock,
		params:             &ServiceMockVerifyWordParams{ctx, username, wordID, answer, enCheck},
		expectationOrigins: ServiceMockVerifyWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmVerifyWord.expectations = append(mmVerifyWord.expectations, expectation)
	return expectation
}

// Then sets up Service.VerifyWord return parameters for the expectation previously defined by the When method
func (e *ServiceMockVerifyWordExpectation) Then(b1 bool, err error) *ServiceMock {
	e.results = &ServiceMockVerifyWordResults{b1, err}
	return e.mock
}

// Times sets number of times Service.VerifyWord should be invoked
func (mmVerifyWord *mServiceMockVerifyWord) Times(n uint64) *mServiceMockVerifyWord {
	if n == 0 {
		mmVerifyWord.mock.t.Fatalf("Times of ServiceMock.VerifyWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmVerifyWord.expectedInvocations, n)
	mmVerifyWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmVerifyWord
}

func (mmVerifyWord *mServiceMockVerifyWord) invocationsDone() bool {
	if len(mmVerifyWord.expectations) == 0 && mmVerifyWord.defaultExpectation == nil && mmVerifyWord.mock.funcVerifyWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmVerifyWord.mock.afterVerifyWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmVerifyWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// VerifyWord implements mm_exam.Service
func (mmVerifyWord *ServiceMock) VerifyWord(ctx context.Context, username string, wordID string, answer string, enCheck bool) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmVerifyWord.beforeVerifyWordCounter, 1)
	defer mm_atomic.AddUint64(&mmVerifyWord.afterVerifyWordCounter, 1)

	mmVerifyWord.t.Helper()

	if mmVerifyWord.inspectFuncVerifyWord != nil {
		mmVerifyWord.inspectFuncVerifyWord(ctx, username, wordID, answer, enCheck)
	}

	mm_params := ServiceMockVerifyWordParams{ctx, username, wordID, answer, enCheck}

	// Record call args
	mmVerifyWord.VerifyWordMock.mutex.Lock()
	mmVerifyWord.VerifyWordMock.callArgs = append(mmVerifyWord.VerifyWordMock.callArgs, &mm_params)
	mmVerifyWord.VerifyWordMock.mutex.Unlock()

	for _, e := range mmVerifyWord.VerifyWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmVerifyWord.VerifyWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVerifyWord.VerifyWordMock.defaultExpectation.Counter, 1)
		mm_want := mmVerifyWord.VerifyWordMock.defaultExpectation.params
		mm_want_ptrs := mmVerifyWord.VerifyWordMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockVerifyWordParams{ctx, username, wordID, answer, enCheck}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmVerifyWord.t.Errorf("ServiceMock.VerifyWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyWord.VerifyWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmVerifyWord.t.Errorf("ServiceMock.VerifyWord got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyWord.VerifyWordMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.wordID != nil && !minimock.Equal(*mm_want_ptrs.wordID, mm_got.wordID) {
				mmVerifyWord.t.Errorf("ServiceMock.VerifyWord got unexpected parameter wordID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyWord.VerifyWordMock.defaultExpectation.expectationOrigins.originWordID, *mm_want_ptrs.wordID, mm_got.wordID, minimock.Diff(*mm_want_ptrs.wordID, mm_got.wordID))
			}

			if mm_want_ptrs.answer != nil && !minimock.Equal(*mm_want_ptrs.answer, mm_got.answer) {
				mmVerifyWord.t.Errorf("ServiceMock.VerifyWord got unexpected parameter answer, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyWord.VerifyWordMock.defaultExpectation.expectationOrigins.originAnswer, *mm_want_ptrs.answer, mm_got.answer, minimock.Diff(*mm_want_ptrs.answer, mm_got.answer))
			}

			if mm_want_ptrs.enCheck != nil && !minimock.Equal(*mm_want_ptrs.enCheck, mm_got.enCheck) {
				mmVerifyWord.t.Errorf("ServiceMock.VerifyWord got unexpected parameter enCheck, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyWord.VerifyWordMock.defaultExpectation.expectationOrigins.originEnCheck, *mm_want_ptrs.enCheck, mm_got.enCheck, minimock.Diff(*mm_want_ptrs.enCheck, mm_got.enCheck))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVerifyWord.t.Errorf("ServiceMock.VerifyWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmVerifyWord.VerifyWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVerifyWord.VerifyWordMock.defaultExpectation.results
		if mm_results == nil {
			mmVerifyWord.t.Fatal("No results are set for the ServiceMock.VerifyWord")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmVerifyWord.funcVerifyWord != nil {
		return mmVerifyWord.funcVerifyWord(ctx, username, wordID, answer, enCheck)
	}
	mmVerifyWord.t.Fatalf("Unexpected call to ServiceMock.VerifyWord. %v %v %v %v %v", ctx, username, wordID, answer, enCheck)
	return
}

// VerifyWordAfterCounter returns a count of finished ServiceMock.VerifyWord invocations
func (mmVerifyWord *ServiceMock) VerifyWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyWord.afterVerifyWordCounter)
}

// VerifyWordBeforeCounter returns a count of ServiceMock.VerifyWord invocations
func (mmVerifyWord *ServiceMock) VerifyWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyWord.beforeVerifyWordCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.VerifyWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVerifyWord *mServiceMockVerifyWord) Calls() []*ServiceMockVerifyWordParams {
	mmVerifyWord.mutex.RLock()

	argCopy := make([]*ServiceMockVerifyWordParams, len(mmVerifyWord.callArgs))
	copy(argCopy, mmVerifyWord.callArgs)

	mmVerifyWord.mutex.RUnlock()

	return argCopy
}

// MinimockVerifyWordDone returns true if the count of the VerifyWord invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockVerifyWordDone() bool {
	if m.VerifyWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.VerifyWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.VerifyWordMock.invocationsDone()
}

// MinimockVerifyWordInspect logs each unmet expectation
func (m *ServiceMock) MinimockVerifyWordInspect() {
	for _, e := range m.VerifyWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.VerifyWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterVerifyWordCounter := mm_atomic.LoadUint64(&m.afterVerifyWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.VerifyWordMock.defaultExpectation != nil && afterVerifyWordCounter < 1 {
		if m.VerifyWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.VerifyWord at\n%s", m.VerifyWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.VerifyWord at\n%s with params: %#v", m.VerifyWordMock.defaultExpectation.expectationOrigins.origin, *m.VerifyWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVerifyWord != nil && afterVerifyWordCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.VerifyWord at\n%s", m.funcVerifyWordOrigin)
	}

	if !m.VerifyWordMock.invocationsDone() && afterVerifyWordCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.VerifyWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.VerifyWordMock.expectedInvocations), m.VerifyWordMock.expectedInvocationsOrigin, afterVerifyWordCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetTestUserWordsInspect()

			m.MinimockVerifyWordInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetTestUserWordsDone() &&
		m.MinimockVerifyWordDone()
}
