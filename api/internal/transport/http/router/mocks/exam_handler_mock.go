// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/transport/http/router.ExamHandler -o exam_handler_mock.go -n ExamHandlerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gin-gonic/gin"
	"github.com/gojuno/minimock/v3"
)

// ExamHandlerMock implements mm_router.ExamHandler
type ExamHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcTestUser          func(c *gin.Context)
	funcTestUserOrigin    string
	inspectFuncTestUser   func(c *gin.Context)
	afterTestUserCounter  uint64
	beforeTestUserCounter uint64
	TestUserMock          mExamHandlerMockTestUser

	funcVerifyWord          func(c *gin.Context)
	funcVerifyWordOrigin    string
	inspectFuncVerifyWord   func(c *gin.Context)
	afterVerifyWordCounter  uint64
	beforeVerifyWordCounter uint64
	VerifyWordMock          mExamHandlerMockVerifyWord
}

// NewExamHandlerMock returns a mock for mm_router.ExamHandler
func NewExamHandlerMock(t minimock.Tester) *ExamHandlerMock {
	m := &ExamHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.TestUserMock = mExamHandlerMockTestUser{mock: m}
	m.TestUserMock.callArgs = []*ExamHandlerMockTestUserParams{}

	m.VerifyWordMock = mExamHandlerMockVerifyWord{mock: m}
	m.VerifyWordMock.callArgs = []*ExamHandlerMockVerifyWordParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mExamHandlerMockTestUser struct {
	optional           bool
	mock               *ExamHandlerMock
	defaultExpectation *ExamHandlerMockTestUserExpectation
	expectations       []*ExamHandlerMockTestUserExpectation

	callArgs []*ExamHandlerMockTestUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamHandlerMockTestUserExpectation specifies expectation struct of the ExamHandler.TestUser
type ExamHandlerMockTestUserExpectation struct {
	mock               *ExamHandlerMock
	params             *ExamHandlerMockTestUserParams
	paramPtrs          *ExamHandlerMockTestUserParamPtrs
	expectationOrigins ExamHandlerMockTestUserExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// ExamHandlerMockTestUserParams contains parameters of the ExamHandler.TestUser
type ExamHandlerMockTestUserParams struct {
	c *gin.Context
}

// ExamHandlerMockTestUserParamPtrs contains pointers to parameters of the ExamHandler.TestUser
type ExamHandlerMockTestUserParamPtrs struct {
	c **gin.Context
}

// ExamHandlerMockTestUserOrigins contains origins of expectations of the ExamHandler.TestUser
type ExamHandlerMockTestUserExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTestUser *mExamHandlerMockTestUser) Optional() *mExamHandlerMockTestUser {
	mmTestUser.optional = true
	return mmTestUser
}

// Expect sets up expected params for ExamHandler.TestUser
func (mmTestUser *mExamHandlerMockTestUser) Expect(c *gin.Context) *mExamHandlerMockTestUser {
	if mmTestUser.mock.funcTestUser != nil {
		mmTestUser.mock.t.Fatalf("ExamHandlerMock.TestUser mock is already set by Set")
	}

	if mmTestUser.defaultExpectation == nil {
		mmTestUser.defaultExpectation = &ExamHandlerMockTestUserExpectation{}
	}

	if mmTestUser.defaultExpectation.paramPtrs != nil {
		mmTestUser.mock.t.Fatalf("ExamHandlerMock.TestUser mock is already set by ExpectParams functions")
	}

	mmTestUser.defaultExpectation.params = &ExamHandlerMockTestUserParams{c}
	mmTestUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTestUser.expectations {
		if minimock.Equal(e.params, mmTestUser.defaultExpectation.params) {
			mmTestUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTestUser.defaultExpectation.params)
		}
	}

	return mmTestUser
}

// ExpectCParam1 sets up expected param c for ExamHandler.TestUser
func (mmTestUser *mExamHandlerMockTestUser) ExpectCParam1(c *gin.Context) *mExamHandlerMockTestUser {
	if mmTestUser.mock.funcTestUser != nil {
		mmTestUser.mock.t.Fatalf("ExamHandlerMock.TestUser mock is already set by Set")
	}

	if mmTestUser.defaultExpectation == nil {
		mmTestUser.defaultExpectation = &ExamHandlerMockTestUserExpectation{}
	}

	if mmTestUser.defaultExpectation.params != nil {
		mmTestUser.mock.t.Fatalf("ExamHandlerMock.TestUser mock is already set by Expect")
	}

	if mmTestUser.defaultExpectation.paramPtrs == nil {
		mmTestUser.defaultExpectation.paramPtrs = &ExamHandlerMockTestUserParamPtrs{}
	}
	mmTestUser.defaultExpectation.paramPtrs.c = &c
	mmTestUser.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmTestUser
}

// Inspect accepts an inspector function that has same arguments as the ExamHandler.TestUser
func (mmTestUser *mExamHandlerMockTestUser) Inspect(f func(c *gin.Context)) *mExamHandlerMockTestUser {
	if mmTestUser.mock.inspectFuncTestUser != nil {
		mmTestUser.mock.t.Fatalf("Inspect function is already set for ExamHandlerMock.TestUser")
	}

	mmTestUser.mock.inspectFuncTestUser = f

	return mmTestUser
}

// Return sets up results that will be returned by ExamHandler.TestUser
func (mmTestUser *mExamHandlerMockTestUser) Return() *ExamHandlerMock {
	if mmTestUser.mock.funcTestUser != nil {
		mmTestUser.mock.t.Fatalf("ExamHandlerMock.TestUser mock is already set by Set")
	}

	if mmTestUser.defaultExpectation == nil {
		mmTestUser.defaultExpectation = &ExamHandlerMockTestUserExpectation{mock: mmTestUser.mock}
	}

	mmTestUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTestUser.mock
}

// Set uses given function f to mock the ExamHandler.TestUser method
func (mmTestUser *mExamHandlerMockTestUser) Set(f func(c *gin.Context)) *ExamHandlerMock {
	if mmTestUser.defaultExpectation != nil {
		mmTestUser.mock.t.Fatalf("Default expectation is already set for the ExamHandler.TestUser method")
	}

	if len(mmTestUser.expectations) > 0 {
		mmTestUser.mock.t.Fatalf("Some expectations are already set for the ExamHandler.TestUser method")
	}

	mmTestUser.mock.funcTestUser = f
	mmTestUser.mock.funcTestUserOrigin = minimock.CallerInfo(1)
	return mmTestUser.mock
}

// When sets expectation for the ExamHandler.TestUser which will trigger the result defined by the following
// Then helper
func (mmTestUser *mExamHandlerMockTestUser) When(c *gin.Context) *ExamHandlerMockTestUserExpectation {
	if mmTestUser.mock.funcTestUser != nil {
		mmTestUser.mock.t.Fatalf("ExamHandlerMock.TestUser mock is already set by Set")
	}

	expectation := &ExamHandlerMockTestUserExpectation{
		mock:               mmTestUser.mock,
		params:             &ExamHandlerMockTestUserParams{c},
		expectationOrigins: ExamHandlerMockTestUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTestUser.expectations = append(mmTestUser.expectations, expectation)
	return expectation
}

// Then sets up ExamHandler.TestUser return parameters for the expectation previously defined by the When method

func (e *ExamHandlerMockTestUserExpectation) Then() *ExamHandlerMock {
	return e.mock
}

// Times sets number of times ExamHandler.TestUser should be invoked
func (mmTestUser *mExamHandlerMockTestUser) Times(n uint64) *mExamHandlerMockTestUser {
	if n == 0 {
		mmTestUser.mock.t.Fatalf("Times of ExamHandlerMock.TestUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTestUser.expectedInvocations, n)
	mmTestUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTestUser
}

func (mmTestUser *mExamHandlerMockTestUser) invocationsDone() bool {
	if len(mmTestUser.expectations) == 0 && mmTestUser.defaultExpectation == nil && mmTestUser.mock.funcTestUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTestUser.mock.afterTestUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTestUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TestUser implements mm_router.ExamHandler
func (mmTestUser *ExamHandlerMock) TestUser(c *gin.Context) {
	mm_atomic.AddUint64(&mmTestUser.beforeTestUserCounter, 1)
	defer mm_atomic.AddUint64(&mmTestUser.afterTestUserCounter, 1)

	mmTestUser.t.Helper()

	if mmTestUser.inspectFuncTestUser != nil {
		mmTestUser.inspectFuncTestUser(c)
	}

	mm_params := ExamHandlerMockTestUserParams{c}

	// Record call args
	mmTestUser.TestUserMock.mutex.Lock()
	mmTestUser.TestUserMock.callArgs = append(mmTestUser.TestUserMock.callArgs, &mm_params)
	mmTestUser.TestUserMock.mutex.Unlock()

	for _, e := range mmTestUser.TestUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmTestUser.TestUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTestUser.TestUserMock.defaultExpectation.Counter, 1)
		mm_want := mmTestUser.TestUserMock.defaultExpectation.params
		mm_want_ptrs := mmTestUser.TestUserMock.defaultExpectation.paramPtrs

		mm_got := ExamHandlerMockTestUserParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmTestUser.t.Errorf("ExamHandlerMock.TestUser got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTestUser.TestUserMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTestUser.t.Errorf("ExamHandlerMock.TestUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTestUser.TestUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmTestUser.funcTestUser != nil {
		mmTestUser.funcTestUser(c)
		return
	}
	mmTestUser.t.Fatalf("Unexpected call to ExamHandlerMock.TestUser. %v", c)

}

// TestUserAfterCounter returns a count of finished ExamHandlerMock.TestUser invocations
func (mmTestUser *ExamHandlerMock) TestUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTestUser.afterTestUserCounter)
}

// TestUserBeforeCounter returns a count of ExamHandlerMock.TestUser invocations
func (mmTestUser *ExamHandlerMock) TestUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTestUser.beforeTestUserCounter)
}

// Calls returns a list of arguments used in each call to ExamHandlerMock.TestUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTestUser *mExamHandlerMockTestUser) Calls() []*ExamHandlerMockTestUserParams {
	mmTestUser.mutex.RLock()

	argCopy := make([]*ExamHandlerMockTestUserParams, len(mmTestUser.callArgs))
	copy(argCopy, mmTestUser.callArgs)

	mmTestUser.mutex.RUnlock()

	return argCopy
}

// MinimockTestUserDone returns true if the count of the TestUser invocations corresponds
// the number of defined expectations
func (m *ExamHandlerMock) MinimockTestUserDone() bool {
	if m.TestUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TestUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TestUserMock.invocationsDone()
}

// MinimockTestUserInspect logs each unmet expectation
func (m *ExamHandlerMock) MinimockTestUserInspect() {
	for _, e := range m.TestUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamHandlerMock.TestUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTestUserCounter := mm_atomic.LoadUint64(&m.afterTestUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TestUserMock.defaultExpectation != nil && afterTestUserCounter < 1 {
		if m.TestUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamHandlerMock.TestUser at\n%s", m.TestUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamHandlerMock.TestUser at\n%s with params: %#v", m.TestUserMock.defaultExpectation.expectationOrigins.origin, *m.TestUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTestUser != nil && afterTestUserCounter < 1 {
		m.t.Errorf("Expected call to ExamHandlerMock.TestUser at\n%s", m.funcTestUserOrigin)
	}

	if !m.TestUserMock.invocationsDone() && afterTestUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamHandlerMock.TestUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TestUserMock.expectedInvocations), m.TestUserMock.expectedInvocationsOrigin, afterTestUserCounter)
	}
}

type mExamHandlerMockVerifyWord struct {
	optional           bool
	mock               *ExamHandlerMock
	defaultExpectation *ExamHandlerMockVerifyWordExpectation
	expectations       []*ExamHandlerMockVerifyWordExpectation

	callArgs []*ExamHandlerMockVerifyWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamHandlerMockVerifyWordExpectation specifies expectation struct of the ExamHandler.VerifyWord
type ExamHandlerMockVerifyWordExpectation struct {
	mock               *ExamHandlerMock
	params             *ExamHandlerMockVerifyWordParams
	paramPtrs          *ExamHandlerMockVerifyWordParamPtrs
	expectationOrigins ExamHandlerMockVerifyWordExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// ExamHandlerMockVerifyWordParams contains parameters of the ExamHandler.VerifyWord
type ExamHandlerMockVerifyWordParams struct {
	c *gin.Context
}

// ExamHandlerMockVerifyWordParamPtrs contains pointers to parameters of the ExamHandler.VerifyWord
type ExamHandlerMockVerifyWordParamPtrs struct {
	c **gin.Context
}

// ExamHandlerMockVerifyWordOrigins contains origins of expectations of the ExamHandler.VerifyWord
type ExamHandlerMockVerifyWordExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmVerifyWord *mExamHandlerMockVerifyWord) Optional() *mExamHandlerMockVerifyWord {
	mmVerifyWord.optional = true
	return mmVerifyWord
}

// Expect sets up expected params for ExamHandler.VerifyWord
func (mmVerifyWord *mExamHandlerMockVerifyWord) Expect(c *gin.Context) *mExamHandlerMockVerifyWord {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ExamHandlerMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ExamHandlerMockVerifyWordExpectation{}
	}

	if mmVerifyWord.defaultExpectation.paramPtrs != nil {
		mmVerifyWord.mock.t.Fatalf("ExamHandlerMock.VerifyWord mock is already set by ExpectParams functions")
	}

	mmVerifyWord.defaultExpectation.params = &ExamHandlerMockVerifyWordParams{c}
	mmVerifyWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmVerifyWord.expectations {
		if minimock.Equal(e.params, mmVerifyWord.defaultExpectation.params) {
			mmVerifyWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVerifyWord.defaultExpectation.params)
		}
	}

	return mmVerifyWord
}

// ExpectCParam1 sets up expected param c for ExamHandler.VerifyWord
func (mmVerifyWord *mExamHandlerMockVerifyWord) ExpectCParam1(c *gin.Context) *mExamHandlerMockVerifyWord {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ExamHandlerMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ExamHandlerMockVerifyWordExpectation{}
	}

	if mmVerifyWord.defaultExpectation.params != nil {
		mmVerifyWord.mock.t.Fatalf("ExamHandlerMock.VerifyWord mock is already set by Expect")
	}

	if mmVerifyWord.defaultExpectation.paramPtrs == nil {
		mmVerifyWord.defaultExpectation.paramPtrs = &ExamHandlerMockVerifyWordParamPtrs{}
	}
	mmVerifyWord.defaultExpectation.paramPtrs.c = &c
	mmVerifyWord.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmVerifyWord
}

// Inspect accepts an inspector function that has same arguments as the ExamHandler.VerifyWord
func (mmVerifyWord *mExamHandlerMockVerifyWord) Inspect(f func(c *gin.Context)) *mExamHandlerMockVerifyWord {
	if mmVerifyWord.mock.inspectFuncVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("Inspect function is already set for ExamHandlerMock.VerifyWord")
	}

	mmVerifyWord.mock.inspectFuncVerifyWord = f

	return mmVerifyWord
}

// Return sets up results that will be returned by ExamHandler.VerifyWord
func (mmVerifyWord *mExamHandlerMockVerifyWord) Return() *ExamHandlerMock {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ExamHandlerMock.VerifyWord mock is already set by Set")
	}

	if mmVerifyWord.defaultExpectation == nil {
		mmVerifyWord.defaultExpectation = &ExamHandlerMockVerifyWordExpectation{mock: mmVerifyWord.mock}
	}

	mmVerifyWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmVerifyWord.mock
}

// Set uses given function f to mock the ExamHandler.VerifyWord method
func (mmVerifyWord *mExamHandlerMockVerifyWord) Set(f func(c *gin.Context)) *ExamHandlerMock {
	if mmVerifyWord.defaultExpectation != nil {
		mmVerifyWord.mock.t.Fatalf("Default expectation is already set for the ExamHandler.VerifyWord method")
	}

	if len(mmVerifyWord.expectations) > 0 {
		mmVerifyWord.mock.t.Fatalf("Some expectations are already set for the ExamHandler.VerifyWord method")
	}

	mmVerifyWord.mock.funcVerifyWord = f
	mmVerifyWord.mock.funcVerifyWordOrigin = minimock.CallerInfo(1)
	return mmVerifyWord.mock
}

// When sets expectation for the ExamHandler.VerifyWord which will trigger the result defined by the following
// Then helper
func (mmVerifyWord *mExamHandlerMockVerifyWord) When(c *gin.Context) *ExamHandlerMockVerifyWordExpectation {
	if mmVerifyWord.mock.funcVerifyWord != nil {
		mmVerifyWord.mock.t.Fatalf("ExamHandlerMock.VerifyWord mock is already set by Set")
	}

	expectation := &ExamHandlerMockVerifyWordExpectation{
		mock:               mmVerifyWord.mock,
		params:             &ExamHandlerMockVerifyWordParams{c},
		expectationOrigins: ExamHandlerMockVerifyWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmVerifyWord.expectations = append(mmVerifyWord.expectations, expectation)
	return expectation
}

// Then sets up ExamHandler.VerifyWord return parameters for the expectation previously defined by the When method

func (e *ExamHandlerMockVerifyWordExpectation) Then() *ExamHandlerMock {
	return e.mock
}

// Times sets number of times ExamHandler.VerifyWord should be invoked
func (mmVerifyWord *mExamHandlerMockVerifyWord) Times(n uint64) *mExamHandlerMockVerifyWord {
	if n == 0 {
		mmVerifyWord.mock.t.Fatalf("Times of ExamHandlerMock.VerifyWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmVerifyWord.expectedInvocations, n)
	mmVerifyWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmVerifyWord
}

func (mmVerifyWord *mExamHandlerMockVerifyWord) invocationsDone() bool {
	if len(mmVerifyWord.expectations) == 0 && mmVerifyWord.defaultExpectation == nil && mmVerifyWord.mock.funcVerifyWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmVerifyWord.mock.afterVerifyWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmVerifyWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// VerifyWord implements mm_router.ExamHandler
func (mmVerifyWord *ExamHandlerMock) VerifyWord(c *gin.Context) {
	mm_atomic.AddUint64(&mmVerifyWord.beforeVerifyWordCounter, 1)
	defer mm_atomic.AddUint64(&mmVerifyWord.afterVerifyWordCounter, 1)

	mmVerifyWord.t.Helper()

	if mmVerifyWord.inspectFuncVerifyWord != nil {
		mmVerifyWord.inspectFuncVerifyWord(c)
	}

	mm_params := ExamHandlerMockVerifyWordParams{c}

	// Record call args
	mmVerifyWord.VerifyWordMock.mutex.Lock()
	mmVerifyWord.VerifyWordMock.callArgs = append(mmVerifyWord.VerifyWordMock.callArgs, &mm_params)
	mmVerifyWord.VerifyWordMock.mutex.Unlock()

	for _, e := range mmVerifyWord.VerifyWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmVerifyWord.VerifyWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVerifyWord.VerifyWordMock.defaultExpectation.Counter, 1)
		mm_want := mmVerifyWord.VerifyWordMock.defaultExpectation.params
		mm_want_ptrs := mmVerifyWord.VerifyWordMock.defaultExpectation.paramPtrs

		mm_got := ExamHandlerMockVerifyWordParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmVerifyWord.t.Errorf("ExamHandlerMock.VerifyWord got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyWord.VerifyWordMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVerifyWord.t.Errorf("ExamHandlerMock.VerifyWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmVerifyWord.VerifyWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmVerifyWord.funcVerifyWord != nil {
		mmVerifyWord.funcVerifyWord(c)
		return
	}
	mmVerifyWord.t.Fatalf("Unexpected call to ExamHandlerMock.VerifyWord. %v", c)

}

// VerifyWordAfterCounter returns a count of finished ExamHandlerMock.VerifyWord invocations
func (mmVerifyWord *ExamHandlerMock) VerifyWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyWord.afterVerifyWordCounter)
}

// VerifyWordBeforeCounter returns a count of ExamHandlerMock.VerifyWord invocations
func (mmVerifyWord *ExamHandlerMock) VerifyWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyWord.beforeVerifyWordCounter)
}

// Calls returns a list of arguments used in each call to ExamHandlerMock.VerifyWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVerifyWord *mExamHandlerMockVerifyWord) Calls() []*ExamHandlerMockVerifyWordParams {
	mmVerifyWord.mutex.RLock()

	argCopy := make([]*ExamHandlerMockVerifyWordParams, len(mmVerifyWord.callArgs))
	copy(argCopy, mmVerifyWord.callArgs)

	mmVerifyWord.mutex.RUnlock()

	return argCopy
}

// MinimockVerifyWordDone returns true if the count of the VerifyWord invocations corresponds
// the number of defined expectations
func (m *ExamHandlerMock) MinimockVerifyWordDone() bool {
	if m.VerifyWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.VerifyWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.VerifyWordMock.invocationsDone()
}

// MinimockVerifyWordInspect logs each unmet expectation
func (m *ExamHandlerMock) MinimockVerifyWordInspect() {
	for _, e := range m.VerifyWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamHandlerMock.VerifyWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterVerifyWordCounter := mm_atomic.LoadUint64(&m.afterVerifyWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.VerifyWordMock.defaultExpectation != nil && afterVerifyWordCounter < 1 {
		if m.VerifyWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamHandlerMock.VerifyWord at\n%s", m.VerifyWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamHandlerMock.VerifyWord at\n%s with params: %#v", m.VerifyWordMock.defaultExpectation.expectationOrigins.origin, *m.VerifyWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVerifyWord != nil && afterVerifyWordCounter < 1 {
		m.t.Errorf("Expected call to ExamHandlerMock.VerifyWord at\n%s", m.funcVerifyWordOrigin)
	}

	if !m.VerifyWordMock.invocationsDone() && afterVerifyWordCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamHandlerMock.VerifyWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.VerifyWordMock.expectedInvocations), m.VerifyWordMock.expectedInvocationsOrigin, afterVerifyWordCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExamHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockTestUserInspect()

			m.MinimockVerifyWordInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExamHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExamHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockTestUserDone() &&
		m.MinimockVerifyWordDone()
}
