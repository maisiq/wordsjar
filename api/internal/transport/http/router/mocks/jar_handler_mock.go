// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/transport/http/router.JarHandler -o jar_handler_mock.go -n JarHandlerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gin-gonic/gin"
	"github.com/gojuno/minimock/v3"
)

// JarHandlerMock implements mm_router.JarHandler
type JarHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddWordToJar          func(c *gin.Context)
	funcAddWordToJarOrigin    string
	inspectFuncAddWordToJar   func(c *gin.Context)
	afterAddWordToJarCounter  uint64
	beforeAddWordToJarCounter uint64
	AddWordToJarMock          mJarHandlerMockAddWordToJar

	funcGetUserWords          func(c *gin.Context)
	funcGetUserWordsOrigin    string
	inspectFuncGetUserWords   func(c *gin.Context)
	afterGetUserWordsCounter  uint64
	beforeGetUserWordsCounter uint64
	GetUserWordsMock          mJarHandlerMockGetUserWords
}

// NewJarHandlerMock returns a mock for mm_router.JarHandler
func NewJarHandlerMock(t minimock.Tester) *JarHandlerMock {
	m := &JarHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddWordToJarMock = mJarHandlerMockAddWordToJar{mock: m}
	m.AddWordToJarMock.callArgs = []*JarHandlerMockAddWordToJarParams{}

	m.GetUserWordsMock = mJarHandlerMockGetUserWords{mock: m}
	m.GetUserWordsMock.callArgs = []*JarHandlerMockGetUserWordsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mJarHandlerMockAddWordToJar struct {
	optional           bool
	mock               *JarHandlerMock
	defaultExpectation *JarHandlerMockAddWordToJarExpectation
	expectations       []*JarHandlerMockAddWordToJarExpectation

	callArgs []*JarHandlerMockAddWordToJarParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JarHandlerMockAddWordToJarExpectation specifies expectation struct of the JarHandler.AddWordToJar
type JarHandlerMockAddWordToJarExpectation struct {
	mock               *JarHandlerMock
	params             *JarHandlerMockAddWordToJarParams
	paramPtrs          *JarHandlerMockAddWordToJarParamPtrs
	expectationOrigins JarHandlerMockAddWordToJarExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// JarHandlerMockAddWordToJarParams contains parameters of the JarHandler.AddWordToJar
type JarHandlerMockAddWordToJarParams struct {
	c *gin.Context
}

// JarHandlerMockAddWordToJarParamPtrs contains pointers to parameters of the JarHandler.AddWordToJar
type JarHandlerMockAddWordToJarParamPtrs struct {
	c **gin.Context
}

// JarHandlerMockAddWordToJarOrigins contains origins of expectations of the JarHandler.AddWordToJar
type JarHandlerMockAddWordToJarExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddWordToJar *mJarHandlerMockAddWordToJar) Optional() *mJarHandlerMockAddWordToJar {
	mmAddWordToJar.optional = true
	return mmAddWordToJar
}

// Expect sets up expected params for JarHandler.AddWordToJar
func (mmAddWordToJar *mJarHandlerMockAddWordToJar) Expect(c *gin.Context) *mJarHandlerMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarHandlerMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarHandlerMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs != nil {
		mmAddWordToJar.mock.t.Fatalf("JarHandlerMock.AddWordToJar mock is already set by ExpectParams functions")
	}

	mmAddWordToJar.defaultExpectation.params = &JarHandlerMockAddWordToJarParams{c}
	mmAddWordToJar.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddWordToJar.expectations {
		if minimock.Equal(e.params, mmAddWordToJar.defaultExpectation.params) {
			mmAddWordToJar.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddWordToJar.defaultExpectation.params)
		}
	}

	return mmAddWordToJar
}

// ExpectCParam1 sets up expected param c for JarHandler.AddWordToJar
func (mmAddWordToJar *mJarHandlerMockAddWordToJar) ExpectCParam1(c *gin.Context) *mJarHandlerMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarHandlerMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarHandlerMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("JarHandlerMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &JarHandlerMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.c = &c
	mmAddWordToJar.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// Inspect accepts an inspector function that has same arguments as the JarHandler.AddWordToJar
func (mmAddWordToJar *mJarHandlerMockAddWordToJar) Inspect(f func(c *gin.Context)) *mJarHandlerMockAddWordToJar {
	if mmAddWordToJar.mock.inspectFuncAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("Inspect function is already set for JarHandlerMock.AddWordToJar")
	}

	mmAddWordToJar.mock.inspectFuncAddWordToJar = f

	return mmAddWordToJar
}

// Return sets up results that will be returned by JarHandler.AddWordToJar
func (mmAddWordToJar *mJarHandlerMockAddWordToJar) Return() *JarHandlerMock {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarHandlerMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarHandlerMockAddWordToJarExpectation{mock: mmAddWordToJar.mock}
	}

	mmAddWordToJar.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar.mock
}

// Set uses given function f to mock the JarHandler.AddWordToJar method
func (mmAddWordToJar *mJarHandlerMockAddWordToJar) Set(f func(c *gin.Context)) *JarHandlerMock {
	if mmAddWordToJar.defaultExpectation != nil {
		mmAddWordToJar.mock.t.Fatalf("Default expectation is already set for the JarHandler.AddWordToJar method")
	}

	if len(mmAddWordToJar.expectations) > 0 {
		mmAddWordToJar.mock.t.Fatalf("Some expectations are already set for the JarHandler.AddWordToJar method")
	}

	mmAddWordToJar.mock.funcAddWordToJar = f
	mmAddWordToJar.mock.funcAddWordToJarOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar.mock
}

// When sets expectation for the JarHandler.AddWordToJar which will trigger the result defined by the following
// Then helper
func (mmAddWordToJar *mJarHandlerMockAddWordToJar) When(c *gin.Context) *JarHandlerMockAddWordToJarExpectation {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarHandlerMock.AddWordToJar mock is already set by Set")
	}

	expectation := &JarHandlerMockAddWordToJarExpectation{
		mock:               mmAddWordToJar.mock,
		params:             &JarHandlerMockAddWordToJarParams{c},
		expectationOrigins: JarHandlerMockAddWordToJarExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddWordToJar.expectations = append(mmAddWordToJar.expectations, expectation)
	return expectation
}

// Then sets up JarHandler.AddWordToJar return parameters for the expectation previously defined by the When method

func (e *JarHandlerMockAddWordToJarExpectation) Then() *JarHandlerMock {
	return e.mock
}

// Times sets number of times JarHandler.AddWordToJar should be invoked
func (mmAddWordToJar *mJarHandlerMockAddWordToJar) Times(n uint64) *mJarHandlerMockAddWordToJar {
	if n == 0 {
		mmAddWordToJar.mock.t.Fatalf("Times of JarHandlerMock.AddWordToJar mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddWordToJar.expectedInvocations, n)
	mmAddWordToJar.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar
}

func (mmAddWordToJar *mJarHandlerMockAddWordToJar) invocationsDone() bool {
	if len(mmAddWordToJar.expectations) == 0 && mmAddWordToJar.defaultExpectation == nil && mmAddWordToJar.mock.funcAddWordToJar == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddWordToJar.mock.afterAddWordToJarCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddWordToJar.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddWordToJar implements mm_router.JarHandler
func (mmAddWordToJar *JarHandlerMock) AddWordToJar(c *gin.Context) {
	mm_atomic.AddUint64(&mmAddWordToJar.beforeAddWordToJarCounter, 1)
	defer mm_atomic.AddUint64(&mmAddWordToJar.afterAddWordToJarCounter, 1)

	mmAddWordToJar.t.Helper()

	if mmAddWordToJar.inspectFuncAddWordToJar != nil {
		mmAddWordToJar.inspectFuncAddWordToJar(c)
	}

	mm_params := JarHandlerMockAddWordToJarParams{c}

	// Record call args
	mmAddWordToJar.AddWordToJarMock.mutex.Lock()
	mmAddWordToJar.AddWordToJarMock.callArgs = append(mmAddWordToJar.AddWordToJarMock.callArgs, &mm_params)
	mmAddWordToJar.AddWordToJarMock.mutex.Unlock()

	for _, e := range mmAddWordToJar.AddWordToJarMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddWordToJar.AddWordToJarMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddWordToJar.AddWordToJarMock.defaultExpectation.Counter, 1)
		mm_want := mmAddWordToJar.AddWordToJarMock.defaultExpectation.params
		mm_want_ptrs := mmAddWordToJar.AddWordToJarMock.defaultExpectation.paramPtrs

		mm_got := JarHandlerMockAddWordToJarParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmAddWordToJar.t.Errorf("JarHandlerMock.AddWordToJar got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddWordToJar.t.Errorf("JarHandlerMock.AddWordToJar got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddWordToJar.funcAddWordToJar != nil {
		mmAddWordToJar.funcAddWordToJar(c)
		return
	}
	mmAddWordToJar.t.Fatalf("Unexpected call to JarHandlerMock.AddWordToJar. %v", c)

}

// AddWordToJarAfterCounter returns a count of finished JarHandlerMock.AddWordToJar invocations
func (mmAddWordToJar *JarHandlerMock) AddWordToJarAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordToJar.afterAddWordToJarCounter)
}

// AddWordToJarBeforeCounter returns a count of JarHandlerMock.AddWordToJar invocations
func (mmAddWordToJar *JarHandlerMock) AddWordToJarBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordToJar.beforeAddWordToJarCounter)
}

// Calls returns a list of arguments used in each call to JarHandlerMock.AddWordToJar.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddWordToJar *mJarHandlerMockAddWordToJar) Calls() []*JarHandlerMockAddWordToJarParams {
	mmAddWordToJar.mutex.RLock()

	argCopy := make([]*JarHandlerMockAddWordToJarParams, len(mmAddWordToJar.callArgs))
	copy(argCopy, mmAddWordToJar.callArgs)

	mmAddWordToJar.mutex.RUnlock()

	return argCopy
}

// MinimockAddWordToJarDone returns true if the count of the AddWordToJar invocations corresponds
// the number of defined expectations
func (m *JarHandlerMock) MinimockAddWordToJarDone() bool {
	if m.AddWordToJarMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddWordToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddWordToJarMock.invocationsDone()
}

// MinimockAddWordToJarInspect logs each unmet expectation
func (m *JarHandlerMock) MinimockAddWordToJarInspect() {
	for _, e := range m.AddWordToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JarHandlerMock.AddWordToJar at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddWordToJarCounter := mm_atomic.LoadUint64(&m.afterAddWordToJarCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddWordToJarMock.defaultExpectation != nil && afterAddWordToJarCounter < 1 {
		if m.AddWordToJarMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JarHandlerMock.AddWordToJar at\n%s", m.AddWordToJarMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JarHandlerMock.AddWordToJar at\n%s with params: %#v", m.AddWordToJarMock.defaultExpectation.expectationOrigins.origin, *m.AddWordToJarMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddWordToJar != nil && afterAddWordToJarCounter < 1 {
		m.t.Errorf("Expected call to JarHandlerMock.AddWordToJar at\n%s", m.funcAddWordToJarOrigin)
	}

	if !m.AddWordToJarMock.invocationsDone() && afterAddWordToJarCounter > 0 {
		m.t.Errorf("Expected %d calls to JarHandlerMock.AddWordToJar at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddWordToJarMock.expectedInvocations), m.AddWordToJarMock.expectedInvocationsOrigin, afterAddWordToJarCounter)
	}
}

type mJarHandlerMockGetUserWords struct {
	optional           bool
	mock               *JarHandlerMock
	defaultExpectation *JarHandlerMockGetUserWordsExpectation
	expectations       []*JarHandlerMockGetUserWordsExpectation

	callArgs []*JarHandlerMockGetUserWordsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JarHandlerMockGetUserWordsExpectation specifies expectation struct of the JarHandler.GetUserWords
type JarHandlerMockGetUserWordsExpectation struct {
	mock               *JarHandlerMock
	params             *JarHandlerMockGetUserWordsParams
	paramPtrs          *JarHandlerMockGetUserWordsParamPtrs
	expectationOrigins JarHandlerMockGetUserWordsExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// JarHandlerMockGetUserWordsParams contains parameters of the JarHandler.GetUserWords
type JarHandlerMockGetUserWordsParams struct {
	c *gin.Context
}

// JarHandlerMockGetUserWordsParamPtrs contains pointers to parameters of the JarHandler.GetUserWords
type JarHandlerMockGetUserWordsParamPtrs struct {
	c **gin.Context
}

// JarHandlerMockGetUserWordsOrigins contains origins of expectations of the JarHandler.GetUserWords
type JarHandlerMockGetUserWordsExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserWords *mJarHandlerMockGetUserWords) Optional() *mJarHandlerMockGetUserWords {
	mmGetUserWords.optional = true
	return mmGetUserWords
}

// Expect sets up expected params for JarHandler.GetUserWords
func (mmGetUserWords *mJarHandlerMockGetUserWords) Expect(c *gin.Context) *mJarHandlerMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarHandlerMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &JarHandlerMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.paramPtrs != nil {
		mmGetUserWords.mock.t.Fatalf("JarHandlerMock.GetUserWords mock is already set by ExpectParams functions")
	}

	mmGetUserWords.defaultExpectation.params = &JarHandlerMockGetUserWordsParams{c}
	mmGetUserWords.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserWords.expectations {
		if minimock.Equal(e.params, mmGetUserWords.defaultExpectation.params) {
			mmGetUserWords.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserWords.defaultExpectation.params)
		}
	}

	return mmGetUserWords
}

// ExpectCParam1 sets up expected param c for JarHandler.GetUserWords
func (mmGetUserWords *mJarHandlerMockGetUserWords) ExpectCParam1(c *gin.Context) *mJarHandlerMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarHandlerMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &JarHandlerMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("JarHandlerMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &JarHandlerMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.c = &c
	mmGetUserWords.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmGetUserWords
}

// Inspect accepts an inspector function that has same arguments as the JarHandler.GetUserWords
func (mmGetUserWords *mJarHandlerMockGetUserWords) Inspect(f func(c *gin.Context)) *mJarHandlerMockGetUserWords {
	if mmGetUserWords.mock.inspectFuncGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("Inspect function is already set for JarHandlerMock.GetUserWords")
	}

	mmGetUserWords.mock.inspectFuncGetUserWords = f

	return mmGetUserWords
}

// Return sets up results that will be returned by JarHandler.GetUserWords
func (mmGetUserWords *mJarHandlerMockGetUserWords) Return() *JarHandlerMock {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarHandlerMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &JarHandlerMockGetUserWordsExpectation{mock: mmGetUserWords.mock}
	}

	mmGetUserWords.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserWords.mock
}

// Set uses given function f to mock the JarHandler.GetUserWords method
func (mmGetUserWords *mJarHandlerMockGetUserWords) Set(f func(c *gin.Context)) *JarHandlerMock {
	if mmGetUserWords.defaultExpectation != nil {
		mmGetUserWords.mock.t.Fatalf("Default expectation is already set for the JarHandler.GetUserWords method")
	}

	if len(mmGetUserWords.expectations) > 0 {
		mmGetUserWords.mock.t.Fatalf("Some expectations are already set for the JarHandler.GetUserWords method")
	}

	mmGetUserWords.mock.funcGetUserWords = f
	mmGetUserWords.mock.funcGetUserWordsOrigin = minimock.CallerInfo(1)
	return mmGetUserWords.mock
}

// When sets expectation for the JarHandler.GetUserWords which will trigger the result defined by the following
// Then helper
func (mmGetUserWords *mJarHandlerMockGetUserWords) When(c *gin.Context) *JarHandlerMockGetUserWordsExpectation {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarHandlerMock.GetUserWords mock is already set by Set")
	}

	expectation := &JarHandlerMockGetUserWordsExpectation{
		mock:               mmGetUserWords.mock,
		params:             &JarHandlerMockGetUserWordsParams{c},
		expectationOrigins: JarHandlerMockGetUserWordsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserWords.expectations = append(mmGetUserWords.expectations, expectation)
	return expectation
}

// Then sets up JarHandler.GetUserWords return parameters for the expectation previously defined by the When method

func (e *JarHandlerMockGetUserWordsExpectation) Then() *JarHandlerMock {
	return e.mock
}

// Times sets number of times JarHandler.GetUserWords should be invoked
func (mmGetUserWords *mJarHandlerMockGetUserWords) Times(n uint64) *mJarHandlerMockGetUserWords {
	if n == 0 {
		mmGetUserWords.mock.t.Fatalf("Times of JarHandlerMock.GetUserWords mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserWords.expectedInvocations, n)
	mmGetUserWords.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserWords
}

func (mmGetUserWords *mJarHandlerMockGetUserWords) invocationsDone() bool {
	if len(mmGetUserWords.expectations) == 0 && mmGetUserWords.defaultExpectation == nil && mmGetUserWords.mock.funcGetUserWords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserWords.mock.afterGetUserWordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserWords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserWords implements mm_router.JarHandler
func (mmGetUserWords *JarHandlerMock) GetUserWords(c *gin.Context) {
	mm_atomic.AddUint64(&mmGetUserWords.beforeGetUserWordsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserWords.afterGetUserWordsCounter, 1)

	mmGetUserWords.t.Helper()

	if mmGetUserWords.inspectFuncGetUserWords != nil {
		mmGetUserWords.inspectFuncGetUserWords(c)
	}

	mm_params := JarHandlerMockGetUserWordsParams{c}

	// Record call args
	mmGetUserWords.GetUserWordsMock.mutex.Lock()
	mmGetUserWords.GetUserWordsMock.callArgs = append(mmGetUserWords.GetUserWordsMock.callArgs, &mm_params)
	mmGetUserWords.GetUserWordsMock.mutex.Unlock()

	for _, e := range mmGetUserWords.GetUserWordsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGetUserWords.GetUserWordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserWords.GetUserWordsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserWords.GetUserWordsMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserWords.GetUserWordsMock.defaultExpectation.paramPtrs

		mm_got := JarHandlerMockGetUserWordsParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmGetUserWords.t.Errorf("JarHandlerMock.GetUserWords got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserWords.t.Errorf("JarHandlerMock.GetUserWords got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGetUserWords.funcGetUserWords != nil {
		mmGetUserWords.funcGetUserWords(c)
		return
	}
	mmGetUserWords.t.Fatalf("Unexpected call to JarHandlerMock.GetUserWords. %v", c)

}

// GetUserWordsAfterCounter returns a count of finished JarHandlerMock.GetUserWords invocations
func (mmGetUserWords *JarHandlerMock) GetUserWordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWords.afterGetUserWordsCounter)
}

// GetUserWordsBeforeCounter returns a count of JarHandlerMock.GetUserWords invocations
func (mmGetUserWords *JarHandlerMock) GetUserWordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWords.beforeGetUserWordsCounter)
}

// Calls returns a list of arguments used in each call to JarHandlerMock.GetUserWords.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserWords *mJarHandlerMockGetUserWords) Calls() []*JarHandlerMockGetUserWordsParams {
	mmGetUserWords.mutex.RLock()

	argCopy := make([]*JarHandlerMockGetUserWordsParams, len(mmGetUserWords.callArgs))
	copy(argCopy, mmGetUserWords.callArgs)

	mmGetUserWords.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserWordsDone returns true if the count of the GetUserWords invocations corresponds
// the number of defined expectations
func (m *JarHandlerMock) MinimockGetUserWordsDone() bool {
	if m.GetUserWordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserWordsMock.invocationsDone()
}

// MinimockGetUserWordsInspect logs each unmet expectation
func (m *JarHandlerMock) MinimockGetUserWordsInspect() {
	for _, e := range m.GetUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JarHandlerMock.GetUserWords at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserWordsCounter := mm_atomic.LoadUint64(&m.afterGetUserWordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserWordsMock.defaultExpectation != nil && afterGetUserWordsCounter < 1 {
		if m.GetUserWordsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JarHandlerMock.GetUserWords at\n%s", m.GetUserWordsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JarHandlerMock.GetUserWords at\n%s with params: %#v", m.GetUserWordsMock.defaultExpectation.expectationOrigins.origin, *m.GetUserWordsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserWords != nil && afterGetUserWordsCounter < 1 {
		m.t.Errorf("Expected call to JarHandlerMock.GetUserWords at\n%s", m.funcGetUserWordsOrigin)
	}

	if !m.GetUserWordsMock.invocationsDone() && afterGetUserWordsCounter > 0 {
		m.t.Errorf("Expected %d calls to JarHandlerMock.GetUserWords at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserWordsMock.expectedInvocations), m.GetUserWordsMock.expectedInvocationsOrigin, afterGetUserWordsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JarHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddWordToJarInspect()

			m.MinimockGetUserWordsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JarHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JarHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddWordToJarDone() &&
		m.MinimockGetUserWordsDone()
}
