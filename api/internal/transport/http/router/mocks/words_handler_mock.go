// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/transport/http/router.WordsHandler -o words_handler_mock.go -n WordsHandlerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gin-gonic/gin"
	"github.com/gojuno/minimock/v3"
)

// WordsHandlerMock implements mm_router.WordsHandler
type WordsHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddWord          func(c *gin.Context)
	funcAddWordOrigin    string
	inspectFuncAddWord   func(c *gin.Context)
	afterAddWordCounter  uint64
	beforeAddWordCounter uint64
	AddWordMock          mWordsHandlerMockAddWord

	funcWord          func(c *gin.Context)
	funcWordOrigin    string
	inspectFuncWord   func(c *gin.Context)
	afterWordCounter  uint64
	beforeWordCounter uint64
	WordMock          mWordsHandlerMockWord

	funcWordList          func(c *gin.Context)
	funcWordListOrigin    string
	inspectFuncWordList   func(c *gin.Context)
	afterWordListCounter  uint64
	beforeWordListCounter uint64
	WordListMock          mWordsHandlerMockWordList
}

// NewWordsHandlerMock returns a mock for mm_router.WordsHandler
func NewWordsHandlerMock(t minimock.Tester) *WordsHandlerMock {
	m := &WordsHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddWordMock = mWordsHandlerMockAddWord{mock: m}
	m.AddWordMock.callArgs = []*WordsHandlerMockAddWordParams{}

	m.WordMock = mWordsHandlerMockWord{mock: m}
	m.WordMock.callArgs = []*WordsHandlerMockWordParams{}

	m.WordListMock = mWordsHandlerMockWordList{mock: m}
	m.WordListMock.callArgs = []*WordsHandlerMockWordListParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mWordsHandlerMockAddWord struct {
	optional           bool
	mock               *WordsHandlerMock
	defaultExpectation *WordsHandlerMockAddWordExpectation
	expectations       []*WordsHandlerMockAddWordExpectation

	callArgs []*WordsHandlerMockAddWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WordsHandlerMockAddWordExpectation specifies expectation struct of the WordsHandler.AddWord
type WordsHandlerMockAddWordExpectation struct {
	mock               *WordsHandlerMock
	params             *WordsHandlerMockAddWordParams
	paramPtrs          *WordsHandlerMockAddWordParamPtrs
	expectationOrigins WordsHandlerMockAddWordExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// WordsHandlerMockAddWordParams contains parameters of the WordsHandler.AddWord
type WordsHandlerMockAddWordParams struct {
	c *gin.Context
}

// WordsHandlerMockAddWordParamPtrs contains pointers to parameters of the WordsHandler.AddWord
type WordsHandlerMockAddWordParamPtrs struct {
	c **gin.Context
}

// WordsHandlerMockAddWordOrigins contains origins of expectations of the WordsHandler.AddWord
type WordsHandlerMockAddWordExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddWord *mWordsHandlerMockAddWord) Optional() *mWordsHandlerMockAddWord {
	mmAddWord.optional = true
	return mmAddWord
}

// Expect sets up expected params for WordsHandler.AddWord
func (mmAddWord *mWordsHandlerMockAddWord) Expect(c *gin.Context) *mWordsHandlerMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("WordsHandlerMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &WordsHandlerMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.paramPtrs != nil {
		mmAddWord.mock.t.Fatalf("WordsHandlerMock.AddWord mock is already set by ExpectParams functions")
	}

	mmAddWord.defaultExpectation.params = &WordsHandlerMockAddWordParams{c}
	mmAddWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddWord.expectations {
		if minimock.Equal(e.params, mmAddWord.defaultExpectation.params) {
			mmAddWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddWord.defaultExpectation.params)
		}
	}

	return mmAddWord
}

// ExpectCParam1 sets up expected param c for WordsHandler.AddWord
func (mmAddWord *mWordsHandlerMockAddWord) ExpectCParam1(c *gin.Context) *mWordsHandlerMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("WordsHandlerMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &WordsHandlerMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.params != nil {
		mmAddWord.mock.t.Fatalf("WordsHandlerMock.AddWord mock is already set by Expect")
	}

	if mmAddWord.defaultExpectation.paramPtrs == nil {
		mmAddWord.defaultExpectation.paramPtrs = &WordsHandlerMockAddWordParamPtrs{}
	}
	mmAddWord.defaultExpectation.paramPtrs.c = &c
	mmAddWord.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmAddWord
}

// Inspect accepts an inspector function that has same arguments as the WordsHandler.AddWord
func (mmAddWord *mWordsHandlerMockAddWord) Inspect(f func(c *gin.Context)) *mWordsHandlerMockAddWord {
	if mmAddWord.mock.inspectFuncAddWord != nil {
		mmAddWord.mock.t.Fatalf("Inspect function is already set for WordsHandlerMock.AddWord")
	}

	mmAddWord.mock.inspectFuncAddWord = f

	return mmAddWord
}

// Return sets up results that will be returned by WordsHandler.AddWord
func (mmAddWord *mWordsHandlerMockAddWord) Return() *WordsHandlerMock {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("WordsHandlerMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &WordsHandlerMockAddWordExpectation{mock: mmAddWord.mock}
	}

	mmAddWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddWord.mock
}

// Set uses given function f to mock the WordsHandler.AddWord method
func (mmAddWord *mWordsHandlerMockAddWord) Set(f func(c *gin.Context)) *WordsHandlerMock {
	if mmAddWord.defaultExpectation != nil {
		mmAddWord.mock.t.Fatalf("Default expectation is already set for the WordsHandler.AddWord method")
	}

	if len(mmAddWord.expectations) > 0 {
		mmAddWord.mock.t.Fatalf("Some expectations are already set for the WordsHandler.AddWord method")
	}

	mmAddWord.mock.funcAddWord = f
	mmAddWord.mock.funcAddWordOrigin = minimock.CallerInfo(1)
	return mmAddWord.mock
}

// When sets expectation for the WordsHandler.AddWord which will trigger the result defined by the following
// Then helper
func (mmAddWord *mWordsHandlerMockAddWord) When(c *gin.Context) *WordsHandlerMockAddWordExpectation {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("WordsHandlerMock.AddWord mock is already set by Set")
	}

	expectation := &WordsHandlerMockAddWordExpectation{
		mock:               mmAddWord.mock,
		params:             &WordsHandlerMockAddWordParams{c},
		expectationOrigins: WordsHandlerMockAddWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddWord.expectations = append(mmAddWord.expectations, expectation)
	return expectation
}

// Then sets up WordsHandler.AddWord return parameters for the expectation previously defined by the When method

func (e *WordsHandlerMockAddWordExpectation) Then() *WordsHandlerMock {
	return e.mock
}

// Times sets number of times WordsHandler.AddWord should be invoked
func (mmAddWord *mWordsHandlerMockAddWord) Times(n uint64) *mWordsHandlerMockAddWord {
	if n == 0 {
		mmAddWord.mock.t.Fatalf("Times of WordsHandlerMock.AddWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddWord.expectedInvocations, n)
	mmAddWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddWord
}

func (mmAddWord *mWordsHandlerMockAddWord) invocationsDone() bool {
	if len(mmAddWord.expectations) == 0 && mmAddWord.defaultExpectation == nil && mmAddWord.mock.funcAddWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddWord.mock.afterAddWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddWord implements mm_router.WordsHandler
func (mmAddWord *WordsHandlerMock) AddWord(c *gin.Context) {
	mm_atomic.AddUint64(&mmAddWord.beforeAddWordCounter, 1)
	defer mm_atomic.AddUint64(&mmAddWord.afterAddWordCounter, 1)

	mmAddWord.t.Helper()

	if mmAddWord.inspectFuncAddWord != nil {
		mmAddWord.inspectFuncAddWord(c)
	}

	mm_params := WordsHandlerMockAddWordParams{c}

	// Record call args
	mmAddWord.AddWordMock.mutex.Lock()
	mmAddWord.AddWordMock.callArgs = append(mmAddWord.AddWordMock.callArgs, &mm_params)
	mmAddWord.AddWordMock.mutex.Unlock()

	for _, e := range mmAddWord.AddWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddWord.AddWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddWord.AddWordMock.defaultExpectation.Counter, 1)
		mm_want := mmAddWord.AddWordMock.defaultExpectation.params
		mm_want_ptrs := mmAddWord.AddWordMock.defaultExpectation.paramPtrs

		mm_got := WordsHandlerMockAddWordParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmAddWord.t.Errorf("WordsHandlerMock.AddWord got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddWord.t.Errorf("WordsHandlerMock.AddWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddWord.funcAddWord != nil {
		mmAddWord.funcAddWord(c)
		return
	}
	mmAddWord.t.Fatalf("Unexpected call to WordsHandlerMock.AddWord. %v", c)

}

// AddWordAfterCounter returns a count of finished WordsHandlerMock.AddWord invocations
func (mmAddWord *WordsHandlerMock) AddWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWord.afterAddWordCounter)
}

// AddWordBeforeCounter returns a count of WordsHandlerMock.AddWord invocations
func (mmAddWord *WordsHandlerMock) AddWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWord.beforeAddWordCounter)
}

// Calls returns a list of arguments used in each call to WordsHandlerMock.AddWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddWord *mWordsHandlerMockAddWord) Calls() []*WordsHandlerMockAddWordParams {
	mmAddWord.mutex.RLock()

	argCopy := make([]*WordsHandlerMockAddWordParams, len(mmAddWord.callArgs))
	copy(argCopy, mmAddWord.callArgs)

	mmAddWord.mutex.RUnlock()

	return argCopy
}

// MinimockAddWordDone returns true if the count of the AddWord invocations corresponds
// the number of defined expectations
func (m *WordsHandlerMock) MinimockAddWordDone() bool {
	if m.AddWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddWordMock.invocationsDone()
}

// MinimockAddWordInspect logs each unmet expectation
func (m *WordsHandlerMock) MinimockAddWordInspect() {
	for _, e := range m.AddWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WordsHandlerMock.AddWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddWordCounter := mm_atomic.LoadUint64(&m.afterAddWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddWordMock.defaultExpectation != nil && afterAddWordCounter < 1 {
		if m.AddWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to WordsHandlerMock.AddWord at\n%s", m.AddWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to WordsHandlerMock.AddWord at\n%s with params: %#v", m.AddWordMock.defaultExpectation.expectationOrigins.origin, *m.AddWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddWord != nil && afterAddWordCounter < 1 {
		m.t.Errorf("Expected call to WordsHandlerMock.AddWord at\n%s", m.funcAddWordOrigin)
	}

	if !m.AddWordMock.invocationsDone() && afterAddWordCounter > 0 {
		m.t.Errorf("Expected %d calls to WordsHandlerMock.AddWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddWordMock.expectedInvocations), m.AddWordMock.expectedInvocationsOrigin, afterAddWordCounter)
	}
}

type mWordsHandlerMockWord struct {
	optional           bool
	mock               *WordsHandlerMock
	defaultExpectation *WordsHandlerMockWordExpectation
	expectations       []*WordsHandlerMockWordExpectation

	callArgs []*WordsHandlerMockWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WordsHandlerMockWordExpectation specifies expectation struct of the WordsHandler.Word
type WordsHandlerMockWordExpectation struct {
	mock               *WordsHandlerMock
	params             *WordsHandlerMockWordParams
	paramPtrs          *WordsHandlerMockWordParamPtrs
	expectationOrigins WordsHandlerMockWordExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// WordsHandlerMockWordParams contains parameters of the WordsHandler.Word
type WordsHandlerMockWordParams struct {
	c *gin.Context
}

// WordsHandlerMockWordParamPtrs contains pointers to parameters of the WordsHandler.Word
type WordsHandlerMockWordParamPtrs struct {
	c **gin.Context
}

// WordsHandlerMockWordOrigins contains origins of expectations of the WordsHandler.Word
type WordsHandlerMockWordExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWord *mWordsHandlerMockWord) Optional() *mWordsHandlerMockWord {
	mmWord.optional = true
	return mmWord
}

// Expect sets up expected params for WordsHandler.Word
func (mmWord *mWordsHandlerMockWord) Expect(c *gin.Context) *mWordsHandlerMockWord {
	if mmWord.mock.funcWord != nil {
		mmWord.mock.t.Fatalf("WordsHandlerMock.Word mock is already set by Set")
	}

	if mmWord.defaultExpectation == nil {
		mmWord.defaultExpectation = &WordsHandlerMockWordExpectation{}
	}

	if mmWord.defaultExpectation.paramPtrs != nil {
		mmWord.mock.t.Fatalf("WordsHandlerMock.Word mock is already set by ExpectParams functions")
	}

	mmWord.defaultExpectation.params = &WordsHandlerMockWordParams{c}
	mmWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWord.expectations {
		if minimock.Equal(e.params, mmWord.defaultExpectation.params) {
			mmWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWord.defaultExpectation.params)
		}
	}

	return mmWord
}

// ExpectCParam1 sets up expected param c for WordsHandler.Word
func (mmWord *mWordsHandlerMockWord) ExpectCParam1(c *gin.Context) *mWordsHandlerMockWord {
	if mmWord.mock.funcWord != nil {
		mmWord.mock.t.Fatalf("WordsHandlerMock.Word mock is already set by Set")
	}

	if mmWord.defaultExpectation == nil {
		mmWord.defaultExpectation = &WordsHandlerMockWordExpectation{}
	}

	if mmWord.defaultExpectation.params != nil {
		mmWord.mock.t.Fatalf("WordsHandlerMock.Word mock is already set by Expect")
	}

	if mmWord.defaultExpectation.paramPtrs == nil {
		mmWord.defaultExpectation.paramPtrs = &WordsHandlerMockWordParamPtrs{}
	}
	mmWord.defaultExpectation.paramPtrs.c = &c
	mmWord.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmWord
}

// Inspect accepts an inspector function that has same arguments as the WordsHandler.Word
func (mmWord *mWordsHandlerMockWord) Inspect(f func(c *gin.Context)) *mWordsHandlerMockWord {
	if mmWord.mock.inspectFuncWord != nil {
		mmWord.mock.t.Fatalf("Inspect function is already set for WordsHandlerMock.Word")
	}

	mmWord.mock.inspectFuncWord = f

	return mmWord
}

// Return sets up results that will be returned by WordsHandler.Word
func (mmWord *mWordsHandlerMockWord) Return() *WordsHandlerMock {
	if mmWord.mock.funcWord != nil {
		mmWord.mock.t.Fatalf("WordsHandlerMock.Word mock is already set by Set")
	}

	if mmWord.defaultExpectation == nil {
		mmWord.defaultExpectation = &WordsHandlerMockWordExpectation{mock: mmWord.mock}
	}

	mmWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWord.mock
}

// Set uses given function f to mock the WordsHandler.Word method
func (mmWord *mWordsHandlerMockWord) Set(f func(c *gin.Context)) *WordsHandlerMock {
	if mmWord.defaultExpectation != nil {
		mmWord.mock.t.Fatalf("Default expectation is already set for the WordsHandler.Word method")
	}

	if len(mmWord.expectations) > 0 {
		mmWord.mock.t.Fatalf("Some expectations are already set for the WordsHandler.Word method")
	}

	mmWord.mock.funcWord = f
	mmWord.mock.funcWordOrigin = minimock.CallerInfo(1)
	return mmWord.mock
}

// When sets expectation for the WordsHandler.Word which will trigger the result defined by the following
// Then helper
func (mmWord *mWordsHandlerMockWord) When(c *gin.Context) *WordsHandlerMockWordExpectation {
	if mmWord.mock.funcWord != nil {
		mmWord.mock.t.Fatalf("WordsHandlerMock.Word mock is already set by Set")
	}

	expectation := &WordsHandlerMockWordExpectation{
		mock:               mmWord.mock,
		params:             &WordsHandlerMockWordParams{c},
		expectationOrigins: WordsHandlerMockWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWord.expectations = append(mmWord.expectations, expectation)
	return expectation
}

// Then sets up WordsHandler.Word return parameters for the expectation previously defined by the When method

func (e *WordsHandlerMockWordExpectation) Then() *WordsHandlerMock {
	return e.mock
}

// Times sets number of times WordsHandler.Word should be invoked
func (mmWord *mWordsHandlerMockWord) Times(n uint64) *mWordsHandlerMockWord {
	if n == 0 {
		mmWord.mock.t.Fatalf("Times of WordsHandlerMock.Word mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWord.expectedInvocations, n)
	mmWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWord
}

func (mmWord *mWordsHandlerMockWord) invocationsDone() bool {
	if len(mmWord.expectations) == 0 && mmWord.defaultExpectation == nil && mmWord.mock.funcWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWord.mock.afterWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Word implements mm_router.WordsHandler
func (mmWord *WordsHandlerMock) Word(c *gin.Context) {
	mm_atomic.AddUint64(&mmWord.beforeWordCounter, 1)
	defer mm_atomic.AddUint64(&mmWord.afterWordCounter, 1)

	mmWord.t.Helper()

	if mmWord.inspectFuncWord != nil {
		mmWord.inspectFuncWord(c)
	}

	mm_params := WordsHandlerMockWordParams{c}

	// Record call args
	mmWord.WordMock.mutex.Lock()
	mmWord.WordMock.callArgs = append(mmWord.WordMock.callArgs, &mm_params)
	mmWord.WordMock.mutex.Unlock()

	for _, e := range mmWord.WordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWord.WordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWord.WordMock.defaultExpectation.Counter, 1)
		mm_want := mmWord.WordMock.defaultExpectation.params
		mm_want_ptrs := mmWord.WordMock.defaultExpectation.paramPtrs

		mm_got := WordsHandlerMockWordParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmWord.t.Errorf("WordsHandlerMock.Word got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWord.WordMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWord.t.Errorf("WordsHandlerMock.Word got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWord.WordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWord.funcWord != nil {
		mmWord.funcWord(c)
		return
	}
	mmWord.t.Fatalf("Unexpected call to WordsHandlerMock.Word. %v", c)

}

// WordAfterCounter returns a count of finished WordsHandlerMock.Word invocations
func (mmWord *WordsHandlerMock) WordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWord.afterWordCounter)
}

// WordBeforeCounter returns a count of WordsHandlerMock.Word invocations
func (mmWord *WordsHandlerMock) WordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWord.beforeWordCounter)
}

// Calls returns a list of arguments used in each call to WordsHandlerMock.Word.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWord *mWordsHandlerMockWord) Calls() []*WordsHandlerMockWordParams {
	mmWord.mutex.RLock()

	argCopy := make([]*WordsHandlerMockWordParams, len(mmWord.callArgs))
	copy(argCopy, mmWord.callArgs)

	mmWord.mutex.RUnlock()

	return argCopy
}

// MinimockWordDone returns true if the count of the Word invocations corresponds
// the number of defined expectations
func (m *WordsHandlerMock) MinimockWordDone() bool {
	if m.WordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WordMock.invocationsDone()
}

// MinimockWordInspect logs each unmet expectation
func (m *WordsHandlerMock) MinimockWordInspect() {
	for _, e := range m.WordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WordsHandlerMock.Word at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWordCounter := mm_atomic.LoadUint64(&m.afterWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WordMock.defaultExpectation != nil && afterWordCounter < 1 {
		if m.WordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to WordsHandlerMock.Word at\n%s", m.WordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to WordsHandlerMock.Word at\n%s with params: %#v", m.WordMock.defaultExpectation.expectationOrigins.origin, *m.WordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWord != nil && afterWordCounter < 1 {
		m.t.Errorf("Expected call to WordsHandlerMock.Word at\n%s", m.funcWordOrigin)
	}

	if !m.WordMock.invocationsDone() && afterWordCounter > 0 {
		m.t.Errorf("Expected %d calls to WordsHandlerMock.Word at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WordMock.expectedInvocations), m.WordMock.expectedInvocationsOrigin, afterWordCounter)
	}
}

type mWordsHandlerMockWordList struct {
	optional           bool
	mock               *WordsHandlerMock
	defaultExpectation *WordsHandlerMockWordListExpectation
	expectations       []*WordsHandlerMockWordListExpectation

	callArgs []*WordsHandlerMockWordListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WordsHandlerMockWordListExpectation specifies expectation struct of the WordsHandler.WordList
type WordsHandlerMockWordListExpectation struct {
	mock               *WordsHandlerMock
	params             *WordsHandlerMockWordListParams
	paramPtrs          *WordsHandlerMockWordListParamPtrs
	expectationOrigins WordsHandlerMockWordListExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// WordsHandlerMockWordListParams contains parameters of the WordsHandler.WordList
type WordsHandlerMockWordListParams struct {
	c *gin.Context
}

// WordsHandlerMockWordListParamPtrs contains pointers to parameters of the WordsHandler.WordList
type WordsHandlerMockWordListParamPtrs struct {
	c **gin.Context
}

// WordsHandlerMockWordListOrigins contains origins of expectations of the WordsHandler.WordList
type WordsHandlerMockWordListExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWordList *mWordsHandlerMockWordList) Optional() *mWordsHandlerMockWordList {
	mmWordList.optional = true
	return mmWordList
}

// Expect sets up expected params for WordsHandler.WordList
func (mmWordList *mWordsHandlerMockWordList) Expect(c *gin.Context) *mWordsHandlerMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("WordsHandlerMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &WordsHandlerMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.paramPtrs != nil {
		mmWordList.mock.t.Fatalf("WordsHandlerMock.WordList mock is already set by ExpectParams functions")
	}

	mmWordList.defaultExpectation.params = &WordsHandlerMockWordListParams{c}
	mmWordList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWordList.expectations {
		if minimock.Equal(e.params, mmWordList.defaultExpectation.params) {
			mmWordList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWordList.defaultExpectation.params)
		}
	}

	return mmWordList
}

// ExpectCParam1 sets up expected param c for WordsHandler.WordList
func (mmWordList *mWordsHandlerMockWordList) ExpectCParam1(c *gin.Context) *mWordsHandlerMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("WordsHandlerMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &WordsHandlerMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.params != nil {
		mmWordList.mock.t.Fatalf("WordsHandlerMock.WordList mock is already set by Expect")
	}

	if mmWordList.defaultExpectation.paramPtrs == nil {
		mmWordList.defaultExpectation.paramPtrs = &WordsHandlerMockWordListParamPtrs{}
	}
	mmWordList.defaultExpectation.paramPtrs.c = &c
	mmWordList.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmWordList
}

// Inspect accepts an inspector function that has same arguments as the WordsHandler.WordList
func (mmWordList *mWordsHandlerMockWordList) Inspect(f func(c *gin.Context)) *mWordsHandlerMockWordList {
	if mmWordList.mock.inspectFuncWordList != nil {
		mmWordList.mock.t.Fatalf("Inspect function is already set for WordsHandlerMock.WordList")
	}

	mmWordList.mock.inspectFuncWordList = f

	return mmWordList
}

// Return sets up results that will be returned by WordsHandler.WordList
func (mmWordList *mWordsHandlerMockWordList) Return() *WordsHandlerMock {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("WordsHandlerMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &WordsHandlerMockWordListExpectation{mock: mmWordList.mock}
	}

	mmWordList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWordList.mock
}

// Set uses given function f to mock the WordsHandler.WordList method
func (mmWordList *mWordsHandlerMockWordList) Set(f func(c *gin.Context)) *WordsHandlerMock {
	if mmWordList.defaultExpectation != nil {
		mmWordList.mock.t.Fatalf("Default expectation is already set for the WordsHandler.WordList method")
	}

	if len(mmWordList.expectations) > 0 {
		mmWordList.mock.t.Fatalf("Some expectations are already set for the WordsHandler.WordList method")
	}

	mmWordList.mock.funcWordList = f
	mmWordList.mock.funcWordListOrigin = minimock.CallerInfo(1)
	return mmWordList.mock
}

// When sets expectation for the WordsHandler.WordList which will trigger the result defined by the following
// Then helper
func (mmWordList *mWordsHandlerMockWordList) When(c *gin.Context) *WordsHandlerMockWordListExpectation {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("WordsHandlerMock.WordList mock is already set by Set")
	}

	expectation := &WordsHandlerMockWordListExpectation{
		mock:               mmWordList.mock,
		params:             &WordsHandlerMockWordListParams{c},
		expectationOrigins: WordsHandlerMockWordListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWordList.expectations = append(mmWordList.expectations, expectation)
	return expectation
}

// Then sets up WordsHandler.WordList return parameters for the expectation previously defined by the When method

func (e *WordsHandlerMockWordListExpectation) Then() *WordsHandlerMock {
	return e.mock
}

// Times sets number of times WordsHandler.WordList should be invoked
func (mmWordList *mWordsHandlerMockWordList) Times(n uint64) *mWordsHandlerMockWordList {
	if n == 0 {
		mmWordList.mock.t.Fatalf("Times of WordsHandlerMock.WordList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWordList.expectedInvocations, n)
	mmWordList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWordList
}

func (mmWordList *mWordsHandlerMockWordList) invocationsDone() bool {
	if len(mmWordList.expectations) == 0 && mmWordList.defaultExpectation == nil && mmWordList.mock.funcWordList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWordList.mock.afterWordListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWordList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WordList implements mm_router.WordsHandler
func (mmWordList *WordsHandlerMock) WordList(c *gin.Context) {
	mm_atomic.AddUint64(&mmWordList.beforeWordListCounter, 1)
	defer mm_atomic.AddUint64(&mmWordList.afterWordListCounter, 1)

	mmWordList.t.Helper()

	if mmWordList.inspectFuncWordList != nil {
		mmWordList.inspectFuncWordList(c)
	}

	mm_params := WordsHandlerMockWordListParams{c}

	// Record call args
	mmWordList.WordListMock.mutex.Lock()
	mmWordList.WordListMock.callArgs = append(mmWordList.WordListMock.callArgs, &mm_params)
	mmWordList.WordListMock.mutex.Unlock()

	for _, e := range mmWordList.WordListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWordList.WordListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWordList.WordListMock.defaultExpectation.Counter, 1)
		mm_want := mmWordList.WordListMock.defaultExpectation.params
		mm_want_ptrs := mmWordList.WordListMock.defaultExpectation.paramPtrs

		mm_got := WordsHandlerMockWordListParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmWordList.t.Errorf("WordsHandlerMock.WordList got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWordList.WordListMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWordList.t.Errorf("WordsHandlerMock.WordList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWordList.WordListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWordList.funcWordList != nil {
		mmWordList.funcWordList(c)
		return
	}
	mmWordList.t.Fatalf("Unexpected call to WordsHandlerMock.WordList. %v", c)

}

// WordListAfterCounter returns a count of finished WordsHandlerMock.WordList invocations
func (mmWordList *WordsHandlerMock) WordListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWordList.afterWordListCounter)
}

// WordListBeforeCounter returns a count of WordsHandlerMock.WordList invocations
func (mmWordList *WordsHandlerMock) WordListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWordList.beforeWordListCounter)
}

// Calls returns a list of arguments used in each call to WordsHandlerMock.WordList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWordList *mWordsHandlerMockWordList) Calls() []*WordsHandlerMockWordListParams {
	mmWordList.mutex.RLock()

	argCopy := make([]*WordsHandlerMockWordListParams, len(mmWordList.callArgs))
	copy(argCopy, mmWordList.callArgs)

	mmWordList.mutex.RUnlock()

	return argCopy
}

// MinimockWordListDone returns true if the count of the WordList invocations corresponds
// the number of defined expectations
func (m *WordsHandlerMock) MinimockWordListDone() bool {
	if m.WordListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WordListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WordListMock.invocationsDone()
}

// MinimockWordListInspect logs each unmet expectation
func (m *WordsHandlerMock) MinimockWordListInspect() {
	for _, e := range m.WordListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WordsHandlerMock.WordList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWordListCounter := mm_atomic.LoadUint64(&m.afterWordListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WordListMock.defaultExpectation != nil && afterWordListCounter < 1 {
		if m.WordListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to WordsHandlerMock.WordList at\n%s", m.WordListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to WordsHandlerMock.WordList at\n%s with params: %#v", m.WordListMock.defaultExpectation.expectationOrigins.origin, *m.WordListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWordList != nil && afterWordListCounter < 1 {
		m.t.Errorf("Expected call to WordsHandlerMock.WordList at\n%s", m.funcWordListOrigin)
	}

	if !m.WordListMock.invocationsDone() && afterWordListCounter > 0 {
		m.t.Errorf("Expected %d calls to WordsHandlerMock.WordList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WordListMock.expectedInvocations), m.WordListMock.expectedInvocationsOrigin, afterWordListCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *WordsHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddWordInspect()

			m.MinimockWordInspect()

			m.MinimockWordListInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *WordsHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *WordsHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddWordDone() &&
		m.MinimockWordDone() &&
		m.MinimockWordListDone()
}
