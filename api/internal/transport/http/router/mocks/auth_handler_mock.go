// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/transport/http/router.AuthHandler -o auth_handler_mock.go -n AuthHandlerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gin-gonic/gin"
	"github.com/gojuno/minimock/v3"
)

// AuthHandlerMock implements mm_router.AuthHandler
type AuthHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAuthenticate          func(c *gin.Context)
	funcAuthenticateOrigin    string
	inspectFuncAuthenticate   func(c *gin.Context)
	afterAuthenticateCounter  uint64
	beforeAuthenticateCounter uint64
	AuthenticateMock          mAuthHandlerMockAuthenticate

	funcCreateUser          func(c *gin.Context)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(c *gin.Context)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mAuthHandlerMockCreateUser

	funcUserInfo          func(c *gin.Context)
	funcUserInfoOrigin    string
	inspectFuncUserInfo   func(c *gin.Context)
	afterUserInfoCounter  uint64
	beforeUserInfoCounter uint64
	UserInfoMock          mAuthHandlerMockUserInfo
}

// NewAuthHandlerMock returns a mock for mm_router.AuthHandler
func NewAuthHandlerMock(t minimock.Tester) *AuthHandlerMock {
	m := &AuthHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AuthenticateMock = mAuthHandlerMockAuthenticate{mock: m}
	m.AuthenticateMock.callArgs = []*AuthHandlerMockAuthenticateParams{}

	m.CreateUserMock = mAuthHandlerMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*AuthHandlerMockCreateUserParams{}

	m.UserInfoMock = mAuthHandlerMockUserInfo{mock: m}
	m.UserInfoMock.callArgs = []*AuthHandlerMockUserInfoParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthHandlerMockAuthenticate struct {
	optional           bool
	mock               *AuthHandlerMock
	defaultExpectation *AuthHandlerMockAuthenticateExpectation
	expectations       []*AuthHandlerMockAuthenticateExpectation

	callArgs []*AuthHandlerMockAuthenticateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthHandlerMockAuthenticateExpectation specifies expectation struct of the AuthHandler.Authenticate
type AuthHandlerMockAuthenticateExpectation struct {
	mock               *AuthHandlerMock
	params             *AuthHandlerMockAuthenticateParams
	paramPtrs          *AuthHandlerMockAuthenticateParamPtrs
	expectationOrigins AuthHandlerMockAuthenticateExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// AuthHandlerMockAuthenticateParams contains parameters of the AuthHandler.Authenticate
type AuthHandlerMockAuthenticateParams struct {
	c *gin.Context
}

// AuthHandlerMockAuthenticateParamPtrs contains pointers to parameters of the AuthHandler.Authenticate
type AuthHandlerMockAuthenticateParamPtrs struct {
	c **gin.Context
}

// AuthHandlerMockAuthenticateOrigins contains origins of expectations of the AuthHandler.Authenticate
type AuthHandlerMockAuthenticateExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAuthenticate *mAuthHandlerMockAuthenticate) Optional() *mAuthHandlerMockAuthenticate {
	mmAuthenticate.optional = true
	return mmAuthenticate
}

// Expect sets up expected params for AuthHandler.Authenticate
func (mmAuthenticate *mAuthHandlerMockAuthenticate) Expect(c *gin.Context) *mAuthHandlerMockAuthenticate {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("AuthHandlerMock.Authenticate mock is already set by Set")
	}

	if mmAuthenticate.defaultExpectation == nil {
		mmAuthenticate.defaultExpectation = &AuthHandlerMockAuthenticateExpectation{}
	}

	if mmAuthenticate.defaultExpectation.paramPtrs != nil {
		mmAuthenticate.mock.t.Fatalf("AuthHandlerMock.Authenticate mock is already set by ExpectParams functions")
	}

	mmAuthenticate.defaultExpectation.params = &AuthHandlerMockAuthenticateParams{c}
	mmAuthenticate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAuthenticate.expectations {
		if minimock.Equal(e.params, mmAuthenticate.defaultExpectation.params) {
			mmAuthenticate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAuthenticate.defaultExpectation.params)
		}
	}

	return mmAuthenticate
}

// ExpectCParam1 sets up expected param c for AuthHandler.Authenticate
func (mmAuthenticate *mAuthHandlerMockAuthenticate) ExpectCParam1(c *gin.Context) *mAuthHandlerMockAuthenticate {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("AuthHandlerMock.Authenticate mock is already set by Set")
	}

	if mmAuthenticate.defaultExpectation == nil {
		mmAuthenticate.defaultExpectation = &AuthHandlerMockAuthenticateExpectation{}
	}

	if mmAuthenticate.defaultExpectation.params != nil {
		mmAuthenticate.mock.t.Fatalf("AuthHandlerMock.Authenticate mock is already set by Expect")
	}

	if mmAuthenticate.defaultExpectation.paramPtrs == nil {
		mmAuthenticate.defaultExpectation.paramPtrs = &AuthHandlerMockAuthenticateParamPtrs{}
	}
	mmAuthenticate.defaultExpectation.paramPtrs.c = &c
	mmAuthenticate.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmAuthenticate
}

// Inspect accepts an inspector function that has same arguments as the AuthHandler.Authenticate
func (mmAuthenticate *mAuthHandlerMockAuthenticate) Inspect(f func(c *gin.Context)) *mAuthHandlerMockAuthenticate {
	if mmAuthenticate.mock.inspectFuncAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("Inspect function is already set for AuthHandlerMock.Authenticate")
	}

	mmAuthenticate.mock.inspectFuncAuthenticate = f

	return mmAuthenticate
}

// Return sets up results that will be returned by AuthHandler.Authenticate
func (mmAuthenticate *mAuthHandlerMockAuthenticate) Return() *AuthHandlerMock {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("AuthHandlerMock.Authenticate mock is already set by Set")
	}

	if mmAuthenticate.defaultExpectation == nil {
		mmAuthenticate.defaultExpectation = &AuthHandlerMockAuthenticateExpectation{mock: mmAuthenticate.mock}
	}

	mmAuthenticate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAuthenticate.mock
}

// Set uses given function f to mock the AuthHandler.Authenticate method
func (mmAuthenticate *mAuthHandlerMockAuthenticate) Set(f func(c *gin.Context)) *AuthHandlerMock {
	if mmAuthenticate.defaultExpectation != nil {
		mmAuthenticate.mock.t.Fatalf("Default expectation is already set for the AuthHandler.Authenticate method")
	}

	if len(mmAuthenticate.expectations) > 0 {
		mmAuthenticate.mock.t.Fatalf("Some expectations are already set for the AuthHandler.Authenticate method")
	}

	mmAuthenticate.mock.funcAuthenticate = f
	mmAuthenticate.mock.funcAuthenticateOrigin = minimock.CallerInfo(1)
	return mmAuthenticate.mock
}

// When sets expectation for the AuthHandler.Authenticate which will trigger the result defined by the following
// Then helper
func (mmAuthenticate *mAuthHandlerMockAuthenticate) When(c *gin.Context) *AuthHandlerMockAuthenticateExpectation {
	if mmAuthenticate.mock.funcAuthenticate != nil {
		mmAuthenticate.mock.t.Fatalf("AuthHandlerMock.Authenticate mock is already set by Set")
	}

	expectation := &AuthHandlerMockAuthenticateExpectation{
		mock:               mmAuthenticate.mock,
		params:             &AuthHandlerMockAuthenticateParams{c},
		expectationOrigins: AuthHandlerMockAuthenticateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAuthenticate.expectations = append(mmAuthenticate.expectations, expectation)
	return expectation
}

// Then sets up AuthHandler.Authenticate return parameters for the expectation previously defined by the When method

func (e *AuthHandlerMockAuthenticateExpectation) Then() *AuthHandlerMock {
	return e.mock
}

// Times sets number of times AuthHandler.Authenticate should be invoked
func (mmAuthenticate *mAuthHandlerMockAuthenticate) Times(n uint64) *mAuthHandlerMockAuthenticate {
	if n == 0 {
		mmAuthenticate.mock.t.Fatalf("Times of AuthHandlerMock.Authenticate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAuthenticate.expectedInvocations, n)
	mmAuthenticate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAuthenticate
}

func (mmAuthenticate *mAuthHandlerMockAuthenticate) invocationsDone() bool {
	if len(mmAuthenticate.expectations) == 0 && mmAuthenticate.defaultExpectation == nil && mmAuthenticate.mock.funcAuthenticate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAuthenticate.mock.afterAuthenticateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAuthenticate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Authenticate implements mm_router.AuthHandler
func (mmAuthenticate *AuthHandlerMock) Authenticate(c *gin.Context) {
	mm_atomic.AddUint64(&mmAuthenticate.beforeAuthenticateCounter, 1)
	defer mm_atomic.AddUint64(&mmAuthenticate.afterAuthenticateCounter, 1)

	mmAuthenticate.t.Helper()

	if mmAuthenticate.inspectFuncAuthenticate != nil {
		mmAuthenticate.inspectFuncAuthenticate(c)
	}

	mm_params := AuthHandlerMockAuthenticateParams{c}

	// Record call args
	mmAuthenticate.AuthenticateMock.mutex.Lock()
	mmAuthenticate.AuthenticateMock.callArgs = append(mmAuthenticate.AuthenticateMock.callArgs, &mm_params)
	mmAuthenticate.AuthenticateMock.mutex.Unlock()

	for _, e := range mmAuthenticate.AuthenticateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAuthenticate.AuthenticateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAuthenticate.AuthenticateMock.defaultExpectation.Counter, 1)
		mm_want := mmAuthenticate.AuthenticateMock.defaultExpectation.params
		mm_want_ptrs := mmAuthenticate.AuthenticateMock.defaultExpectation.paramPtrs

		mm_got := AuthHandlerMockAuthenticateParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmAuthenticate.t.Errorf("AuthHandlerMock.Authenticate got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAuthenticate.AuthenticateMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAuthenticate.t.Errorf("AuthHandlerMock.Authenticate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAuthenticate.AuthenticateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAuthenticate.funcAuthenticate != nil {
		mmAuthenticate.funcAuthenticate(c)
		return
	}
	mmAuthenticate.t.Fatalf("Unexpected call to AuthHandlerMock.Authenticate. %v", c)

}

// AuthenticateAfterCounter returns a count of finished AuthHandlerMock.Authenticate invocations
func (mmAuthenticate *AuthHandlerMock) AuthenticateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthenticate.afterAuthenticateCounter)
}

// AuthenticateBeforeCounter returns a count of AuthHandlerMock.Authenticate invocations
func (mmAuthenticate *AuthHandlerMock) AuthenticateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthenticate.beforeAuthenticateCounter)
}

// Calls returns a list of arguments used in each call to AuthHandlerMock.Authenticate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAuthenticate *mAuthHandlerMockAuthenticate) Calls() []*AuthHandlerMockAuthenticateParams {
	mmAuthenticate.mutex.RLock()

	argCopy := make([]*AuthHandlerMockAuthenticateParams, len(mmAuthenticate.callArgs))
	copy(argCopy, mmAuthenticate.callArgs)

	mmAuthenticate.mutex.RUnlock()

	return argCopy
}

// MinimockAuthenticateDone returns true if the count of the Authenticate invocations corresponds
// the number of defined expectations
func (m *AuthHandlerMock) MinimockAuthenticateDone() bool {
	if m.AuthenticateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AuthenticateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AuthenticateMock.invocationsDone()
}

// MinimockAuthenticateInspect logs each unmet expectation
func (m *AuthHandlerMock) MinimockAuthenticateInspect() {
	for _, e := range m.AuthenticateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthHandlerMock.Authenticate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAuthenticateCounter := mm_atomic.LoadUint64(&m.afterAuthenticateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AuthenticateMock.defaultExpectation != nil && afterAuthenticateCounter < 1 {
		if m.AuthenticateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthHandlerMock.Authenticate at\n%s", m.AuthenticateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthHandlerMock.Authenticate at\n%s with params: %#v", m.AuthenticateMock.defaultExpectation.expectationOrigins.origin, *m.AuthenticateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuthenticate != nil && afterAuthenticateCounter < 1 {
		m.t.Errorf("Expected call to AuthHandlerMock.Authenticate at\n%s", m.funcAuthenticateOrigin)
	}

	if !m.AuthenticateMock.invocationsDone() && afterAuthenticateCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthHandlerMock.Authenticate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AuthenticateMock.expectedInvocations), m.AuthenticateMock.expectedInvocationsOrigin, afterAuthenticateCounter)
	}
}

type mAuthHandlerMockCreateUser struct {
	optional           bool
	mock               *AuthHandlerMock
	defaultExpectation *AuthHandlerMockCreateUserExpectation
	expectations       []*AuthHandlerMockCreateUserExpectation

	callArgs []*AuthHandlerMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthHandlerMockCreateUserExpectation specifies expectation struct of the AuthHandler.CreateUser
type AuthHandlerMockCreateUserExpectation struct {
	mock               *AuthHandlerMock
	params             *AuthHandlerMockCreateUserParams
	paramPtrs          *AuthHandlerMockCreateUserParamPtrs
	expectationOrigins AuthHandlerMockCreateUserExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// AuthHandlerMockCreateUserParams contains parameters of the AuthHandler.CreateUser
type AuthHandlerMockCreateUserParams struct {
	c *gin.Context
}

// AuthHandlerMockCreateUserParamPtrs contains pointers to parameters of the AuthHandler.CreateUser
type AuthHandlerMockCreateUserParamPtrs struct {
	c **gin.Context
}

// AuthHandlerMockCreateUserOrigins contains origins of expectations of the AuthHandler.CreateUser
type AuthHandlerMockCreateUserExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mAuthHandlerMockCreateUser) Optional() *mAuthHandlerMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for AuthHandler.CreateUser
func (mmCreateUser *mAuthHandlerMockCreateUser) Expect(c *gin.Context) *mAuthHandlerMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthHandlerMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthHandlerMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("AuthHandlerMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &AuthHandlerMockCreateUserParams{c}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCParam1 sets up expected param c for AuthHandler.CreateUser
func (mmCreateUser *mAuthHandlerMockCreateUser) ExpectCParam1(c *gin.Context) *mAuthHandlerMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthHandlerMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthHandlerMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthHandlerMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthHandlerMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.c = &c
	mmCreateUser.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the AuthHandler.CreateUser
func (mmCreateUser *mAuthHandlerMockCreateUser) Inspect(f func(c *gin.Context)) *mAuthHandlerMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for AuthHandlerMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by AuthHandler.CreateUser
func (mmCreateUser *mAuthHandlerMockCreateUser) Return() *AuthHandlerMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthHandlerMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthHandlerMockCreateUserExpectation{mock: mmCreateUser.mock}
	}

	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the AuthHandler.CreateUser method
func (mmCreateUser *mAuthHandlerMockCreateUser) Set(f func(c *gin.Context)) *AuthHandlerMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the AuthHandler.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the AuthHandler.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the AuthHandler.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mAuthHandlerMockCreateUser) When(c *gin.Context) *AuthHandlerMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthHandlerMock.CreateUser mock is already set by Set")
	}

	expectation := &AuthHandlerMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &AuthHandlerMockCreateUserParams{c},
		expectationOrigins: AuthHandlerMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up AuthHandler.CreateUser return parameters for the expectation previously defined by the When method

func (e *AuthHandlerMockCreateUserExpectation) Then() *AuthHandlerMock {
	return e.mock
}

// Times sets number of times AuthHandler.CreateUser should be invoked
func (mmCreateUser *mAuthHandlerMockCreateUser) Times(n uint64) *mAuthHandlerMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of AuthHandlerMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mAuthHandlerMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_router.AuthHandler
func (mmCreateUser *AuthHandlerMock) CreateUser(c *gin.Context) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(c)
	}

	mm_params := AuthHandlerMockCreateUserParams{c}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := AuthHandlerMockCreateUserParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmCreateUser.t.Errorf("AuthHandlerMock.CreateUser got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("AuthHandlerMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCreateUser.funcCreateUser != nil {
		mmCreateUser.funcCreateUser(c)
		return
	}
	mmCreateUser.t.Fatalf("Unexpected call to AuthHandlerMock.CreateUser. %v", c)

}

// CreateUserAfterCounter returns a count of finished AuthHandlerMock.CreateUser invocations
func (mmCreateUser *AuthHandlerMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of AuthHandlerMock.CreateUser invocations
func (mmCreateUser *AuthHandlerMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to AuthHandlerMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mAuthHandlerMockCreateUser) Calls() []*AuthHandlerMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*AuthHandlerMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *AuthHandlerMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *AuthHandlerMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthHandlerMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthHandlerMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthHandlerMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to AuthHandlerMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthHandlerMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mAuthHandlerMockUserInfo struct {
	optional           bool
	mock               *AuthHandlerMock
	defaultExpectation *AuthHandlerMockUserInfoExpectation
	expectations       []*AuthHandlerMockUserInfoExpectation

	callArgs []*AuthHandlerMockUserInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthHandlerMockUserInfoExpectation specifies expectation struct of the AuthHandler.UserInfo
type AuthHandlerMockUserInfoExpectation struct {
	mock               *AuthHandlerMock
	params             *AuthHandlerMockUserInfoParams
	paramPtrs          *AuthHandlerMockUserInfoParamPtrs
	expectationOrigins AuthHandlerMockUserInfoExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// AuthHandlerMockUserInfoParams contains parameters of the AuthHandler.UserInfo
type AuthHandlerMockUserInfoParams struct {
	c *gin.Context
}

// AuthHandlerMockUserInfoParamPtrs contains pointers to parameters of the AuthHandler.UserInfo
type AuthHandlerMockUserInfoParamPtrs struct {
	c **gin.Context
}

// AuthHandlerMockUserInfoOrigins contains origins of expectations of the AuthHandler.UserInfo
type AuthHandlerMockUserInfoExpectationOrigins struct {
	origin  string
	originC string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserInfo *mAuthHandlerMockUserInfo) Optional() *mAuthHandlerMockUserInfo {
	mmUserInfo.optional = true
	return mmUserInfo
}

// Expect sets up expected params for AuthHandler.UserInfo
func (mmUserInfo *mAuthHandlerMockUserInfo) Expect(c *gin.Context) *mAuthHandlerMockUserInfo {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("AuthHandlerMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &AuthHandlerMockUserInfoExpectation{}
	}

	if mmUserInfo.defaultExpectation.paramPtrs != nil {
		mmUserInfo.mock.t.Fatalf("AuthHandlerMock.UserInfo mock is already set by ExpectParams functions")
	}

	mmUserInfo.defaultExpectation.params = &AuthHandlerMockUserInfoParams{c}
	mmUserInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserInfo.expectations {
		if minimock.Equal(e.params, mmUserInfo.defaultExpectation.params) {
			mmUserInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserInfo.defaultExpectation.params)
		}
	}

	return mmUserInfo
}

// ExpectCParam1 sets up expected param c for AuthHandler.UserInfo
func (mmUserInfo *mAuthHandlerMockUserInfo) ExpectCParam1(c *gin.Context) *mAuthHandlerMockUserInfo {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("AuthHandlerMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &AuthHandlerMockUserInfoExpectation{}
	}

	if mmUserInfo.defaultExpectation.params != nil {
		mmUserInfo.mock.t.Fatalf("AuthHandlerMock.UserInfo mock is already set by Expect")
	}

	if mmUserInfo.defaultExpectation.paramPtrs == nil {
		mmUserInfo.defaultExpectation.paramPtrs = &AuthHandlerMockUserInfoParamPtrs{}
	}
	mmUserInfo.defaultExpectation.paramPtrs.c = &c
	mmUserInfo.defaultExpectation.expectationOrigins.originC = minimock.CallerInfo(1)

	return mmUserInfo
}

// Inspect accepts an inspector function that has same arguments as the AuthHandler.UserInfo
func (mmUserInfo *mAuthHandlerMockUserInfo) Inspect(f func(c *gin.Context)) *mAuthHandlerMockUserInfo {
	if mmUserInfo.mock.inspectFuncUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("Inspect function is already set for AuthHandlerMock.UserInfo")
	}

	mmUserInfo.mock.inspectFuncUserInfo = f

	return mmUserInfo
}

// Return sets up results that will be returned by AuthHandler.UserInfo
func (mmUserInfo *mAuthHandlerMockUserInfo) Return() *AuthHandlerMock {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("AuthHandlerMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &AuthHandlerMockUserInfoExpectation{mock: mmUserInfo.mock}
	}

	mmUserInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserInfo.mock
}

// Set uses given function f to mock the AuthHandler.UserInfo method
func (mmUserInfo *mAuthHandlerMockUserInfo) Set(f func(c *gin.Context)) *AuthHandlerMock {
	if mmUserInfo.defaultExpectation != nil {
		mmUserInfo.mock.t.Fatalf("Default expectation is already set for the AuthHandler.UserInfo method")
	}

	if len(mmUserInfo.expectations) > 0 {
		mmUserInfo.mock.t.Fatalf("Some expectations are already set for the AuthHandler.UserInfo method")
	}

	mmUserInfo.mock.funcUserInfo = f
	mmUserInfo.mock.funcUserInfoOrigin = minimock.CallerInfo(1)
	return mmUserInfo.mock
}

// When sets expectation for the AuthHandler.UserInfo which will trigger the result defined by the following
// Then helper
func (mmUserInfo *mAuthHandlerMockUserInfo) When(c *gin.Context) *AuthHandlerMockUserInfoExpectation {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("AuthHandlerMock.UserInfo mock is already set by Set")
	}

	expectation := &AuthHandlerMockUserInfoExpectation{
		mock:               mmUserInfo.mock,
		params:             &AuthHandlerMockUserInfoParams{c},
		expectationOrigins: AuthHandlerMockUserInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserInfo.expectations = append(mmUserInfo.expectations, expectation)
	return expectation
}

// Then sets up AuthHandler.UserInfo return parameters for the expectation previously defined by the When method

func (e *AuthHandlerMockUserInfoExpectation) Then() *AuthHandlerMock {
	return e.mock
}

// Times sets number of times AuthHandler.UserInfo should be invoked
func (mmUserInfo *mAuthHandlerMockUserInfo) Times(n uint64) *mAuthHandlerMockUserInfo {
	if n == 0 {
		mmUserInfo.mock.t.Fatalf("Times of AuthHandlerMock.UserInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserInfo.expectedInvocations, n)
	mmUserInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserInfo
}

func (mmUserInfo *mAuthHandlerMockUserInfo) invocationsDone() bool {
	if len(mmUserInfo.expectations) == 0 && mmUserInfo.defaultExpectation == nil && mmUserInfo.mock.funcUserInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserInfo.mock.afterUserInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserInfo implements mm_router.AuthHandler
func (mmUserInfo *AuthHandlerMock) UserInfo(c *gin.Context) {
	mm_atomic.AddUint64(&mmUserInfo.beforeUserInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmUserInfo.afterUserInfoCounter, 1)

	mmUserInfo.t.Helper()

	if mmUserInfo.inspectFuncUserInfo != nil {
		mmUserInfo.inspectFuncUserInfo(c)
	}

	mm_params := AuthHandlerMockUserInfoParams{c}

	// Record call args
	mmUserInfo.UserInfoMock.mutex.Lock()
	mmUserInfo.UserInfoMock.callArgs = append(mmUserInfo.UserInfoMock.callArgs, &mm_params)
	mmUserInfo.UserInfoMock.mutex.Unlock()

	for _, e := range mmUserInfo.UserInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUserInfo.UserInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserInfo.UserInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmUserInfo.UserInfoMock.defaultExpectation.params
		mm_want_ptrs := mmUserInfo.UserInfoMock.defaultExpectation.paramPtrs

		mm_got := AuthHandlerMockUserInfoParams{c}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.c != nil && !minimock.Equal(*mm_want_ptrs.c, mm_got.c) {
				mmUserInfo.t.Errorf("AuthHandlerMock.UserInfo got unexpected parameter c, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserInfo.UserInfoMock.defaultExpectation.expectationOrigins.originC, *mm_want_ptrs.c, mm_got.c, minimock.Diff(*mm_want_ptrs.c, mm_got.c))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserInfo.t.Errorf("AuthHandlerMock.UserInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserInfo.UserInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmUserInfo.funcUserInfo != nil {
		mmUserInfo.funcUserInfo(c)
		return
	}
	mmUserInfo.t.Fatalf("Unexpected call to AuthHandlerMock.UserInfo. %v", c)

}

// UserInfoAfterCounter returns a count of finished AuthHandlerMock.UserInfo invocations
func (mmUserInfo *AuthHandlerMock) UserInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserInfo.afterUserInfoCounter)
}

// UserInfoBeforeCounter returns a count of AuthHandlerMock.UserInfo invocations
func (mmUserInfo *AuthHandlerMock) UserInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserInfo.beforeUserInfoCounter)
}

// Calls returns a list of arguments used in each call to AuthHandlerMock.UserInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserInfo *mAuthHandlerMockUserInfo) Calls() []*AuthHandlerMockUserInfoParams {
	mmUserInfo.mutex.RLock()

	argCopy := make([]*AuthHandlerMockUserInfoParams, len(mmUserInfo.callArgs))
	copy(argCopy, mmUserInfo.callArgs)

	mmUserInfo.mutex.RUnlock()

	return argCopy
}

// MinimockUserInfoDone returns true if the count of the UserInfo invocations corresponds
// the number of defined expectations
func (m *AuthHandlerMock) MinimockUserInfoDone() bool {
	if m.UserInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserInfoMock.invocationsDone()
}

// MinimockUserInfoInspect logs each unmet expectation
func (m *AuthHandlerMock) MinimockUserInfoInspect() {
	for _, e := range m.UserInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthHandlerMock.UserInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserInfoCounter := mm_atomic.LoadUint64(&m.afterUserInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserInfoMock.defaultExpectation != nil && afterUserInfoCounter < 1 {
		if m.UserInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthHandlerMock.UserInfo at\n%s", m.UserInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthHandlerMock.UserInfo at\n%s with params: %#v", m.UserInfoMock.defaultExpectation.expectationOrigins.origin, *m.UserInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserInfo != nil && afterUserInfoCounter < 1 {
		m.t.Errorf("Expected call to AuthHandlerMock.UserInfo at\n%s", m.funcUserInfoOrigin)
	}

	if !m.UserInfoMock.invocationsDone() && afterUserInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthHandlerMock.UserInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserInfoMock.expectedInvocations), m.UserInfoMock.expectedInvocationsOrigin, afterUserInfoCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAuthenticateInspect()

			m.MinimockCreateUserInspect()

			m.MinimockUserInfoInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAuthenticateDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockUserInfoDone()
}
