// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/service.Repository -o repository_mock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
	mm_service "github.com/maisiq/go-words-jar/internal/service"
)

// RepositoryMock implements mm_service.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddWord          func(ctx context.Context, w1 models.Word) (err error)
	funcAddWordOrigin    string
	inspectFuncAddWord   func(ctx context.Context, w1 models.Word)
	afterAddWordCounter  uint64
	beforeAddWordCounter uint64
	AddWordMock          mRepositoryMockAddWord

	funcAddWordToJar          func(ctx context.Context, username string, setRating float32, words ...string) (i1 int64, err error)
	funcAddWordToJarOrigin    string
	inspectFuncAddWordToJar   func(ctx context.Context, username string, setRating float32, words ...string)
	afterAddWordToJarCounter  uint64
	beforeAddWordToJarCounter uint64
	AddWordToJarMock          mRepositoryMockAddWordToJar

	funcGetJarWords          func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)
	funcGetJarWordsOrigin    string
	inspectFuncGetJarWords   func(ctx context.Context, username string, filters ...mm_service.Filter)
	afterGetJarWordsCounter  uint64
	beforeGetJarWordsCounter uint64
	GetJarWordsMock          mRepositoryMockGetJarWords

	funcGetUserWord          func(ctx context.Context, wordID string, username string) (up1 *models.UserWord, err error)
	funcGetUserWordOrigin    string
	inspectFuncGetUserWord   func(ctx context.Context, wordID string, username string)
	afterGetUserWordCounter  uint64
	beforeGetUserWordCounter uint64
	GetUserWordMock          mRepositoryMockGetUserWord

	funcGetWordByID          func(ctx context.Context, id string) (w1 models.Word, err error)
	funcGetWordByIDOrigin    string
	inspectFuncGetWordByID   func(ctx context.Context, id string)
	afterGetWordByIDCounter  uint64
	beforeGetWordByIDCounter uint64
	GetWordByIDMock          mRepositoryMockGetWordByID

	funcGetWordByName          func(ctx context.Context, wordName string) (w1 models.Word, err error)
	funcGetWordByNameOrigin    string
	inspectFuncGetWordByName   func(ctx context.Context, wordName string)
	afterGetWordByNameCounter  uint64
	beforeGetWordByNameCounter uint64
	GetWordByNameMock          mRepositoryMockGetWordByName

	funcUpdateUserWord          func(ctx context.Context, userWord *models.UserWord) (err error)
	funcUpdateUserWordOrigin    string
	inspectFuncUpdateUserWord   func(ctx context.Context, userWord *models.UserWord)
	afterUpdateUserWordCounter  uint64
	beforeUpdateUserWordCounter uint64
	UpdateUserWordMock          mRepositoryMockUpdateUserWord

	funcWordList          func(ctx context.Context, qp1 *mm_service.QueryParams) (wa1 []models.Word, err error)
	funcWordListOrigin    string
	inspectFuncWordList   func(ctx context.Context, qp1 *mm_service.QueryParams)
	afterWordListCounter  uint64
	beforeWordListCounter uint64
	WordListMock          mRepositoryMockWordList
}

// NewRepositoryMock returns a mock for mm_service.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddWordMock = mRepositoryMockAddWord{mock: m}
	m.AddWordMock.callArgs = []*RepositoryMockAddWordParams{}

	m.AddWordToJarMock = mRepositoryMockAddWordToJar{mock: m}
	m.AddWordToJarMock.callArgs = []*RepositoryMockAddWordToJarParams{}

	m.GetJarWordsMock = mRepositoryMockGetJarWords{mock: m}
	m.GetJarWordsMock.callArgs = []*RepositoryMockGetJarWordsParams{}

	m.GetUserWordMock = mRepositoryMockGetUserWord{mock: m}
	m.GetUserWordMock.callArgs = []*RepositoryMockGetUserWordParams{}

	m.GetWordByIDMock = mRepositoryMockGetWordByID{mock: m}
	m.GetWordByIDMock.callArgs = []*RepositoryMockGetWordByIDParams{}

	m.GetWordByNameMock = mRepositoryMockGetWordByName{mock: m}
	m.GetWordByNameMock.callArgs = []*RepositoryMockGetWordByNameParams{}

	m.UpdateUserWordMock = mRepositoryMockUpdateUserWord{mock: m}
	m.UpdateUserWordMock.callArgs = []*RepositoryMockUpdateUserWordParams{}

	m.WordListMock = mRepositoryMockWordList{mock: m}
	m.WordListMock.callArgs = []*RepositoryMockWordListParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddWord struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddWordExpectation
	expectations       []*RepositoryMockAddWordExpectation

	callArgs []*RepositoryMockAddWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddWordExpectation specifies expectation struct of the Repository.AddWord
type RepositoryMockAddWordExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddWordParams
	paramPtrs          *RepositoryMockAddWordParamPtrs
	expectationOrigins RepositoryMockAddWordExpectationOrigins
	results            *RepositoryMockAddWordResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddWordParams contains parameters of the Repository.AddWord
type RepositoryMockAddWordParams struct {
	ctx context.Context
	w1  models.Word
}

// RepositoryMockAddWordParamPtrs contains pointers to parameters of the Repository.AddWord
type RepositoryMockAddWordParamPtrs struct {
	ctx *context.Context
	w1  *models.Word
}

// RepositoryMockAddWordResults contains results of the Repository.AddWord
type RepositoryMockAddWordResults struct {
	err error
}

// RepositoryMockAddWordOrigins contains origins of expectations of the Repository.AddWord
type RepositoryMockAddWordExpectationOrigins struct {
	origin    string
	originCtx string
	originW1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddWord *mRepositoryMockAddWord) Optional() *mRepositoryMockAddWord {
	mmAddWord.optional = true
	return mmAddWord
}

// Expect sets up expected params for Repository.AddWord
func (mmAddWord *mRepositoryMockAddWord) Expect(ctx context.Context, w1 models.Word) *mRepositoryMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("RepositoryMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &RepositoryMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.paramPtrs != nil {
		mmAddWord.mock.t.Fatalf("RepositoryMock.AddWord mock is already set by ExpectParams functions")
	}

	mmAddWord.defaultExpectation.params = &RepositoryMockAddWordParams{ctx, w1}
	mmAddWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddWord.expectations {
		if minimock.Equal(e.params, mmAddWord.defaultExpectation.params) {
			mmAddWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddWord.defaultExpectation.params)
		}
	}

	return mmAddWord
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddWord
func (mmAddWord *mRepositoryMockAddWord) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("RepositoryMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &RepositoryMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.params != nil {
		mmAddWord.mock.t.Fatalf("RepositoryMock.AddWord mock is already set by Expect")
	}

	if mmAddWord.defaultExpectation.paramPtrs == nil {
		mmAddWord.defaultExpectation.paramPtrs = &RepositoryMockAddWordParamPtrs{}
	}
	mmAddWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddWord
}

// ExpectW1Param2 sets up expected param w1 for Repository.AddWord
func (mmAddWord *mRepositoryMockAddWord) ExpectW1Param2(w1 models.Word) *mRepositoryMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("RepositoryMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &RepositoryMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.params != nil {
		mmAddWord.mock.t.Fatalf("RepositoryMock.AddWord mock is already set by Expect")
	}

	if mmAddWord.defaultExpectation.paramPtrs == nil {
		mmAddWord.defaultExpectation.paramPtrs = &RepositoryMockAddWordParamPtrs{}
	}
	mmAddWord.defaultExpectation.paramPtrs.w1 = &w1
	mmAddWord.defaultExpectation.expectationOrigins.originW1 = minimock.CallerInfo(1)

	return mmAddWord
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddWord
func (mmAddWord *mRepositoryMockAddWord) Inspect(f func(ctx context.Context, w1 models.Word)) *mRepositoryMockAddWord {
	if mmAddWord.mock.inspectFuncAddWord != nil {
		mmAddWord.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddWord")
	}

	mmAddWord.mock.inspectFuncAddWord = f

	return mmAddWord
}

// Return sets up results that will be returned by Repository.AddWord
func (mmAddWord *mRepositoryMockAddWord) Return(err error) *RepositoryMock {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("RepositoryMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &RepositoryMockAddWordExpectation{mock: mmAddWord.mock}
	}
	mmAddWord.defaultExpectation.results = &RepositoryMockAddWordResults{err}
	mmAddWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddWord.mock
}

// Set uses given function f to mock the Repository.AddWord method
func (mmAddWord *mRepositoryMockAddWord) Set(f func(ctx context.Context, w1 models.Word) (err error)) *RepositoryMock {
	if mmAddWord.defaultExpectation != nil {
		mmAddWord.mock.t.Fatalf("Default expectation is already set for the Repository.AddWord method")
	}

	if len(mmAddWord.expectations) > 0 {
		mmAddWord.mock.t.Fatalf("Some expectations are already set for the Repository.AddWord method")
	}

	mmAddWord.mock.funcAddWord = f
	mmAddWord.mock.funcAddWordOrigin = minimock.CallerInfo(1)
	return mmAddWord.mock
}

// When sets expectation for the Repository.AddWord which will trigger the result defined by the following
// Then helper
func (mmAddWord *mRepositoryMockAddWord) When(ctx context.Context, w1 models.Word) *RepositoryMockAddWordExpectation {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("RepositoryMock.AddWord mock is already set by Set")
	}

	expectation := &RepositoryMockAddWordExpectation{
		mock:               mmAddWord.mock,
		params:             &RepositoryMockAddWordParams{ctx, w1},
		expectationOrigins: RepositoryMockAddWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddWord.expectations = append(mmAddWord.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddWord return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddWordExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddWordResults{err}
	return e.mock
}

// Times sets number of times Repository.AddWord should be invoked
func (mmAddWord *mRepositoryMockAddWord) Times(n uint64) *mRepositoryMockAddWord {
	if n == 0 {
		mmAddWord.mock.t.Fatalf("Times of RepositoryMock.AddWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddWord.expectedInvocations, n)
	mmAddWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddWord
}

func (mmAddWord *mRepositoryMockAddWord) invocationsDone() bool {
	if len(mmAddWord.expectations) == 0 && mmAddWord.defaultExpectation == nil && mmAddWord.mock.funcAddWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddWord.mock.afterAddWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddWord implements mm_service.Repository
func (mmAddWord *RepositoryMock) AddWord(ctx context.Context, w1 models.Word) (err error) {
	mm_atomic.AddUint64(&mmAddWord.beforeAddWordCounter, 1)
	defer mm_atomic.AddUint64(&mmAddWord.afterAddWordCounter, 1)

	mmAddWord.t.Helper()

	if mmAddWord.inspectFuncAddWord != nil {
		mmAddWord.inspectFuncAddWord(ctx, w1)
	}

	mm_params := RepositoryMockAddWordParams{ctx, w1}

	// Record call args
	mmAddWord.AddWordMock.mutex.Lock()
	mmAddWord.AddWordMock.callArgs = append(mmAddWord.AddWordMock.callArgs, &mm_params)
	mmAddWord.AddWordMock.mutex.Unlock()

	for _, e := range mmAddWord.AddWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddWord.AddWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddWord.AddWordMock.defaultExpectation.Counter, 1)
		mm_want := mmAddWord.AddWordMock.defaultExpectation.params
		mm_want_ptrs := mmAddWord.AddWordMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddWordParams{ctx, w1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddWord.t.Errorf("RepositoryMock.AddWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.w1 != nil && !minimock.Equal(*mm_want_ptrs.w1, mm_got.w1) {
				mmAddWord.t.Errorf("RepositoryMock.AddWord got unexpected parameter w1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.originW1, *mm_want_ptrs.w1, mm_got.w1, minimock.Diff(*mm_want_ptrs.w1, mm_got.w1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddWord.t.Errorf("RepositoryMock.AddWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddWord.AddWordMock.defaultExpectation.results
		if mm_results == nil {
			mmAddWord.t.Fatal("No results are set for the RepositoryMock.AddWord")
		}
		return (*mm_results).err
	}
	if mmAddWord.funcAddWord != nil {
		return mmAddWord.funcAddWord(ctx, w1)
	}
	mmAddWord.t.Fatalf("Unexpected call to RepositoryMock.AddWord. %v %v", ctx, w1)
	return
}

// AddWordAfterCounter returns a count of finished RepositoryMock.AddWord invocations
func (mmAddWord *RepositoryMock) AddWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWord.afterAddWordCounter)
}

// AddWordBeforeCounter returns a count of RepositoryMock.AddWord invocations
func (mmAddWord *RepositoryMock) AddWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWord.beforeAddWordCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddWord *mRepositoryMockAddWord) Calls() []*RepositoryMockAddWordParams {
	mmAddWord.mutex.RLock()

	argCopy := make([]*RepositoryMockAddWordParams, len(mmAddWord.callArgs))
	copy(argCopy, mmAddWord.callArgs)

	mmAddWord.mutex.RUnlock()

	return argCopy
}

// MinimockAddWordDone returns true if the count of the AddWord invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddWordDone() bool {
	if m.AddWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddWordMock.invocationsDone()
}

// MinimockAddWordInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddWordInspect() {
	for _, e := range m.AddWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddWordCounter := mm_atomic.LoadUint64(&m.afterAddWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddWordMock.defaultExpectation != nil && afterAddWordCounter < 1 {
		if m.AddWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddWord at\n%s", m.AddWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddWord at\n%s with params: %#v", m.AddWordMock.defaultExpectation.expectationOrigins.origin, *m.AddWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddWord != nil && afterAddWordCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddWord at\n%s", m.funcAddWordOrigin)
	}

	if !m.AddWordMock.invocationsDone() && afterAddWordCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddWordMock.expectedInvocations), m.AddWordMock.expectedInvocationsOrigin, afterAddWordCounter)
	}
}

type mRepositoryMockAddWordToJar struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddWordToJarExpectation
	expectations       []*RepositoryMockAddWordToJarExpectation

	callArgs []*RepositoryMockAddWordToJarParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddWordToJarExpectation specifies expectation struct of the Repository.AddWordToJar
type RepositoryMockAddWordToJarExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddWordToJarParams
	paramPtrs          *RepositoryMockAddWordToJarParamPtrs
	expectationOrigins RepositoryMockAddWordToJarExpectationOrigins
	results            *RepositoryMockAddWordToJarResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddWordToJarParams contains parameters of the Repository.AddWordToJar
type RepositoryMockAddWordToJarParams struct {
	ctx       context.Context
	username  string
	setRating float32
	words     []string
}

// RepositoryMockAddWordToJarParamPtrs contains pointers to parameters of the Repository.AddWordToJar
type RepositoryMockAddWordToJarParamPtrs struct {
	ctx       *context.Context
	username  *string
	setRating *float32
	words     *[]string
}

// RepositoryMockAddWordToJarResults contains results of the Repository.AddWordToJar
type RepositoryMockAddWordToJarResults struct {
	i1  int64
	err error
}

// RepositoryMockAddWordToJarOrigins contains origins of expectations of the Repository.AddWordToJar
type RepositoryMockAddWordToJarExpectationOrigins struct {
	origin          string
	originCtx       string
	originUsername  string
	originSetRating string
	originWords     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddWordToJar *mRepositoryMockAddWordToJar) Optional() *mRepositoryMockAddWordToJar {
	mmAddWordToJar.optional = true
	return mmAddWordToJar
}

// Expect sets up expected params for Repository.AddWordToJar
func (mmAddWordToJar *mRepositoryMockAddWordToJar) Expect(ctx context.Context, username string, setRating float32, words ...string) *mRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &RepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by ExpectParams functions")
	}

	mmAddWordToJar.defaultExpectation.params = &RepositoryMockAddWordToJarParams{ctx, username, setRating, words}
	mmAddWordToJar.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddWordToJar.expectations {
		if minimock.Equal(e.params, mmAddWordToJar.defaultExpectation.params) {
			mmAddWordToJar.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddWordToJar.defaultExpectation.params)
		}
	}

	return mmAddWordToJar
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddWordToJar
func (mmAddWordToJar *mRepositoryMockAddWordToJar) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &RepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &RepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddWordToJar.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// ExpectUsernameParam2 sets up expected param username for Repository.AddWordToJar
func (mmAddWordToJar *mRepositoryMockAddWordToJar) ExpectUsernameParam2(username string) *mRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &RepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &RepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.username = &username
	mmAddWordToJar.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// ExpectSetRatingParam3 sets up expected param setRating for Repository.AddWordToJar
func (mmAddWordToJar *mRepositoryMockAddWordToJar) ExpectSetRatingParam3(setRating float32) *mRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &RepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &RepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.setRating = &setRating
	mmAddWordToJar.defaultExpectation.expectationOrigins.originSetRating = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// ExpectWordsParam4 sets up expected param words for Repository.AddWordToJar
func (mmAddWordToJar *mRepositoryMockAddWordToJar) ExpectWordsParam4(words ...string) *mRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &RepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &RepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.words = &words
	mmAddWordToJar.defaultExpectation.expectationOrigins.originWords = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddWordToJar
func (mmAddWordToJar *mRepositoryMockAddWordToJar) Inspect(f func(ctx context.Context, username string, setRating float32, words ...string)) *mRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.inspectFuncAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddWordToJar")
	}

	mmAddWordToJar.mock.inspectFuncAddWordToJar = f

	return mmAddWordToJar
}

// Return sets up results that will be returned by Repository.AddWordToJar
func (mmAddWordToJar *mRepositoryMockAddWordToJar) Return(i1 int64, err error) *RepositoryMock {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &RepositoryMockAddWordToJarExpectation{mock: mmAddWordToJar.mock}
	}
	mmAddWordToJar.defaultExpectation.results = &RepositoryMockAddWordToJarResults{i1, err}
	mmAddWordToJar.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar.mock
}

// Set uses given function f to mock the Repository.AddWordToJar method
func (mmAddWordToJar *mRepositoryMockAddWordToJar) Set(f func(ctx context.Context, username string, setRating float32, words ...string) (i1 int64, err error)) *RepositoryMock {
	if mmAddWordToJar.defaultExpectation != nil {
		mmAddWordToJar.mock.t.Fatalf("Default expectation is already set for the Repository.AddWordToJar method")
	}

	if len(mmAddWordToJar.expectations) > 0 {
		mmAddWordToJar.mock.t.Fatalf("Some expectations are already set for the Repository.AddWordToJar method")
	}

	mmAddWordToJar.mock.funcAddWordToJar = f
	mmAddWordToJar.mock.funcAddWordToJarOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar.mock
}

// When sets expectation for the Repository.AddWordToJar which will trigger the result defined by the following
// Then helper
func (mmAddWordToJar *mRepositoryMockAddWordToJar) When(ctx context.Context, username string, setRating float32, words ...string) *RepositoryMockAddWordToJarExpectation {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("RepositoryMock.AddWordToJar mock is already set by Set")
	}

	expectation := &RepositoryMockAddWordToJarExpectation{
		mock:               mmAddWordToJar.mock,
		params:             &RepositoryMockAddWordToJarParams{ctx, username, setRating, words},
		expectationOrigins: RepositoryMockAddWordToJarExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddWordToJar.expectations = append(mmAddWordToJar.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddWordToJar return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddWordToJarExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockAddWordToJarResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.AddWordToJar should be invoked
func (mmAddWordToJar *mRepositoryMockAddWordToJar) Times(n uint64) *mRepositoryMockAddWordToJar {
	if n == 0 {
		mmAddWordToJar.mock.t.Fatalf("Times of RepositoryMock.AddWordToJar mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddWordToJar.expectedInvocations, n)
	mmAddWordToJar.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar
}

func (mmAddWordToJar *mRepositoryMockAddWordToJar) invocationsDone() bool {
	if len(mmAddWordToJar.expectations) == 0 && mmAddWordToJar.defaultExpectation == nil && mmAddWordToJar.mock.funcAddWordToJar == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddWordToJar.mock.afterAddWordToJarCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddWordToJar.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddWordToJar implements mm_service.Repository
func (mmAddWordToJar *RepositoryMock) AddWordToJar(ctx context.Context, username string, setRating float32, words ...string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmAddWordToJar.beforeAddWordToJarCounter, 1)
	defer mm_atomic.AddUint64(&mmAddWordToJar.afterAddWordToJarCounter, 1)

	mmAddWordToJar.t.Helper()

	if mmAddWordToJar.inspectFuncAddWordToJar != nil {
		mmAddWordToJar.inspectFuncAddWordToJar(ctx, username, setRating, words...)
	}

	mm_params := RepositoryMockAddWordToJarParams{ctx, username, setRating, words}

	// Record call args
	mmAddWordToJar.AddWordToJarMock.mutex.Lock()
	mmAddWordToJar.AddWordToJarMock.callArgs = append(mmAddWordToJar.AddWordToJarMock.callArgs, &mm_params)
	mmAddWordToJar.AddWordToJarMock.mutex.Unlock()

	for _, e := range mmAddWordToJar.AddWordToJarMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddWordToJar.AddWordToJarMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddWordToJar.AddWordToJarMock.defaultExpectation.Counter, 1)
		mm_want := mmAddWordToJar.AddWordToJarMock.defaultExpectation.params
		mm_want_ptrs := mmAddWordToJar.AddWordToJarMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddWordToJarParams{ctx, username, setRating, words}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddWordToJar.t.Errorf("RepositoryMock.AddWordToJar got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmAddWordToJar.t.Errorf("RepositoryMock.AddWordToJar got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.setRating != nil && !minimock.Equal(*mm_want_ptrs.setRating, mm_got.setRating) {
				mmAddWordToJar.t.Errorf("RepositoryMock.AddWordToJar got unexpected parameter setRating, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originSetRating, *mm_want_ptrs.setRating, mm_got.setRating, minimock.Diff(*mm_want_ptrs.setRating, mm_got.setRating))
			}

			if mm_want_ptrs.words != nil && !minimock.Equal(*mm_want_ptrs.words, mm_got.words) {
				mmAddWordToJar.t.Errorf("RepositoryMock.AddWordToJar got unexpected parameter words, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originWords, *mm_want_ptrs.words, mm_got.words, minimock.Diff(*mm_want_ptrs.words, mm_got.words))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddWordToJar.t.Errorf("RepositoryMock.AddWordToJar got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddWordToJar.AddWordToJarMock.defaultExpectation.results
		if mm_results == nil {
			mmAddWordToJar.t.Fatal("No results are set for the RepositoryMock.AddWordToJar")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddWordToJar.funcAddWordToJar != nil {
		return mmAddWordToJar.funcAddWordToJar(ctx, username, setRating, words...)
	}
	mmAddWordToJar.t.Fatalf("Unexpected call to RepositoryMock.AddWordToJar. %v %v %v %v", ctx, username, setRating, words)
	return
}

// AddWordToJarAfterCounter returns a count of finished RepositoryMock.AddWordToJar invocations
func (mmAddWordToJar *RepositoryMock) AddWordToJarAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordToJar.afterAddWordToJarCounter)
}

// AddWordToJarBeforeCounter returns a count of RepositoryMock.AddWordToJar invocations
func (mmAddWordToJar *RepositoryMock) AddWordToJarBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordToJar.beforeAddWordToJarCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddWordToJar.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddWordToJar *mRepositoryMockAddWordToJar) Calls() []*RepositoryMockAddWordToJarParams {
	mmAddWordToJar.mutex.RLock()

	argCopy := make([]*RepositoryMockAddWordToJarParams, len(mmAddWordToJar.callArgs))
	copy(argCopy, mmAddWordToJar.callArgs)

	mmAddWordToJar.mutex.RUnlock()

	return argCopy
}

// MinimockAddWordToJarDone returns true if the count of the AddWordToJar invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddWordToJarDone() bool {
	if m.AddWordToJarMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddWordToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddWordToJarMock.invocationsDone()
}

// MinimockAddWordToJarInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddWordToJarInspect() {
	for _, e := range m.AddWordToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddWordToJar at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddWordToJarCounter := mm_atomic.LoadUint64(&m.afterAddWordToJarCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddWordToJarMock.defaultExpectation != nil && afterAddWordToJarCounter < 1 {
		if m.AddWordToJarMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddWordToJar at\n%s", m.AddWordToJarMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddWordToJar at\n%s with params: %#v", m.AddWordToJarMock.defaultExpectation.expectationOrigins.origin, *m.AddWordToJarMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddWordToJar != nil && afterAddWordToJarCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddWordToJar at\n%s", m.funcAddWordToJarOrigin)
	}

	if !m.AddWordToJarMock.invocationsDone() && afterAddWordToJarCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddWordToJar at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddWordToJarMock.expectedInvocations), m.AddWordToJarMock.expectedInvocationsOrigin, afterAddWordToJarCounter)
	}
}

type mRepositoryMockGetJarWords struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetJarWordsExpectation
	expectations       []*RepositoryMockGetJarWordsExpectation

	callArgs []*RepositoryMockGetJarWordsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetJarWordsExpectation specifies expectation struct of the Repository.GetJarWords
type RepositoryMockGetJarWordsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetJarWordsParams
	paramPtrs          *RepositoryMockGetJarWordsParamPtrs
	expectationOrigins RepositoryMockGetJarWordsExpectationOrigins
	results            *RepositoryMockGetJarWordsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetJarWordsParams contains parameters of the Repository.GetJarWords
type RepositoryMockGetJarWordsParams struct {
	ctx      context.Context
	username string
	filters  []mm_service.Filter
}

// RepositoryMockGetJarWordsParamPtrs contains pointers to parameters of the Repository.GetJarWords
type RepositoryMockGetJarWordsParamPtrs struct {
	ctx      *context.Context
	username *string
	filters  *[]mm_service.Filter
}

// RepositoryMockGetJarWordsResults contains results of the Repository.GetJarWords
type RepositoryMockGetJarWordsResults struct {
	wa1 []models.Word
	err error
}

// RepositoryMockGetJarWordsOrigins contains origins of expectations of the Repository.GetJarWords
type RepositoryMockGetJarWordsExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originFilters  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetJarWords *mRepositoryMockGetJarWords) Optional() *mRepositoryMockGetJarWords {
	mmGetJarWords.optional = true
	return mmGetJarWords
}

// Expect sets up expected params for Repository.GetJarWords
func (mmGetJarWords *mRepositoryMockGetJarWords) Expect(ctx context.Context, username string, filters ...mm_service.Filter) *mRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &RepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.paramPtrs != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by ExpectParams functions")
	}

	mmGetJarWords.defaultExpectation.params = &RepositoryMockGetJarWordsParams{ctx, username, filters}
	mmGetJarWords.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetJarWords.expectations {
		if minimock.Equal(e.params, mmGetJarWords.defaultExpectation.params) {
			mmGetJarWords.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetJarWords.defaultExpectation.params)
		}
	}

	return mmGetJarWords
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetJarWords
func (mmGetJarWords *mRepositoryMockGetJarWords) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &RepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.params != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by Expect")
	}

	if mmGetJarWords.defaultExpectation.paramPtrs == nil {
		mmGetJarWords.defaultExpectation.paramPtrs = &RepositoryMockGetJarWordsParamPtrs{}
	}
	mmGetJarWords.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetJarWords.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetJarWords
}

// ExpectUsernameParam2 sets up expected param username for Repository.GetJarWords
func (mmGetJarWords *mRepositoryMockGetJarWords) ExpectUsernameParam2(username string) *mRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &RepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.params != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by Expect")
	}

	if mmGetJarWords.defaultExpectation.paramPtrs == nil {
		mmGetJarWords.defaultExpectation.paramPtrs = &RepositoryMockGetJarWordsParamPtrs{}
	}
	mmGetJarWords.defaultExpectation.paramPtrs.username = &username
	mmGetJarWords.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetJarWords
}

// ExpectFiltersParam3 sets up expected param filters for Repository.GetJarWords
func (mmGetJarWords *mRepositoryMockGetJarWords) ExpectFiltersParam3(filters ...mm_service.Filter) *mRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &RepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.params != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by Expect")
	}

	if mmGetJarWords.defaultExpectation.paramPtrs == nil {
		mmGetJarWords.defaultExpectation.paramPtrs = &RepositoryMockGetJarWordsParamPtrs{}
	}
	mmGetJarWords.defaultExpectation.paramPtrs.filters = &filters
	mmGetJarWords.defaultExpectation.expectationOrigins.originFilters = minimock.CallerInfo(1)

	return mmGetJarWords
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetJarWords
func (mmGetJarWords *mRepositoryMockGetJarWords) Inspect(f func(ctx context.Context, username string, filters ...mm_service.Filter)) *mRepositoryMockGetJarWords {
	if mmGetJarWords.mock.inspectFuncGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetJarWords")
	}

	mmGetJarWords.mock.inspectFuncGetJarWords = f

	return mmGetJarWords
}

// Return sets up results that will be returned by Repository.GetJarWords
func (mmGetJarWords *mRepositoryMockGetJarWords) Return(wa1 []models.Word, err error) *RepositoryMock {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &RepositoryMockGetJarWordsExpectation{mock: mmGetJarWords.mock}
	}
	mmGetJarWords.defaultExpectation.results = &RepositoryMockGetJarWordsResults{wa1, err}
	mmGetJarWords.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetJarWords.mock
}

// Set uses given function f to mock the Repository.GetJarWords method
func (mmGetJarWords *mRepositoryMockGetJarWords) Set(f func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)) *RepositoryMock {
	if mmGetJarWords.defaultExpectation != nil {
		mmGetJarWords.mock.t.Fatalf("Default expectation is already set for the Repository.GetJarWords method")
	}

	if len(mmGetJarWords.expectations) > 0 {
		mmGetJarWords.mock.t.Fatalf("Some expectations are already set for the Repository.GetJarWords method")
	}

	mmGetJarWords.mock.funcGetJarWords = f
	mmGetJarWords.mock.funcGetJarWordsOrigin = minimock.CallerInfo(1)
	return mmGetJarWords.mock
}

// When sets expectation for the Repository.GetJarWords which will trigger the result defined by the following
// Then helper
func (mmGetJarWords *mRepositoryMockGetJarWords) When(ctx context.Context, username string, filters ...mm_service.Filter) *RepositoryMockGetJarWordsExpectation {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("RepositoryMock.GetJarWords mock is already set by Set")
	}

	expectation := &RepositoryMockGetJarWordsExpectation{
		mock:               mmGetJarWords.mock,
		params:             &RepositoryMockGetJarWordsParams{ctx, username, filters},
		expectationOrigins: RepositoryMockGetJarWordsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetJarWords.expectations = append(mmGetJarWords.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetJarWords return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetJarWordsExpectation) Then(wa1 []models.Word, err error) *RepositoryMock {
	e.results = &RepositoryMockGetJarWordsResults{wa1, err}
	return e.mock
}

// Times sets number of times Repository.GetJarWords should be invoked
func (mmGetJarWords *mRepositoryMockGetJarWords) Times(n uint64) *mRepositoryMockGetJarWords {
	if n == 0 {
		mmGetJarWords.mock.t.Fatalf("Times of RepositoryMock.GetJarWords mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetJarWords.expectedInvocations, n)
	mmGetJarWords.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetJarWords
}

func (mmGetJarWords *mRepositoryMockGetJarWords) invocationsDone() bool {
	if len(mmGetJarWords.expectations) == 0 && mmGetJarWords.defaultExpectation == nil && mmGetJarWords.mock.funcGetJarWords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetJarWords.mock.afterGetJarWordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetJarWords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetJarWords implements mm_service.Repository
func (mmGetJarWords *RepositoryMock) GetJarWords(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error) {
	mm_atomic.AddUint64(&mmGetJarWords.beforeGetJarWordsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetJarWords.afterGetJarWordsCounter, 1)

	mmGetJarWords.t.Helper()

	if mmGetJarWords.inspectFuncGetJarWords != nil {
		mmGetJarWords.inspectFuncGetJarWords(ctx, username, filters...)
	}

	mm_params := RepositoryMockGetJarWordsParams{ctx, username, filters}

	// Record call args
	mmGetJarWords.GetJarWordsMock.mutex.Lock()
	mmGetJarWords.GetJarWordsMock.callArgs = append(mmGetJarWords.GetJarWordsMock.callArgs, &mm_params)
	mmGetJarWords.GetJarWordsMock.mutex.Unlock()

	for _, e := range mmGetJarWords.GetJarWordsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmGetJarWords.GetJarWordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetJarWords.GetJarWordsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetJarWords.GetJarWordsMock.defaultExpectation.params
		mm_want_ptrs := mmGetJarWords.GetJarWordsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetJarWordsParams{ctx, username, filters}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetJarWords.t.Errorf("RepositoryMock.GetJarWords got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetJarWords.t.Errorf("RepositoryMock.GetJarWords got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.filters != nil && !minimock.Equal(*mm_want_ptrs.filters, mm_got.filters) {
				mmGetJarWords.t.Errorf("RepositoryMock.GetJarWords got unexpected parameter filters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.originFilters, *mm_want_ptrs.filters, mm_got.filters, minimock.Diff(*mm_want_ptrs.filters, mm_got.filters))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetJarWords.t.Errorf("RepositoryMock.GetJarWords got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetJarWords.GetJarWordsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetJarWords.t.Fatal("No results are set for the RepositoryMock.GetJarWords")
		}
		return (*mm_results).wa1, (*mm_results).err
	}
	if mmGetJarWords.funcGetJarWords != nil {
		return mmGetJarWords.funcGetJarWords(ctx, username, filters...)
	}
	mmGetJarWords.t.Fatalf("Unexpected call to RepositoryMock.GetJarWords. %v %v %v", ctx, username, filters)
	return
}

// GetJarWordsAfterCounter returns a count of finished RepositoryMock.GetJarWords invocations
func (mmGetJarWords *RepositoryMock) GetJarWordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJarWords.afterGetJarWordsCounter)
}

// GetJarWordsBeforeCounter returns a count of RepositoryMock.GetJarWords invocations
func (mmGetJarWords *RepositoryMock) GetJarWordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJarWords.beforeGetJarWordsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetJarWords.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetJarWords *mRepositoryMockGetJarWords) Calls() []*RepositoryMockGetJarWordsParams {
	mmGetJarWords.mutex.RLock()

	argCopy := make([]*RepositoryMockGetJarWordsParams, len(mmGetJarWords.callArgs))
	copy(argCopy, mmGetJarWords.callArgs)

	mmGetJarWords.mutex.RUnlock()

	return argCopy
}

// MinimockGetJarWordsDone returns true if the count of the GetJarWords invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetJarWordsDone() bool {
	if m.GetJarWordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetJarWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetJarWordsMock.invocationsDone()
}

// MinimockGetJarWordsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetJarWordsInspect() {
	for _, e := range m.GetJarWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetJarWords at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetJarWordsCounter := mm_atomic.LoadUint64(&m.afterGetJarWordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetJarWordsMock.defaultExpectation != nil && afterGetJarWordsCounter < 1 {
		if m.GetJarWordsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetJarWords at\n%s", m.GetJarWordsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetJarWords at\n%s with params: %#v", m.GetJarWordsMock.defaultExpectation.expectationOrigins.origin, *m.GetJarWordsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJarWords != nil && afterGetJarWordsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetJarWords at\n%s", m.funcGetJarWordsOrigin)
	}

	if !m.GetJarWordsMock.invocationsDone() && afterGetJarWordsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetJarWords at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetJarWordsMock.expectedInvocations), m.GetJarWordsMock.expectedInvocationsOrigin, afterGetJarWordsCounter)
	}
}

type mRepositoryMockGetUserWord struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserWordExpectation
	expectations       []*RepositoryMockGetUserWordExpectation

	callArgs []*RepositoryMockGetUserWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetUserWordExpectation specifies expectation struct of the Repository.GetUserWord
type RepositoryMockGetUserWordExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetUserWordParams
	paramPtrs          *RepositoryMockGetUserWordParamPtrs
	expectationOrigins RepositoryMockGetUserWordExpectationOrigins
	results            *RepositoryMockGetUserWordResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetUserWordParams contains parameters of the Repository.GetUserWord
type RepositoryMockGetUserWordParams struct {
	ctx      context.Context
	wordID   string
	username string
}

// RepositoryMockGetUserWordParamPtrs contains pointers to parameters of the Repository.GetUserWord
type RepositoryMockGetUserWordParamPtrs struct {
	ctx      *context.Context
	wordID   *string
	username *string
}

// RepositoryMockGetUserWordResults contains results of the Repository.GetUserWord
type RepositoryMockGetUserWordResults struct {
	up1 *models.UserWord
	err error
}

// RepositoryMockGetUserWordOrigins contains origins of expectations of the Repository.GetUserWord
type RepositoryMockGetUserWordExpectationOrigins struct {
	origin         string
	originCtx      string
	originWordID   string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserWord *mRepositoryMockGetUserWord) Optional() *mRepositoryMockGetUserWord {
	mmGetUserWord.optional = true
	return mmGetUserWord
}

// Expect sets up expected params for Repository.GetUserWord
func (mmGetUserWord *mRepositoryMockGetUserWord) Expect(ctx context.Context, wordID string, username string) *mRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &RepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.paramPtrs != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by ExpectParams functions")
	}

	mmGetUserWord.defaultExpectation.params = &RepositoryMockGetUserWordParams{ctx, wordID, username}
	mmGetUserWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserWord.expectations {
		if minimock.Equal(e.params, mmGetUserWord.defaultExpectation.params) {
			mmGetUserWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserWord.defaultExpectation.params)
		}
	}

	return mmGetUserWord
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetUserWord
func (mmGetUserWord *mRepositoryMockGetUserWord) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &RepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.params != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by Expect")
	}

	if mmGetUserWord.defaultExpectation.paramPtrs == nil {
		mmGetUserWord.defaultExpectation.paramPtrs = &RepositoryMockGetUserWordParamPtrs{}
	}
	mmGetUserWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserWord
}

// ExpectWordIDParam2 sets up expected param wordID for Repository.GetUserWord
func (mmGetUserWord *mRepositoryMockGetUserWord) ExpectWordIDParam2(wordID string) *mRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &RepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.params != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by Expect")
	}

	if mmGetUserWord.defaultExpectation.paramPtrs == nil {
		mmGetUserWord.defaultExpectation.paramPtrs = &RepositoryMockGetUserWordParamPtrs{}
	}
	mmGetUserWord.defaultExpectation.paramPtrs.wordID = &wordID
	mmGetUserWord.defaultExpectation.expectationOrigins.originWordID = minimock.CallerInfo(1)

	return mmGetUserWord
}

// ExpectUsernameParam3 sets up expected param username for Repository.GetUserWord
func (mmGetUserWord *mRepositoryMockGetUserWord) ExpectUsernameParam3(username string) *mRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &RepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.params != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by Expect")
	}

	if mmGetUserWord.defaultExpectation.paramPtrs == nil {
		mmGetUserWord.defaultExpectation.paramPtrs = &RepositoryMockGetUserWordParamPtrs{}
	}
	mmGetUserWord.defaultExpectation.paramPtrs.username = &username
	mmGetUserWord.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserWord
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUserWord
func (mmGetUserWord *mRepositoryMockGetUserWord) Inspect(f func(ctx context.Context, wordID string, username string)) *mRepositoryMockGetUserWord {
	if mmGetUserWord.mock.inspectFuncGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUserWord")
	}

	mmGetUserWord.mock.inspectFuncGetUserWord = f

	return mmGetUserWord
}

// Return sets up results that will be returned by Repository.GetUserWord
func (mmGetUserWord *mRepositoryMockGetUserWord) Return(up1 *models.UserWord, err error) *RepositoryMock {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &RepositoryMockGetUserWordExpectation{mock: mmGetUserWord.mock}
	}
	mmGetUserWord.defaultExpectation.results = &RepositoryMockGetUserWordResults{up1, err}
	mmGetUserWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserWord.mock
}

// Set uses given function f to mock the Repository.GetUserWord method
func (mmGetUserWord *mRepositoryMockGetUserWord) Set(f func(ctx context.Context, wordID string, username string) (up1 *models.UserWord, err error)) *RepositoryMock {
	if mmGetUserWord.defaultExpectation != nil {
		mmGetUserWord.mock.t.Fatalf("Default expectation is already set for the Repository.GetUserWord method")
	}

	if len(mmGetUserWord.expectations) > 0 {
		mmGetUserWord.mock.t.Fatalf("Some expectations are already set for the Repository.GetUserWord method")
	}

	mmGetUserWord.mock.funcGetUserWord = f
	mmGetUserWord.mock.funcGetUserWordOrigin = minimock.CallerInfo(1)
	return mmGetUserWord.mock
}

// When sets expectation for the Repository.GetUserWord which will trigger the result defined by the following
// Then helper
func (mmGetUserWord *mRepositoryMockGetUserWord) When(ctx context.Context, wordID string, username string) *RepositoryMockGetUserWordExpectation {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("RepositoryMock.GetUserWord mock is already set by Set")
	}

	expectation := &RepositoryMockGetUserWordExpectation{
		mock:               mmGetUserWord.mock,
		params:             &RepositoryMockGetUserWordParams{ctx, wordID, username},
		expectationOrigins: RepositoryMockGetUserWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserWord.expectations = append(mmGetUserWord.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUserWord return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUserWordExpectation) Then(up1 *models.UserWord, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUserWordResults{up1, err}
	return e.mock
}

// Times sets number of times Repository.GetUserWord should be invoked
func (mmGetUserWord *mRepositoryMockGetUserWord) Times(n uint64) *mRepositoryMockGetUserWord {
	if n == 0 {
		mmGetUserWord.mock.t.Fatalf("Times of RepositoryMock.GetUserWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserWord.expectedInvocations, n)
	mmGetUserWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserWord
}

func (mmGetUserWord *mRepositoryMockGetUserWord) invocationsDone() bool {
	if len(mmGetUserWord.expectations) == 0 && mmGetUserWord.defaultExpectation == nil && mmGetUserWord.mock.funcGetUserWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserWord.mock.afterGetUserWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserWord implements mm_service.Repository
func (mmGetUserWord *RepositoryMock) GetUserWord(ctx context.Context, wordID string, username string) (up1 *models.UserWord, err error) {
	mm_atomic.AddUint64(&mmGetUserWord.beforeGetUserWordCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserWord.afterGetUserWordCounter, 1)

	mmGetUserWord.t.Helper()

	if mmGetUserWord.inspectFuncGetUserWord != nil {
		mmGetUserWord.inspectFuncGetUserWord(ctx, wordID, username)
	}

	mm_params := RepositoryMockGetUserWordParams{ctx, wordID, username}

	// Record call args
	mmGetUserWord.GetUserWordMock.mutex.Lock()
	mmGetUserWord.GetUserWordMock.callArgs = append(mmGetUserWord.GetUserWordMock.callArgs, &mm_params)
	mmGetUserWord.GetUserWordMock.mutex.Unlock()

	for _, e := range mmGetUserWord.GetUserWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserWord.GetUserWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserWord.GetUserWordMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserWord.GetUserWordMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserWord.GetUserWordMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetUserWordParams{ctx, wordID, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserWord.t.Errorf("RepositoryMock.GetUserWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wordID != nil && !minimock.Equal(*mm_want_ptrs.wordID, mm_got.wordID) {
				mmGetUserWord.t.Errorf("RepositoryMock.GetUserWord got unexpected parameter wordID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.originWordID, *mm_want_ptrs.wordID, mm_got.wordID, minimock.Diff(*mm_want_ptrs.wordID, mm_got.wordID))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserWord.t.Errorf("RepositoryMock.GetUserWord got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserWord.t.Errorf("RepositoryMock.GetUserWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserWord.GetUserWordMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserWord.t.Fatal("No results are set for the RepositoryMock.GetUserWord")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserWord.funcGetUserWord != nil {
		return mmGetUserWord.funcGetUserWord(ctx, wordID, username)
	}
	mmGetUserWord.t.Fatalf("Unexpected call to RepositoryMock.GetUserWord. %v %v %v", ctx, wordID, username)
	return
}

// GetUserWordAfterCounter returns a count of finished RepositoryMock.GetUserWord invocations
func (mmGetUserWord *RepositoryMock) GetUserWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWord.afterGetUserWordCounter)
}

// GetUserWordBeforeCounter returns a count of RepositoryMock.GetUserWord invocations
func (mmGetUserWord *RepositoryMock) GetUserWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWord.beforeGetUserWordCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUserWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserWord *mRepositoryMockGetUserWord) Calls() []*RepositoryMockGetUserWordParams {
	mmGetUserWord.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUserWordParams, len(mmGetUserWord.callArgs))
	copy(argCopy, mmGetUserWord.callArgs)

	mmGetUserWord.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserWordDone returns true if the count of the GetUserWord invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserWordDone() bool {
	if m.GetUserWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserWordMock.invocationsDone()
}

// MinimockGetUserWordInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserWordInspect() {
	for _, e := range m.GetUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUserWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserWordCounter := mm_atomic.LoadUint64(&m.afterGetUserWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserWordMock.defaultExpectation != nil && afterGetUserWordCounter < 1 {
		if m.GetUserWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetUserWord at\n%s", m.GetUserWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUserWord at\n%s with params: %#v", m.GetUserWordMock.defaultExpectation.expectationOrigins.origin, *m.GetUserWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserWord != nil && afterGetUserWordCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetUserWord at\n%s", m.funcGetUserWordOrigin)
	}

	if !m.GetUserWordMock.invocationsDone() && afterGetUserWordCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetUserWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserWordMock.expectedInvocations), m.GetUserWordMock.expectedInvocationsOrigin, afterGetUserWordCounter)
	}
}

type mRepositoryMockGetWordByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetWordByIDExpectation
	expectations       []*RepositoryMockGetWordByIDExpectation

	callArgs []*RepositoryMockGetWordByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetWordByIDExpectation specifies expectation struct of the Repository.GetWordByID
type RepositoryMockGetWordByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetWordByIDParams
	paramPtrs          *RepositoryMockGetWordByIDParamPtrs
	expectationOrigins RepositoryMockGetWordByIDExpectationOrigins
	results            *RepositoryMockGetWordByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetWordByIDParams contains parameters of the Repository.GetWordByID
type RepositoryMockGetWordByIDParams struct {
	ctx context.Context
	id  string
}

// RepositoryMockGetWordByIDParamPtrs contains pointers to parameters of the Repository.GetWordByID
type RepositoryMockGetWordByIDParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RepositoryMockGetWordByIDResults contains results of the Repository.GetWordByID
type RepositoryMockGetWordByIDResults struct {
	w1  models.Word
	err error
}

// RepositoryMockGetWordByIDOrigins contains origins of expectations of the Repository.GetWordByID
type RepositoryMockGetWordByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetWordByID *mRepositoryMockGetWordByID) Optional() *mRepositoryMockGetWordByID {
	mmGetWordByID.optional = true
	return mmGetWordByID
}

// Expect sets up expected params for Repository.GetWordByID
func (mmGetWordByID *mRepositoryMockGetWordByID) Expect(ctx context.Context, id string) *mRepositoryMockGetWordByID {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("RepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &RepositoryMockGetWordByIDExpectation{}
	}

	if mmGetWordByID.defaultExpectation.paramPtrs != nil {
		mmGetWordByID.mock.t.Fatalf("RepositoryMock.GetWordByID mock is already set by ExpectParams functions")
	}

	mmGetWordByID.defaultExpectation.params = &RepositoryMockGetWordByIDParams{ctx, id}
	mmGetWordByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetWordByID.expectations {
		if minimock.Equal(e.params, mmGetWordByID.defaultExpectation.params) {
			mmGetWordByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWordByID.defaultExpectation.params)
		}
	}

	return mmGetWordByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetWordByID
func (mmGetWordByID *mRepositoryMockGetWordByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetWordByID {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("RepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &RepositoryMockGetWordByIDExpectation{}
	}

	if mmGetWordByID.defaultExpectation.params != nil {
		mmGetWordByID.mock.t.Fatalf("RepositoryMock.GetWordByID mock is already set by Expect")
	}

	if mmGetWordByID.defaultExpectation.paramPtrs == nil {
		mmGetWordByID.defaultExpectation.paramPtrs = &RepositoryMockGetWordByIDParamPtrs{}
	}
	mmGetWordByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetWordByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetWordByID
}

// ExpectIdParam2 sets up expected param id for Repository.GetWordByID
func (mmGetWordByID *mRepositoryMockGetWordByID) ExpectIdParam2(id string) *mRepositoryMockGetWordByID {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("RepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &RepositoryMockGetWordByIDExpectation{}
	}

	if mmGetWordByID.defaultExpectation.params != nil {
		mmGetWordByID.mock.t.Fatalf("RepositoryMock.GetWordByID mock is already set by Expect")
	}

	if mmGetWordByID.defaultExpectation.paramPtrs == nil {
		mmGetWordByID.defaultExpectation.paramPtrs = &RepositoryMockGetWordByIDParamPtrs{}
	}
	mmGetWordByID.defaultExpectation.paramPtrs.id = &id
	mmGetWordByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetWordByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetWordByID
func (mmGetWordByID *mRepositoryMockGetWordByID) Inspect(f func(ctx context.Context, id string)) *mRepositoryMockGetWordByID {
	if mmGetWordByID.mock.inspectFuncGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetWordByID")
	}

	mmGetWordByID.mock.inspectFuncGetWordByID = f

	return mmGetWordByID
}

// Return sets up results that will be returned by Repository.GetWordByID
func (mmGetWordByID *mRepositoryMockGetWordByID) Return(w1 models.Word, err error) *RepositoryMock {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("RepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &RepositoryMockGetWordByIDExpectation{mock: mmGetWordByID.mock}
	}
	mmGetWordByID.defaultExpectation.results = &RepositoryMockGetWordByIDResults{w1, err}
	mmGetWordByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetWordByID.mock
}

// Set uses given function f to mock the Repository.GetWordByID method
func (mmGetWordByID *mRepositoryMockGetWordByID) Set(f func(ctx context.Context, id string) (w1 models.Word, err error)) *RepositoryMock {
	if mmGetWordByID.defaultExpectation != nil {
		mmGetWordByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetWordByID method")
	}

	if len(mmGetWordByID.expectations) > 0 {
		mmGetWordByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetWordByID method")
	}

	mmGetWordByID.mock.funcGetWordByID = f
	mmGetWordByID.mock.funcGetWordByIDOrigin = minimock.CallerInfo(1)
	return mmGetWordByID.mock
}

// When sets expectation for the Repository.GetWordByID which will trigger the result defined by the following
// Then helper
func (mmGetWordByID *mRepositoryMockGetWordByID) When(ctx context.Context, id string) *RepositoryMockGetWordByIDExpectation {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("RepositoryMock.GetWordByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetWordByIDExpectation{
		mock:               mmGetWordByID.mock,
		params:             &RepositoryMockGetWordByIDParams{ctx, id},
		expectationOrigins: RepositoryMockGetWordByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetWordByID.expectations = append(mmGetWordByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetWordByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetWordByIDExpectation) Then(w1 models.Word, err error) *RepositoryMock {
	e.results = &RepositoryMockGetWordByIDResults{w1, err}
	return e.mock
}

// Times sets number of times Repository.GetWordByID should be invoked
func (mmGetWordByID *mRepositoryMockGetWordByID) Times(n uint64) *mRepositoryMockGetWordByID {
	if n == 0 {
		mmGetWordByID.mock.t.Fatalf("Times of RepositoryMock.GetWordByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetWordByID.expectedInvocations, n)
	mmGetWordByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetWordByID
}

func (mmGetWordByID *mRepositoryMockGetWordByID) invocationsDone() bool {
	if len(mmGetWordByID.expectations) == 0 && mmGetWordByID.defaultExpectation == nil && mmGetWordByID.mock.funcGetWordByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetWordByID.mock.afterGetWordByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetWordByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetWordByID implements mm_service.Repository
func (mmGetWordByID *RepositoryMock) GetWordByID(ctx context.Context, id string) (w1 models.Word, err error) {
	mm_atomic.AddUint64(&mmGetWordByID.beforeGetWordByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWordByID.afterGetWordByIDCounter, 1)

	mmGetWordByID.t.Helper()

	if mmGetWordByID.inspectFuncGetWordByID != nil {
		mmGetWordByID.inspectFuncGetWordByID(ctx, id)
	}

	mm_params := RepositoryMockGetWordByIDParams{ctx, id}

	// Record call args
	mmGetWordByID.GetWordByIDMock.mutex.Lock()
	mmGetWordByID.GetWordByIDMock.callArgs = append(mmGetWordByID.GetWordByIDMock.callArgs, &mm_params)
	mmGetWordByID.GetWordByIDMock.mutex.Unlock()

	for _, e := range mmGetWordByID.GetWordByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1, e.results.err
		}
	}

	if mmGetWordByID.GetWordByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWordByID.GetWordByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWordByID.GetWordByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetWordByID.GetWordByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetWordByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetWordByID.t.Errorf("RepositoryMock.GetWordByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByID.GetWordByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetWordByID.t.Errorf("RepositoryMock.GetWordByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByID.GetWordByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWordByID.t.Errorf("RepositoryMock.GetWordByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetWordByID.GetWordByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWordByID.GetWordByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWordByID.t.Fatal("No results are set for the RepositoryMock.GetWordByID")
		}
		return (*mm_results).w1, (*mm_results).err
	}
	if mmGetWordByID.funcGetWordByID != nil {
		return mmGetWordByID.funcGetWordByID(ctx, id)
	}
	mmGetWordByID.t.Fatalf("Unexpected call to RepositoryMock.GetWordByID. %v %v", ctx, id)
	return
}

// GetWordByIDAfterCounter returns a count of finished RepositoryMock.GetWordByID invocations
func (mmGetWordByID *RepositoryMock) GetWordByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByID.afterGetWordByIDCounter)
}

// GetWordByIDBeforeCounter returns a count of RepositoryMock.GetWordByID invocations
func (mmGetWordByID *RepositoryMock) GetWordByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByID.beforeGetWordByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetWordByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWordByID *mRepositoryMockGetWordByID) Calls() []*RepositoryMockGetWordByIDParams {
	mmGetWordByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetWordByIDParams, len(mmGetWordByID.callArgs))
	copy(argCopy, mmGetWordByID.callArgs)

	mmGetWordByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetWordByIDDone returns true if the count of the GetWordByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetWordByIDDone() bool {
	if m.GetWordByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetWordByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetWordByIDMock.invocationsDone()
}

// MinimockGetWordByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetWordByIDInspect() {
	for _, e := range m.GetWordByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetWordByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetWordByIDCounter := mm_atomic.LoadUint64(&m.afterGetWordByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetWordByIDMock.defaultExpectation != nil && afterGetWordByIDCounter < 1 {
		if m.GetWordByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetWordByID at\n%s", m.GetWordByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetWordByID at\n%s with params: %#v", m.GetWordByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetWordByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWordByID != nil && afterGetWordByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetWordByID at\n%s", m.funcGetWordByIDOrigin)
	}

	if !m.GetWordByIDMock.invocationsDone() && afterGetWordByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetWordByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetWordByIDMock.expectedInvocations), m.GetWordByIDMock.expectedInvocationsOrigin, afterGetWordByIDCounter)
	}
}

type mRepositoryMockGetWordByName struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetWordByNameExpectation
	expectations       []*RepositoryMockGetWordByNameExpectation

	callArgs []*RepositoryMockGetWordByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetWordByNameExpectation specifies expectation struct of the Repository.GetWordByName
type RepositoryMockGetWordByNameExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetWordByNameParams
	paramPtrs          *RepositoryMockGetWordByNameParamPtrs
	expectationOrigins RepositoryMockGetWordByNameExpectationOrigins
	results            *RepositoryMockGetWordByNameResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetWordByNameParams contains parameters of the Repository.GetWordByName
type RepositoryMockGetWordByNameParams struct {
	ctx      context.Context
	wordName string
}

// RepositoryMockGetWordByNameParamPtrs contains pointers to parameters of the Repository.GetWordByName
type RepositoryMockGetWordByNameParamPtrs struct {
	ctx      *context.Context
	wordName *string
}

// RepositoryMockGetWordByNameResults contains results of the Repository.GetWordByName
type RepositoryMockGetWordByNameResults struct {
	w1  models.Word
	err error
}

// RepositoryMockGetWordByNameOrigins contains origins of expectations of the Repository.GetWordByName
type RepositoryMockGetWordByNameExpectationOrigins struct {
	origin         string
	originCtx      string
	originWordName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetWordByName *mRepositoryMockGetWordByName) Optional() *mRepositoryMockGetWordByName {
	mmGetWordByName.optional = true
	return mmGetWordByName
}

// Expect sets up expected params for Repository.GetWordByName
func (mmGetWordByName *mRepositoryMockGetWordByName) Expect(ctx context.Context, wordName string) *mRepositoryMockGetWordByName {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("RepositoryMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &RepositoryMockGetWordByNameExpectation{}
	}

	if mmGetWordByName.defaultExpectation.paramPtrs != nil {
		mmGetWordByName.mock.t.Fatalf("RepositoryMock.GetWordByName mock is already set by ExpectParams functions")
	}

	mmGetWordByName.defaultExpectation.params = &RepositoryMockGetWordByNameParams{ctx, wordName}
	mmGetWordByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetWordByName.expectations {
		if minimock.Equal(e.params, mmGetWordByName.defaultExpectation.params) {
			mmGetWordByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWordByName.defaultExpectation.params)
		}
	}

	return mmGetWordByName
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetWordByName
func (mmGetWordByName *mRepositoryMockGetWordByName) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetWordByName {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("RepositoryMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &RepositoryMockGetWordByNameExpectation{}
	}

	if mmGetWordByName.defaultExpectation.params != nil {
		mmGetWordByName.mock.t.Fatalf("RepositoryMock.GetWordByName mock is already set by Expect")
	}

	if mmGetWordByName.defaultExpectation.paramPtrs == nil {
		mmGetWordByName.defaultExpectation.paramPtrs = &RepositoryMockGetWordByNameParamPtrs{}
	}
	mmGetWordByName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetWordByName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetWordByName
}

// ExpectWordNameParam2 sets up expected param wordName for Repository.GetWordByName
func (mmGetWordByName *mRepositoryMockGetWordByName) ExpectWordNameParam2(wordName string) *mRepositoryMockGetWordByName {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("RepositoryMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &RepositoryMockGetWordByNameExpectation{}
	}

	if mmGetWordByName.defaultExpectation.params != nil {
		mmGetWordByName.mock.t.Fatalf("RepositoryMock.GetWordByName mock is already set by Expect")
	}

	if mmGetWordByName.defaultExpectation.paramPtrs == nil {
		mmGetWordByName.defaultExpectation.paramPtrs = &RepositoryMockGetWordByNameParamPtrs{}
	}
	mmGetWordByName.defaultExpectation.paramPtrs.wordName = &wordName
	mmGetWordByName.defaultExpectation.expectationOrigins.originWordName = minimock.CallerInfo(1)

	return mmGetWordByName
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetWordByName
func (mmGetWordByName *mRepositoryMockGetWordByName) Inspect(f func(ctx context.Context, wordName string)) *mRepositoryMockGetWordByName {
	if mmGetWordByName.mock.inspectFuncGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetWordByName")
	}

	mmGetWordByName.mock.inspectFuncGetWordByName = f

	return mmGetWordByName
}

// Return sets up results that will be returned by Repository.GetWordByName
func (mmGetWordByName *mRepositoryMockGetWordByName) Return(w1 models.Word, err error) *RepositoryMock {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("RepositoryMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &RepositoryMockGetWordByNameExpectation{mock: mmGetWordByName.mock}
	}
	mmGetWordByName.defaultExpectation.results = &RepositoryMockGetWordByNameResults{w1, err}
	mmGetWordByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetWordByName.mock
}

// Set uses given function f to mock the Repository.GetWordByName method
func (mmGetWordByName *mRepositoryMockGetWordByName) Set(f func(ctx context.Context, wordName string) (w1 models.Word, err error)) *RepositoryMock {
	if mmGetWordByName.defaultExpectation != nil {
		mmGetWordByName.mock.t.Fatalf("Default expectation is already set for the Repository.GetWordByName method")
	}

	if len(mmGetWordByName.expectations) > 0 {
		mmGetWordByName.mock.t.Fatalf("Some expectations are already set for the Repository.GetWordByName method")
	}

	mmGetWordByName.mock.funcGetWordByName = f
	mmGetWordByName.mock.funcGetWordByNameOrigin = minimock.CallerInfo(1)
	return mmGetWordByName.mock
}

// When sets expectation for the Repository.GetWordByName which will trigger the result defined by the following
// Then helper
func (mmGetWordByName *mRepositoryMockGetWordByName) When(ctx context.Context, wordName string) *RepositoryMockGetWordByNameExpectation {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("RepositoryMock.GetWordByName mock is already set by Set")
	}

	expectation := &RepositoryMockGetWordByNameExpectation{
		mock:               mmGetWordByName.mock,
		params:             &RepositoryMockGetWordByNameParams{ctx, wordName},
		expectationOrigins: RepositoryMockGetWordByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetWordByName.expectations = append(mmGetWordByName.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetWordByName return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetWordByNameExpectation) Then(w1 models.Word, err error) *RepositoryMock {
	e.results = &RepositoryMockGetWordByNameResults{w1, err}
	return e.mock
}

// Times sets number of times Repository.GetWordByName should be invoked
func (mmGetWordByName *mRepositoryMockGetWordByName) Times(n uint64) *mRepositoryMockGetWordByName {
	if n == 0 {
		mmGetWordByName.mock.t.Fatalf("Times of RepositoryMock.GetWordByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetWordByName.expectedInvocations, n)
	mmGetWordByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetWordByName
}

func (mmGetWordByName *mRepositoryMockGetWordByName) invocationsDone() bool {
	if len(mmGetWordByName.expectations) == 0 && mmGetWordByName.defaultExpectation == nil && mmGetWordByName.mock.funcGetWordByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetWordByName.mock.afterGetWordByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetWordByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetWordByName implements mm_service.Repository
func (mmGetWordByName *RepositoryMock) GetWordByName(ctx context.Context, wordName string) (w1 models.Word, err error) {
	mm_atomic.AddUint64(&mmGetWordByName.beforeGetWordByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWordByName.afterGetWordByNameCounter, 1)

	mmGetWordByName.t.Helper()

	if mmGetWordByName.inspectFuncGetWordByName != nil {
		mmGetWordByName.inspectFuncGetWordByName(ctx, wordName)
	}

	mm_params := RepositoryMockGetWordByNameParams{ctx, wordName}

	// Record call args
	mmGetWordByName.GetWordByNameMock.mutex.Lock()
	mmGetWordByName.GetWordByNameMock.callArgs = append(mmGetWordByName.GetWordByNameMock.callArgs, &mm_params)
	mmGetWordByName.GetWordByNameMock.mutex.Unlock()

	for _, e := range mmGetWordByName.GetWordByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1, e.results.err
		}
	}

	if mmGetWordByName.GetWordByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWordByName.GetWordByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWordByName.GetWordByNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetWordByName.GetWordByNameMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetWordByNameParams{ctx, wordName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetWordByName.t.Errorf("RepositoryMock.GetWordByName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByName.GetWordByNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wordName != nil && !minimock.Equal(*mm_want_ptrs.wordName, mm_got.wordName) {
				mmGetWordByName.t.Errorf("RepositoryMock.GetWordByName got unexpected parameter wordName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByName.GetWordByNameMock.defaultExpectation.expectationOrigins.originWordName, *mm_want_ptrs.wordName, mm_got.wordName, minimock.Diff(*mm_want_ptrs.wordName, mm_got.wordName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWordByName.t.Errorf("RepositoryMock.GetWordByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetWordByName.GetWordByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWordByName.GetWordByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWordByName.t.Fatal("No results are set for the RepositoryMock.GetWordByName")
		}
		return (*mm_results).w1, (*mm_results).err
	}
	if mmGetWordByName.funcGetWordByName != nil {
		return mmGetWordByName.funcGetWordByName(ctx, wordName)
	}
	mmGetWordByName.t.Fatalf("Unexpected call to RepositoryMock.GetWordByName. %v %v", ctx, wordName)
	return
}

// GetWordByNameAfterCounter returns a count of finished RepositoryMock.GetWordByName invocations
func (mmGetWordByName *RepositoryMock) GetWordByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByName.afterGetWordByNameCounter)
}

// GetWordByNameBeforeCounter returns a count of RepositoryMock.GetWordByName invocations
func (mmGetWordByName *RepositoryMock) GetWordByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByName.beforeGetWordByNameCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetWordByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWordByName *mRepositoryMockGetWordByName) Calls() []*RepositoryMockGetWordByNameParams {
	mmGetWordByName.mutex.RLock()

	argCopy := make([]*RepositoryMockGetWordByNameParams, len(mmGetWordByName.callArgs))
	copy(argCopy, mmGetWordByName.callArgs)

	mmGetWordByName.mutex.RUnlock()

	return argCopy
}

// MinimockGetWordByNameDone returns true if the count of the GetWordByName invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetWordByNameDone() bool {
	if m.GetWordByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetWordByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetWordByNameMock.invocationsDone()
}

// MinimockGetWordByNameInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetWordByNameInspect() {
	for _, e := range m.GetWordByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetWordByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetWordByNameCounter := mm_atomic.LoadUint64(&m.afterGetWordByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetWordByNameMock.defaultExpectation != nil && afterGetWordByNameCounter < 1 {
		if m.GetWordByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetWordByName at\n%s", m.GetWordByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetWordByName at\n%s with params: %#v", m.GetWordByNameMock.defaultExpectation.expectationOrigins.origin, *m.GetWordByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWordByName != nil && afterGetWordByNameCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetWordByName at\n%s", m.funcGetWordByNameOrigin)
	}

	if !m.GetWordByNameMock.invocationsDone() && afterGetWordByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetWordByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetWordByNameMock.expectedInvocations), m.GetWordByNameMock.expectedInvocationsOrigin, afterGetWordByNameCounter)
	}
}

type mRepositoryMockUpdateUserWord struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateUserWordExpectation
	expectations       []*RepositoryMockUpdateUserWordExpectation

	callArgs []*RepositoryMockUpdateUserWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateUserWordExpectation specifies expectation struct of the Repository.UpdateUserWord
type RepositoryMockUpdateUserWordExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateUserWordParams
	paramPtrs          *RepositoryMockUpdateUserWordParamPtrs
	expectationOrigins RepositoryMockUpdateUserWordExpectationOrigins
	results            *RepositoryMockUpdateUserWordResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateUserWordParams contains parameters of the Repository.UpdateUserWord
type RepositoryMockUpdateUserWordParams struct {
	ctx      context.Context
	userWord *models.UserWord
}

// RepositoryMockUpdateUserWordParamPtrs contains pointers to parameters of the Repository.UpdateUserWord
type RepositoryMockUpdateUserWordParamPtrs struct {
	ctx      *context.Context
	userWord **models.UserWord
}

// RepositoryMockUpdateUserWordResults contains results of the Repository.UpdateUserWord
type RepositoryMockUpdateUserWordResults struct {
	err error
}

// RepositoryMockUpdateUserWordOrigins contains origins of expectations of the Repository.UpdateUserWord
type RepositoryMockUpdateUserWordExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserWord string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) Optional() *mRepositoryMockUpdateUserWord {
	mmUpdateUserWord.optional = true
	return mmUpdateUserWord
}

// Expect sets up expected params for Repository.UpdateUserWord
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) Expect(ctx context.Context, userWord *models.UserWord) *mRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("RepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &RepositoryMockUpdateUserWordExpectation{}
	}

	if mmUpdateUserWord.defaultExpectation.paramPtrs != nil {
		mmUpdateUserWord.mock.t.Fatalf("RepositoryMock.UpdateUserWord mock is already set by ExpectParams functions")
	}

	mmUpdateUserWord.defaultExpectation.params = &RepositoryMockUpdateUserWordParams{ctx, userWord}
	mmUpdateUserWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUserWord.expectations {
		if minimock.Equal(e.params, mmUpdateUserWord.defaultExpectation.params) {
			mmUpdateUserWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUserWord.defaultExpectation.params)
		}
	}

	return mmUpdateUserWord
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateUserWord
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("RepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &RepositoryMockUpdateUserWordExpectation{}
	}

	if mmUpdateUserWord.defaultExpectation.params != nil {
		mmUpdateUserWord.mock.t.Fatalf("RepositoryMock.UpdateUserWord mock is already set by Expect")
	}

	if mmUpdateUserWord.defaultExpectation.paramPtrs == nil {
		mmUpdateUserWord.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserWordParamPtrs{}
	}
	mmUpdateUserWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUserWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUserWord
}

// ExpectUserWordParam2 sets up expected param userWord for Repository.UpdateUserWord
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) ExpectUserWordParam2(userWord *models.UserWord) *mRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("RepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &RepositoryMockUpdateUserWordExpectation{}
	}

	if mmUpdateUserWord.defaultExpectation.params != nil {
		mmUpdateUserWord.mock.t.Fatalf("RepositoryMock.UpdateUserWord mock is already set by Expect")
	}

	if mmUpdateUserWord.defaultExpectation.paramPtrs == nil {
		mmUpdateUserWord.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserWordParamPtrs{}
	}
	mmUpdateUserWord.defaultExpectation.paramPtrs.userWord = &userWord
	mmUpdateUserWord.defaultExpectation.expectationOrigins.originUserWord = minimock.CallerInfo(1)

	return mmUpdateUserWord
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateUserWord
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) Inspect(f func(ctx context.Context, userWord *models.UserWord)) *mRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.inspectFuncUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateUserWord")
	}

	mmUpdateUserWord.mock.inspectFuncUpdateUserWord = f

	return mmUpdateUserWord
}

// Return sets up results that will be returned by Repository.UpdateUserWord
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) Return(err error) *RepositoryMock {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("RepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &RepositoryMockUpdateUserWordExpectation{mock: mmUpdateUserWord.mock}
	}
	mmUpdateUserWord.defaultExpectation.results = &RepositoryMockUpdateUserWordResults{err}
	mmUpdateUserWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUserWord.mock
}

// Set uses given function f to mock the Repository.UpdateUserWord method
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) Set(f func(ctx context.Context, userWord *models.UserWord) (err error)) *RepositoryMock {
	if mmUpdateUserWord.defaultExpectation != nil {
		mmUpdateUserWord.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateUserWord method")
	}

	if len(mmUpdateUserWord.expectations) > 0 {
		mmUpdateUserWord.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateUserWord method")
	}

	mmUpdateUserWord.mock.funcUpdateUserWord = f
	mmUpdateUserWord.mock.funcUpdateUserWordOrigin = minimock.CallerInfo(1)
	return mmUpdateUserWord.mock
}

// When sets expectation for the Repository.UpdateUserWord which will trigger the result defined by the following
// Then helper
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) When(ctx context.Context, userWord *models.UserWord) *RepositoryMockUpdateUserWordExpectation {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("RepositoryMock.UpdateUserWord mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateUserWordExpectation{
		mock:               mmUpdateUserWord.mock,
		params:             &RepositoryMockUpdateUserWordParams{ctx, userWord},
		expectationOrigins: RepositoryMockUpdateUserWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUserWord.expectations = append(mmUpdateUserWord.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateUserWord return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateUserWordExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateUserWordResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateUserWord should be invoked
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) Times(n uint64) *mRepositoryMockUpdateUserWord {
	if n == 0 {
		mmUpdateUserWord.mock.t.Fatalf("Times of RepositoryMock.UpdateUserWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUserWord.expectedInvocations, n)
	mmUpdateUserWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserWord
}

func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) invocationsDone() bool {
	if len(mmUpdateUserWord.expectations) == 0 && mmUpdateUserWord.defaultExpectation == nil && mmUpdateUserWord.mock.funcUpdateUserWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUserWord.mock.afterUpdateUserWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUserWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUserWord implements mm_service.Repository
func (mmUpdateUserWord *RepositoryMock) UpdateUserWord(ctx context.Context, userWord *models.UserWord) (err error) {
	mm_atomic.AddUint64(&mmUpdateUserWord.beforeUpdateUserWordCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUserWord.afterUpdateUserWordCounter, 1)

	mmUpdateUserWord.t.Helper()

	if mmUpdateUserWord.inspectFuncUpdateUserWord != nil {
		mmUpdateUserWord.inspectFuncUpdateUserWord(ctx, userWord)
	}

	mm_params := RepositoryMockUpdateUserWordParams{ctx, userWord}

	// Record call args
	mmUpdateUserWord.UpdateUserWordMock.mutex.Lock()
	mmUpdateUserWord.UpdateUserWordMock.callArgs = append(mmUpdateUserWord.UpdateUserWordMock.callArgs, &mm_params)
	mmUpdateUserWord.UpdateUserWordMock.mutex.Unlock()

	for _, e := range mmUpdateUserWord.UpdateUserWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUserWord.UpdateUserWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateUserWordParams{ctx, userWord}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUserWord.t.Errorf("RepositoryMock.UpdateUserWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userWord != nil && !minimock.Equal(*mm_want_ptrs.userWord, mm_got.userWord) {
				mmUpdateUserWord.t.Errorf("RepositoryMock.UpdateUserWord got unexpected parameter userWord, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.expectationOrigins.originUserWord, *mm_want_ptrs.userWord, mm_got.userWord, minimock.Diff(*mm_want_ptrs.userWord, mm_got.userWord))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUserWord.t.Errorf("RepositoryMock.UpdateUserWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUserWord.t.Fatal("No results are set for the RepositoryMock.UpdateUserWord")
		}
		return (*mm_results).err
	}
	if mmUpdateUserWord.funcUpdateUserWord != nil {
		return mmUpdateUserWord.funcUpdateUserWord(ctx, userWord)
	}
	mmUpdateUserWord.t.Fatalf("Unexpected call to RepositoryMock.UpdateUserWord. %v %v", ctx, userWord)
	return
}

// UpdateUserWordAfterCounter returns a count of finished RepositoryMock.UpdateUserWord invocations
func (mmUpdateUserWord *RepositoryMock) UpdateUserWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserWord.afterUpdateUserWordCounter)
}

// UpdateUserWordBeforeCounter returns a count of RepositoryMock.UpdateUserWord invocations
func (mmUpdateUserWord *RepositoryMock) UpdateUserWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserWord.beforeUpdateUserWordCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateUserWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUserWord *mRepositoryMockUpdateUserWord) Calls() []*RepositoryMockUpdateUserWordParams {
	mmUpdateUserWord.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateUserWordParams, len(mmUpdateUserWord.callArgs))
	copy(argCopy, mmUpdateUserWord.callArgs)

	mmUpdateUserWord.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserWordDone returns true if the count of the UpdateUserWord invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateUserWordDone() bool {
	if m.UpdateUserWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserWordMock.invocationsDone()
}

// MinimockUpdateUserWordInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateUserWordInspect() {
	for _, e := range m.UpdateUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUserWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserWordCounter := mm_atomic.LoadUint64(&m.afterUpdateUserWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserWordMock.defaultExpectation != nil && afterUpdateUserWordCounter < 1 {
		if m.UpdateUserWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUserWord at\n%s", m.UpdateUserWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUserWord at\n%s with params: %#v", m.UpdateUserWordMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserWord != nil && afterUpdateUserWordCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateUserWord at\n%s", m.funcUpdateUserWordOrigin)
	}

	if !m.UpdateUserWordMock.invocationsDone() && afterUpdateUserWordCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateUserWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserWordMock.expectedInvocations), m.UpdateUserWordMock.expectedInvocationsOrigin, afterUpdateUserWordCounter)
	}
}

type mRepositoryMockWordList struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockWordListExpectation
	expectations       []*RepositoryMockWordListExpectation

	callArgs []*RepositoryMockWordListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockWordListExpectation specifies expectation struct of the Repository.WordList
type RepositoryMockWordListExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockWordListParams
	paramPtrs          *RepositoryMockWordListParamPtrs
	expectationOrigins RepositoryMockWordListExpectationOrigins
	results            *RepositoryMockWordListResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockWordListParams contains parameters of the Repository.WordList
type RepositoryMockWordListParams struct {
	ctx context.Context
	qp1 *mm_service.QueryParams
}

// RepositoryMockWordListParamPtrs contains pointers to parameters of the Repository.WordList
type RepositoryMockWordListParamPtrs struct {
	ctx *context.Context
	qp1 **mm_service.QueryParams
}

// RepositoryMockWordListResults contains results of the Repository.WordList
type RepositoryMockWordListResults struct {
	wa1 []models.Word
	err error
}

// RepositoryMockWordListOrigins contains origins of expectations of the Repository.WordList
type RepositoryMockWordListExpectationOrigins struct {
	origin    string
	originCtx string
	originQp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWordList *mRepositoryMockWordList) Optional() *mRepositoryMockWordList {
	mmWordList.optional = true
	return mmWordList
}

// Expect sets up expected params for Repository.WordList
func (mmWordList *mRepositoryMockWordList) Expect(ctx context.Context, qp1 *mm_service.QueryParams) *mRepositoryMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("RepositoryMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &RepositoryMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.paramPtrs != nil {
		mmWordList.mock.t.Fatalf("RepositoryMock.WordList mock is already set by ExpectParams functions")
	}

	mmWordList.defaultExpectation.params = &RepositoryMockWordListParams{ctx, qp1}
	mmWordList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWordList.expectations {
		if minimock.Equal(e.params, mmWordList.defaultExpectation.params) {
			mmWordList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWordList.defaultExpectation.params)
		}
	}

	return mmWordList
}

// ExpectCtxParam1 sets up expected param ctx for Repository.WordList
func (mmWordList *mRepositoryMockWordList) ExpectCtxParam1(ctx context.Context) *mRepositoryMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("RepositoryMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &RepositoryMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.params != nil {
		mmWordList.mock.t.Fatalf("RepositoryMock.WordList mock is already set by Expect")
	}

	if mmWordList.defaultExpectation.paramPtrs == nil {
		mmWordList.defaultExpectation.paramPtrs = &RepositoryMockWordListParamPtrs{}
	}
	mmWordList.defaultExpectation.paramPtrs.ctx = &ctx
	mmWordList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWordList
}

// ExpectQp1Param2 sets up expected param qp1 for Repository.WordList
func (mmWordList *mRepositoryMockWordList) ExpectQp1Param2(qp1 *mm_service.QueryParams) *mRepositoryMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("RepositoryMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &RepositoryMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.params != nil {
		mmWordList.mock.t.Fatalf("RepositoryMock.WordList mock is already set by Expect")
	}

	if mmWordList.defaultExpectation.paramPtrs == nil {
		mmWordList.defaultExpectation.paramPtrs = &RepositoryMockWordListParamPtrs{}
	}
	mmWordList.defaultExpectation.paramPtrs.qp1 = &qp1
	mmWordList.defaultExpectation.expectationOrigins.originQp1 = minimock.CallerInfo(1)

	return mmWordList
}

// Inspect accepts an inspector function that has same arguments as the Repository.WordList
func (mmWordList *mRepositoryMockWordList) Inspect(f func(ctx context.Context, qp1 *mm_service.QueryParams)) *mRepositoryMockWordList {
	if mmWordList.mock.inspectFuncWordList != nil {
		mmWordList.mock.t.Fatalf("Inspect function is already set for RepositoryMock.WordList")
	}

	mmWordList.mock.inspectFuncWordList = f

	return mmWordList
}

// Return sets up results that will be returned by Repository.WordList
func (mmWordList *mRepositoryMockWordList) Return(wa1 []models.Word, err error) *RepositoryMock {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("RepositoryMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &RepositoryMockWordListExpectation{mock: mmWordList.mock}
	}
	mmWordList.defaultExpectation.results = &RepositoryMockWordListResults{wa1, err}
	mmWordList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWordList.mock
}

// Set uses given function f to mock the Repository.WordList method
func (mmWordList *mRepositoryMockWordList) Set(f func(ctx context.Context, qp1 *mm_service.QueryParams) (wa1 []models.Word, err error)) *RepositoryMock {
	if mmWordList.defaultExpectation != nil {
		mmWordList.mock.t.Fatalf("Default expectation is already set for the Repository.WordList method")
	}

	if len(mmWordList.expectations) > 0 {
		mmWordList.mock.t.Fatalf("Some expectations are already set for the Repository.WordList method")
	}

	mmWordList.mock.funcWordList = f
	mmWordList.mock.funcWordListOrigin = minimock.CallerInfo(1)
	return mmWordList.mock
}

// When sets expectation for the Repository.WordList which will trigger the result defined by the following
// Then helper
func (mmWordList *mRepositoryMockWordList) When(ctx context.Context, qp1 *mm_service.QueryParams) *RepositoryMockWordListExpectation {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("RepositoryMock.WordList mock is already set by Set")
	}

	expectation := &RepositoryMockWordListExpectation{
		mock:               mmWordList.mock,
		params:             &RepositoryMockWordListParams{ctx, qp1},
		expectationOrigins: RepositoryMockWordListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWordList.expectations = append(mmWordList.expectations, expectation)
	return expectation
}

// Then sets up Repository.WordList return parameters for the expectation previously defined by the When method
func (e *RepositoryMockWordListExpectation) Then(wa1 []models.Word, err error) *RepositoryMock {
	e.results = &RepositoryMockWordListResults{wa1, err}
	return e.mock
}

// Times sets number of times Repository.WordList should be invoked
func (mmWordList *mRepositoryMockWordList) Times(n uint64) *mRepositoryMockWordList {
	if n == 0 {
		mmWordList.mock.t.Fatalf("Times of RepositoryMock.WordList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWordList.expectedInvocations, n)
	mmWordList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWordList
}

func (mmWordList *mRepositoryMockWordList) invocationsDone() bool {
	if len(mmWordList.expectations) == 0 && mmWordList.defaultExpectation == nil && mmWordList.mock.funcWordList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWordList.mock.afterWordListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWordList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WordList implements mm_service.Repository
func (mmWordList *RepositoryMock) WordList(ctx context.Context, qp1 *mm_service.QueryParams) (wa1 []models.Word, err error) {
	mm_atomic.AddUint64(&mmWordList.beforeWordListCounter, 1)
	defer mm_atomic.AddUint64(&mmWordList.afterWordListCounter, 1)

	mmWordList.t.Helper()

	if mmWordList.inspectFuncWordList != nil {
		mmWordList.inspectFuncWordList(ctx, qp1)
	}

	mm_params := RepositoryMockWordListParams{ctx, qp1}

	// Record call args
	mmWordList.WordListMock.mutex.Lock()
	mmWordList.WordListMock.callArgs = append(mmWordList.WordListMock.callArgs, &mm_params)
	mmWordList.WordListMock.mutex.Unlock()

	for _, e := range mmWordList.WordListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmWordList.WordListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWordList.WordListMock.defaultExpectation.Counter, 1)
		mm_want := mmWordList.WordListMock.defaultExpectation.params
		mm_want_ptrs := mmWordList.WordListMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockWordListParams{ctx, qp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWordList.t.Errorf("RepositoryMock.WordList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWordList.WordListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.qp1 != nil && !minimock.Equal(*mm_want_ptrs.qp1, mm_got.qp1) {
				mmWordList.t.Errorf("RepositoryMock.WordList got unexpected parameter qp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWordList.WordListMock.defaultExpectation.expectationOrigins.originQp1, *mm_want_ptrs.qp1, mm_got.qp1, minimock.Diff(*mm_want_ptrs.qp1, mm_got.qp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWordList.t.Errorf("RepositoryMock.WordList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWordList.WordListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWordList.WordListMock.defaultExpectation.results
		if mm_results == nil {
			mmWordList.t.Fatal("No results are set for the RepositoryMock.WordList")
		}
		return (*mm_results).wa1, (*mm_results).err
	}
	if mmWordList.funcWordList != nil {
		return mmWordList.funcWordList(ctx, qp1)
	}
	mmWordList.t.Fatalf("Unexpected call to RepositoryMock.WordList. %v %v", ctx, qp1)
	return
}

// WordListAfterCounter returns a count of finished RepositoryMock.WordList invocations
func (mmWordList *RepositoryMock) WordListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWordList.afterWordListCounter)
}

// WordListBeforeCounter returns a count of RepositoryMock.WordList invocations
func (mmWordList *RepositoryMock) WordListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWordList.beforeWordListCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.WordList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWordList *mRepositoryMockWordList) Calls() []*RepositoryMockWordListParams {
	mmWordList.mutex.RLock()

	argCopy := make([]*RepositoryMockWordListParams, len(mmWordList.callArgs))
	copy(argCopy, mmWordList.callArgs)

	mmWordList.mutex.RUnlock()

	return argCopy
}

// MinimockWordListDone returns true if the count of the WordList invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockWordListDone() bool {
	if m.WordListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WordListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WordListMock.invocationsDone()
}

// MinimockWordListInspect logs each unmet expectation
func (m *RepositoryMock) MinimockWordListInspect() {
	for _, e := range m.WordListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.WordList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWordListCounter := mm_atomic.LoadUint64(&m.afterWordListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WordListMock.defaultExpectation != nil && afterWordListCounter < 1 {
		if m.WordListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.WordList at\n%s", m.WordListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.WordList at\n%s with params: %#v", m.WordListMock.defaultExpectation.expectationOrigins.origin, *m.WordListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWordList != nil && afterWordListCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.WordList at\n%s", m.funcWordListOrigin)
	}

	if !m.WordListMock.invocationsDone() && afterWordListCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.WordList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WordListMock.expectedInvocations), m.WordListMock.expectedInvocationsOrigin, afterWordListCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddWordInspect()

			m.MinimockAddWordToJarInspect()

			m.MinimockGetJarWordsInspect()

			m.MinimockGetUserWordInspect()

			m.MinimockGetWordByIDInspect()

			m.MinimockGetWordByNameInspect()

			m.MinimockUpdateUserWordInspect()

			m.MinimockWordListInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddWordDone() &&
		m.MinimockAddWordToJarDone() &&
		m.MinimockGetJarWordsDone() &&
		m.MinimockGetUserWordDone() &&
		m.MinimockGetWordByIDDone() &&
		m.MinimockGetWordByNameDone() &&
		m.MinimockUpdateUserWordDone() &&
		m.MinimockWordListDone()
}
