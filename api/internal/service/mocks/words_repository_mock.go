// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/service.WordsRepository -o words_repository_mock.go -n WordsRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
	mm_service "github.com/maisiq/go-words-jar/internal/service"
)

// WordsRepositoryMock implements mm_service.WordsRepository
type WordsRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddWord          func(ctx context.Context, w1 models.Word) (err error)
	funcAddWordOrigin    string
	inspectFuncAddWord   func(ctx context.Context, w1 models.Word)
	afterAddWordCounter  uint64
	beforeAddWordCounter uint64
	AddWordMock          mWordsRepositoryMockAddWord

	funcGetWordByName          func(ctx context.Context, wordName string) (w1 models.Word, err error)
	funcGetWordByNameOrigin    string
	inspectFuncGetWordByName   func(ctx context.Context, wordName string)
	afterGetWordByNameCounter  uint64
	beforeGetWordByNameCounter uint64
	GetWordByNameMock          mWordsRepositoryMockGetWordByName

	funcWordList          func(ctx context.Context, qp1 *mm_service.QueryParams) (wa1 []models.Word, err error)
	funcWordListOrigin    string
	inspectFuncWordList   func(ctx context.Context, qp1 *mm_service.QueryParams)
	afterWordListCounter  uint64
	beforeWordListCounter uint64
	WordListMock          mWordsRepositoryMockWordList
}

// NewWordsRepositoryMock returns a mock for mm_service.WordsRepository
func NewWordsRepositoryMock(t minimock.Tester) *WordsRepositoryMock {
	m := &WordsRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddWordMock = mWordsRepositoryMockAddWord{mock: m}
	m.AddWordMock.callArgs = []*WordsRepositoryMockAddWordParams{}

	m.GetWordByNameMock = mWordsRepositoryMockGetWordByName{mock: m}
	m.GetWordByNameMock.callArgs = []*WordsRepositoryMockGetWordByNameParams{}

	m.WordListMock = mWordsRepositoryMockWordList{mock: m}
	m.WordListMock.callArgs = []*WordsRepositoryMockWordListParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mWordsRepositoryMockAddWord struct {
	optional           bool
	mock               *WordsRepositoryMock
	defaultExpectation *WordsRepositoryMockAddWordExpectation
	expectations       []*WordsRepositoryMockAddWordExpectation

	callArgs []*WordsRepositoryMockAddWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WordsRepositoryMockAddWordExpectation specifies expectation struct of the WordsRepository.AddWord
type WordsRepositoryMockAddWordExpectation struct {
	mock               *WordsRepositoryMock
	params             *WordsRepositoryMockAddWordParams
	paramPtrs          *WordsRepositoryMockAddWordParamPtrs
	expectationOrigins WordsRepositoryMockAddWordExpectationOrigins
	results            *WordsRepositoryMockAddWordResults
	returnOrigin       string
	Counter            uint64
}

// WordsRepositoryMockAddWordParams contains parameters of the WordsRepository.AddWord
type WordsRepositoryMockAddWordParams struct {
	ctx context.Context
	w1  models.Word
}

// WordsRepositoryMockAddWordParamPtrs contains pointers to parameters of the WordsRepository.AddWord
type WordsRepositoryMockAddWordParamPtrs struct {
	ctx *context.Context
	w1  *models.Word
}

// WordsRepositoryMockAddWordResults contains results of the WordsRepository.AddWord
type WordsRepositoryMockAddWordResults struct {
	err error
}

// WordsRepositoryMockAddWordOrigins contains origins of expectations of the WordsRepository.AddWord
type WordsRepositoryMockAddWordExpectationOrigins struct {
	origin    string
	originCtx string
	originW1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddWord *mWordsRepositoryMockAddWord) Optional() *mWordsRepositoryMockAddWord {
	mmAddWord.optional = true
	return mmAddWord
}

// Expect sets up expected params for WordsRepository.AddWord
func (mmAddWord *mWordsRepositoryMockAddWord) Expect(ctx context.Context, w1 models.Word) *mWordsRepositoryMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("WordsRepositoryMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &WordsRepositoryMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.paramPtrs != nil {
		mmAddWord.mock.t.Fatalf("WordsRepositoryMock.AddWord mock is already set by ExpectParams functions")
	}

	mmAddWord.defaultExpectation.params = &WordsRepositoryMockAddWordParams{ctx, w1}
	mmAddWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddWord.expectations {
		if minimock.Equal(e.params, mmAddWord.defaultExpectation.params) {
			mmAddWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddWord.defaultExpectation.params)
		}
	}

	return mmAddWord
}

// ExpectCtxParam1 sets up expected param ctx for WordsRepository.AddWord
func (mmAddWord *mWordsRepositoryMockAddWord) ExpectCtxParam1(ctx context.Context) *mWordsRepositoryMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("WordsRepositoryMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &WordsRepositoryMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.params != nil {
		mmAddWord.mock.t.Fatalf("WordsRepositoryMock.AddWord mock is already set by Expect")
	}

	if mmAddWord.defaultExpectation.paramPtrs == nil {
		mmAddWord.defaultExpectation.paramPtrs = &WordsRepositoryMockAddWordParamPtrs{}
	}
	mmAddWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddWord
}

// ExpectW1Param2 sets up expected param w1 for WordsRepository.AddWord
func (mmAddWord *mWordsRepositoryMockAddWord) ExpectW1Param2(w1 models.Word) *mWordsRepositoryMockAddWord {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("WordsRepositoryMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &WordsRepositoryMockAddWordExpectation{}
	}

	if mmAddWord.defaultExpectation.params != nil {
		mmAddWord.mock.t.Fatalf("WordsRepositoryMock.AddWord mock is already set by Expect")
	}

	if mmAddWord.defaultExpectation.paramPtrs == nil {
		mmAddWord.defaultExpectation.paramPtrs = &WordsRepositoryMockAddWordParamPtrs{}
	}
	mmAddWord.defaultExpectation.paramPtrs.w1 = &w1
	mmAddWord.defaultExpectation.expectationOrigins.originW1 = minimock.CallerInfo(1)

	return mmAddWord
}

// Inspect accepts an inspector function that has same arguments as the WordsRepository.AddWord
func (mmAddWord *mWordsRepositoryMockAddWord) Inspect(f func(ctx context.Context, w1 models.Word)) *mWordsRepositoryMockAddWord {
	if mmAddWord.mock.inspectFuncAddWord != nil {
		mmAddWord.mock.t.Fatalf("Inspect function is already set for WordsRepositoryMock.AddWord")
	}

	mmAddWord.mock.inspectFuncAddWord = f

	return mmAddWord
}

// Return sets up results that will be returned by WordsRepository.AddWord
func (mmAddWord *mWordsRepositoryMockAddWord) Return(err error) *WordsRepositoryMock {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("WordsRepositoryMock.AddWord mock is already set by Set")
	}

	if mmAddWord.defaultExpectation == nil {
		mmAddWord.defaultExpectation = &WordsRepositoryMockAddWordExpectation{mock: mmAddWord.mock}
	}
	mmAddWord.defaultExpectation.results = &WordsRepositoryMockAddWordResults{err}
	mmAddWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddWord.mock
}

// Set uses given function f to mock the WordsRepository.AddWord method
func (mmAddWord *mWordsRepositoryMockAddWord) Set(f func(ctx context.Context, w1 models.Word) (err error)) *WordsRepositoryMock {
	if mmAddWord.defaultExpectation != nil {
		mmAddWord.mock.t.Fatalf("Default expectation is already set for the WordsRepository.AddWord method")
	}

	if len(mmAddWord.expectations) > 0 {
		mmAddWord.mock.t.Fatalf("Some expectations are already set for the WordsRepository.AddWord method")
	}

	mmAddWord.mock.funcAddWord = f
	mmAddWord.mock.funcAddWordOrigin = minimock.CallerInfo(1)
	return mmAddWord.mock
}

// When sets expectation for the WordsRepository.AddWord which will trigger the result defined by the following
// Then helper
func (mmAddWord *mWordsRepositoryMockAddWord) When(ctx context.Context, w1 models.Word) *WordsRepositoryMockAddWordExpectation {
	if mmAddWord.mock.funcAddWord != nil {
		mmAddWord.mock.t.Fatalf("WordsRepositoryMock.AddWord mock is already set by Set")
	}

	expectation := &WordsRepositoryMockAddWordExpectation{
		mock:               mmAddWord.mock,
		params:             &WordsRepositoryMockAddWordParams{ctx, w1},
		expectationOrigins: WordsRepositoryMockAddWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddWord.expectations = append(mmAddWord.expectations, expectation)
	return expectation
}

// Then sets up WordsRepository.AddWord return parameters for the expectation previously defined by the When method
func (e *WordsRepositoryMockAddWordExpectation) Then(err error) *WordsRepositoryMock {
	e.results = &WordsRepositoryMockAddWordResults{err}
	return e.mock
}

// Times sets number of times WordsRepository.AddWord should be invoked
func (mmAddWord *mWordsRepositoryMockAddWord) Times(n uint64) *mWordsRepositoryMockAddWord {
	if n == 0 {
		mmAddWord.mock.t.Fatalf("Times of WordsRepositoryMock.AddWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddWord.expectedInvocations, n)
	mmAddWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddWord
}

func (mmAddWord *mWordsRepositoryMockAddWord) invocationsDone() bool {
	if len(mmAddWord.expectations) == 0 && mmAddWord.defaultExpectation == nil && mmAddWord.mock.funcAddWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddWord.mock.afterAddWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddWord implements mm_service.WordsRepository
func (mmAddWord *WordsRepositoryMock) AddWord(ctx context.Context, w1 models.Word) (err error) {
	mm_atomic.AddUint64(&mmAddWord.beforeAddWordCounter, 1)
	defer mm_atomic.AddUint64(&mmAddWord.afterAddWordCounter, 1)

	mmAddWord.t.Helper()

	if mmAddWord.inspectFuncAddWord != nil {
		mmAddWord.inspectFuncAddWord(ctx, w1)
	}

	mm_params := WordsRepositoryMockAddWordParams{ctx, w1}

	// Record call args
	mmAddWord.AddWordMock.mutex.Lock()
	mmAddWord.AddWordMock.callArgs = append(mmAddWord.AddWordMock.callArgs, &mm_params)
	mmAddWord.AddWordMock.mutex.Unlock()

	for _, e := range mmAddWord.AddWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddWord.AddWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddWord.AddWordMock.defaultExpectation.Counter, 1)
		mm_want := mmAddWord.AddWordMock.defaultExpectation.params
		mm_want_ptrs := mmAddWord.AddWordMock.defaultExpectation.paramPtrs

		mm_got := WordsRepositoryMockAddWordParams{ctx, w1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddWord.t.Errorf("WordsRepositoryMock.AddWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.w1 != nil && !minimock.Equal(*mm_want_ptrs.w1, mm_got.w1) {
				mmAddWord.t.Errorf("WordsRepositoryMock.AddWord got unexpected parameter w1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.originW1, *mm_want_ptrs.w1, mm_got.w1, minimock.Diff(*mm_want_ptrs.w1, mm_got.w1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddWord.t.Errorf("WordsRepositoryMock.AddWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddWord.AddWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddWord.AddWordMock.defaultExpectation.results
		if mm_results == nil {
			mmAddWord.t.Fatal("No results are set for the WordsRepositoryMock.AddWord")
		}
		return (*mm_results).err
	}
	if mmAddWord.funcAddWord != nil {
		return mmAddWord.funcAddWord(ctx, w1)
	}
	mmAddWord.t.Fatalf("Unexpected call to WordsRepositoryMock.AddWord. %v %v", ctx, w1)
	return
}

// AddWordAfterCounter returns a count of finished WordsRepositoryMock.AddWord invocations
func (mmAddWord *WordsRepositoryMock) AddWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWord.afterAddWordCounter)
}

// AddWordBeforeCounter returns a count of WordsRepositoryMock.AddWord invocations
func (mmAddWord *WordsRepositoryMock) AddWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWord.beforeAddWordCounter)
}

// Calls returns a list of arguments used in each call to WordsRepositoryMock.AddWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddWord *mWordsRepositoryMockAddWord) Calls() []*WordsRepositoryMockAddWordParams {
	mmAddWord.mutex.RLock()

	argCopy := make([]*WordsRepositoryMockAddWordParams, len(mmAddWord.callArgs))
	copy(argCopy, mmAddWord.callArgs)

	mmAddWord.mutex.RUnlock()

	return argCopy
}

// MinimockAddWordDone returns true if the count of the AddWord invocations corresponds
// the number of defined expectations
func (m *WordsRepositoryMock) MinimockAddWordDone() bool {
	if m.AddWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddWordMock.invocationsDone()
}

// MinimockAddWordInspect logs each unmet expectation
func (m *WordsRepositoryMock) MinimockAddWordInspect() {
	for _, e := range m.AddWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WordsRepositoryMock.AddWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddWordCounter := mm_atomic.LoadUint64(&m.afterAddWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddWordMock.defaultExpectation != nil && afterAddWordCounter < 1 {
		if m.AddWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to WordsRepositoryMock.AddWord at\n%s", m.AddWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to WordsRepositoryMock.AddWord at\n%s with params: %#v", m.AddWordMock.defaultExpectation.expectationOrigins.origin, *m.AddWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddWord != nil && afterAddWordCounter < 1 {
		m.t.Errorf("Expected call to WordsRepositoryMock.AddWord at\n%s", m.funcAddWordOrigin)
	}

	if !m.AddWordMock.invocationsDone() && afterAddWordCounter > 0 {
		m.t.Errorf("Expected %d calls to WordsRepositoryMock.AddWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddWordMock.expectedInvocations), m.AddWordMock.expectedInvocationsOrigin, afterAddWordCounter)
	}
}

type mWordsRepositoryMockGetWordByName struct {
	optional           bool
	mock               *WordsRepositoryMock
	defaultExpectation *WordsRepositoryMockGetWordByNameExpectation
	expectations       []*WordsRepositoryMockGetWordByNameExpectation

	callArgs []*WordsRepositoryMockGetWordByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WordsRepositoryMockGetWordByNameExpectation specifies expectation struct of the WordsRepository.GetWordByName
type WordsRepositoryMockGetWordByNameExpectation struct {
	mock               *WordsRepositoryMock
	params             *WordsRepositoryMockGetWordByNameParams
	paramPtrs          *WordsRepositoryMockGetWordByNameParamPtrs
	expectationOrigins WordsRepositoryMockGetWordByNameExpectationOrigins
	results            *WordsRepositoryMockGetWordByNameResults
	returnOrigin       string
	Counter            uint64
}

// WordsRepositoryMockGetWordByNameParams contains parameters of the WordsRepository.GetWordByName
type WordsRepositoryMockGetWordByNameParams struct {
	ctx      context.Context
	wordName string
}

// WordsRepositoryMockGetWordByNameParamPtrs contains pointers to parameters of the WordsRepository.GetWordByName
type WordsRepositoryMockGetWordByNameParamPtrs struct {
	ctx      *context.Context
	wordName *string
}

// WordsRepositoryMockGetWordByNameResults contains results of the WordsRepository.GetWordByName
type WordsRepositoryMockGetWordByNameResults struct {
	w1  models.Word
	err error
}

// WordsRepositoryMockGetWordByNameOrigins contains origins of expectations of the WordsRepository.GetWordByName
type WordsRepositoryMockGetWordByNameExpectationOrigins struct {
	origin         string
	originCtx      string
	originWordName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) Optional() *mWordsRepositoryMockGetWordByName {
	mmGetWordByName.optional = true
	return mmGetWordByName
}

// Expect sets up expected params for WordsRepository.GetWordByName
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) Expect(ctx context.Context, wordName string) *mWordsRepositoryMockGetWordByName {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("WordsRepositoryMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &WordsRepositoryMockGetWordByNameExpectation{}
	}

	if mmGetWordByName.defaultExpectation.paramPtrs != nil {
		mmGetWordByName.mock.t.Fatalf("WordsRepositoryMock.GetWordByName mock is already set by ExpectParams functions")
	}

	mmGetWordByName.defaultExpectation.params = &WordsRepositoryMockGetWordByNameParams{ctx, wordName}
	mmGetWordByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetWordByName.expectations {
		if minimock.Equal(e.params, mmGetWordByName.defaultExpectation.params) {
			mmGetWordByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWordByName.defaultExpectation.params)
		}
	}

	return mmGetWordByName
}

// ExpectCtxParam1 sets up expected param ctx for WordsRepository.GetWordByName
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) ExpectCtxParam1(ctx context.Context) *mWordsRepositoryMockGetWordByName {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("WordsRepositoryMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &WordsRepositoryMockGetWordByNameExpectation{}
	}

	if mmGetWordByName.defaultExpectation.params != nil {
		mmGetWordByName.mock.t.Fatalf("WordsRepositoryMock.GetWordByName mock is already set by Expect")
	}

	if mmGetWordByName.defaultExpectation.paramPtrs == nil {
		mmGetWordByName.defaultExpectation.paramPtrs = &WordsRepositoryMockGetWordByNameParamPtrs{}
	}
	mmGetWordByName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetWordByName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetWordByName
}

// ExpectWordNameParam2 sets up expected param wordName for WordsRepository.GetWordByName
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) ExpectWordNameParam2(wordName string) *mWordsRepositoryMockGetWordByName {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("WordsRepositoryMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &WordsRepositoryMockGetWordByNameExpectation{}
	}

	if mmGetWordByName.defaultExpectation.params != nil {
		mmGetWordByName.mock.t.Fatalf("WordsRepositoryMock.GetWordByName mock is already set by Expect")
	}

	if mmGetWordByName.defaultExpectation.paramPtrs == nil {
		mmGetWordByName.defaultExpectation.paramPtrs = &WordsRepositoryMockGetWordByNameParamPtrs{}
	}
	mmGetWordByName.defaultExpectation.paramPtrs.wordName = &wordName
	mmGetWordByName.defaultExpectation.expectationOrigins.originWordName = minimock.CallerInfo(1)

	return mmGetWordByName
}

// Inspect accepts an inspector function that has same arguments as the WordsRepository.GetWordByName
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) Inspect(f func(ctx context.Context, wordName string)) *mWordsRepositoryMockGetWordByName {
	if mmGetWordByName.mock.inspectFuncGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("Inspect function is already set for WordsRepositoryMock.GetWordByName")
	}

	mmGetWordByName.mock.inspectFuncGetWordByName = f

	return mmGetWordByName
}

// Return sets up results that will be returned by WordsRepository.GetWordByName
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) Return(w1 models.Word, err error) *WordsRepositoryMock {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("WordsRepositoryMock.GetWordByName mock is already set by Set")
	}

	if mmGetWordByName.defaultExpectation == nil {
		mmGetWordByName.defaultExpectation = &WordsRepositoryMockGetWordByNameExpectation{mock: mmGetWordByName.mock}
	}
	mmGetWordByName.defaultExpectation.results = &WordsRepositoryMockGetWordByNameResults{w1, err}
	mmGetWordByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetWordByName.mock
}

// Set uses given function f to mock the WordsRepository.GetWordByName method
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) Set(f func(ctx context.Context, wordName string) (w1 models.Word, err error)) *WordsRepositoryMock {
	if mmGetWordByName.defaultExpectation != nil {
		mmGetWordByName.mock.t.Fatalf("Default expectation is already set for the WordsRepository.GetWordByName method")
	}

	if len(mmGetWordByName.expectations) > 0 {
		mmGetWordByName.mock.t.Fatalf("Some expectations are already set for the WordsRepository.GetWordByName method")
	}

	mmGetWordByName.mock.funcGetWordByName = f
	mmGetWordByName.mock.funcGetWordByNameOrigin = minimock.CallerInfo(1)
	return mmGetWordByName.mock
}

// When sets expectation for the WordsRepository.GetWordByName which will trigger the result defined by the following
// Then helper
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) When(ctx context.Context, wordName string) *WordsRepositoryMockGetWordByNameExpectation {
	if mmGetWordByName.mock.funcGetWordByName != nil {
		mmGetWordByName.mock.t.Fatalf("WordsRepositoryMock.GetWordByName mock is already set by Set")
	}

	expectation := &WordsRepositoryMockGetWordByNameExpectation{
		mock:               mmGetWordByName.mock,
		params:             &WordsRepositoryMockGetWordByNameParams{ctx, wordName},
		expectationOrigins: WordsRepositoryMockGetWordByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetWordByName.expectations = append(mmGetWordByName.expectations, expectation)
	return expectation
}

// Then sets up WordsRepository.GetWordByName return parameters for the expectation previously defined by the When method
func (e *WordsRepositoryMockGetWordByNameExpectation) Then(w1 models.Word, err error) *WordsRepositoryMock {
	e.results = &WordsRepositoryMockGetWordByNameResults{w1, err}
	return e.mock
}

// Times sets number of times WordsRepository.GetWordByName should be invoked
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) Times(n uint64) *mWordsRepositoryMockGetWordByName {
	if n == 0 {
		mmGetWordByName.mock.t.Fatalf("Times of WordsRepositoryMock.GetWordByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetWordByName.expectedInvocations, n)
	mmGetWordByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetWordByName
}

func (mmGetWordByName *mWordsRepositoryMockGetWordByName) invocationsDone() bool {
	if len(mmGetWordByName.expectations) == 0 && mmGetWordByName.defaultExpectation == nil && mmGetWordByName.mock.funcGetWordByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetWordByName.mock.afterGetWordByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetWordByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetWordByName implements mm_service.WordsRepository
func (mmGetWordByName *WordsRepositoryMock) GetWordByName(ctx context.Context, wordName string) (w1 models.Word, err error) {
	mm_atomic.AddUint64(&mmGetWordByName.beforeGetWordByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWordByName.afterGetWordByNameCounter, 1)

	mmGetWordByName.t.Helper()

	if mmGetWordByName.inspectFuncGetWordByName != nil {
		mmGetWordByName.inspectFuncGetWordByName(ctx, wordName)
	}

	mm_params := WordsRepositoryMockGetWordByNameParams{ctx, wordName}

	// Record call args
	mmGetWordByName.GetWordByNameMock.mutex.Lock()
	mmGetWordByName.GetWordByNameMock.callArgs = append(mmGetWordByName.GetWordByNameMock.callArgs, &mm_params)
	mmGetWordByName.GetWordByNameMock.mutex.Unlock()

	for _, e := range mmGetWordByName.GetWordByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1, e.results.err
		}
	}

	if mmGetWordByName.GetWordByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWordByName.GetWordByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWordByName.GetWordByNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetWordByName.GetWordByNameMock.defaultExpectation.paramPtrs

		mm_got := WordsRepositoryMockGetWordByNameParams{ctx, wordName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetWordByName.t.Errorf("WordsRepositoryMock.GetWordByName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByName.GetWordByNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wordName != nil && !minimock.Equal(*mm_want_ptrs.wordName, mm_got.wordName) {
				mmGetWordByName.t.Errorf("WordsRepositoryMock.GetWordByName got unexpected parameter wordName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByName.GetWordByNameMock.defaultExpectation.expectationOrigins.originWordName, *mm_want_ptrs.wordName, mm_got.wordName, minimock.Diff(*mm_want_ptrs.wordName, mm_got.wordName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWordByName.t.Errorf("WordsRepositoryMock.GetWordByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetWordByName.GetWordByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWordByName.GetWordByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWordByName.t.Fatal("No results are set for the WordsRepositoryMock.GetWordByName")
		}
		return (*mm_results).w1, (*mm_results).err
	}
	if mmGetWordByName.funcGetWordByName != nil {
		return mmGetWordByName.funcGetWordByName(ctx, wordName)
	}
	mmGetWordByName.t.Fatalf("Unexpected call to WordsRepositoryMock.GetWordByName. %v %v", ctx, wordName)
	return
}

// GetWordByNameAfterCounter returns a count of finished WordsRepositoryMock.GetWordByName invocations
func (mmGetWordByName *WordsRepositoryMock) GetWordByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByName.afterGetWordByNameCounter)
}

// GetWordByNameBeforeCounter returns a count of WordsRepositoryMock.GetWordByName invocations
func (mmGetWordByName *WordsRepositoryMock) GetWordByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByName.beforeGetWordByNameCounter)
}

// Calls returns a list of arguments used in each call to WordsRepositoryMock.GetWordByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWordByName *mWordsRepositoryMockGetWordByName) Calls() []*WordsRepositoryMockGetWordByNameParams {
	mmGetWordByName.mutex.RLock()

	argCopy := make([]*WordsRepositoryMockGetWordByNameParams, len(mmGetWordByName.callArgs))
	copy(argCopy, mmGetWordByName.callArgs)

	mmGetWordByName.mutex.RUnlock()

	return argCopy
}

// MinimockGetWordByNameDone returns true if the count of the GetWordByName invocations corresponds
// the number of defined expectations
func (m *WordsRepositoryMock) MinimockGetWordByNameDone() bool {
	if m.GetWordByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetWordByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetWordByNameMock.invocationsDone()
}

// MinimockGetWordByNameInspect logs each unmet expectation
func (m *WordsRepositoryMock) MinimockGetWordByNameInspect() {
	for _, e := range m.GetWordByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WordsRepositoryMock.GetWordByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetWordByNameCounter := mm_atomic.LoadUint64(&m.afterGetWordByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetWordByNameMock.defaultExpectation != nil && afterGetWordByNameCounter < 1 {
		if m.GetWordByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to WordsRepositoryMock.GetWordByName at\n%s", m.GetWordByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to WordsRepositoryMock.GetWordByName at\n%s with params: %#v", m.GetWordByNameMock.defaultExpectation.expectationOrigins.origin, *m.GetWordByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWordByName != nil && afterGetWordByNameCounter < 1 {
		m.t.Errorf("Expected call to WordsRepositoryMock.GetWordByName at\n%s", m.funcGetWordByNameOrigin)
	}

	if !m.GetWordByNameMock.invocationsDone() && afterGetWordByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to WordsRepositoryMock.GetWordByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetWordByNameMock.expectedInvocations), m.GetWordByNameMock.expectedInvocationsOrigin, afterGetWordByNameCounter)
	}
}

type mWordsRepositoryMockWordList struct {
	optional           bool
	mock               *WordsRepositoryMock
	defaultExpectation *WordsRepositoryMockWordListExpectation
	expectations       []*WordsRepositoryMockWordListExpectation

	callArgs []*WordsRepositoryMockWordListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WordsRepositoryMockWordListExpectation specifies expectation struct of the WordsRepository.WordList
type WordsRepositoryMockWordListExpectation struct {
	mock               *WordsRepositoryMock
	params             *WordsRepositoryMockWordListParams
	paramPtrs          *WordsRepositoryMockWordListParamPtrs
	expectationOrigins WordsRepositoryMockWordListExpectationOrigins
	results            *WordsRepositoryMockWordListResults
	returnOrigin       string
	Counter            uint64
}

// WordsRepositoryMockWordListParams contains parameters of the WordsRepository.WordList
type WordsRepositoryMockWordListParams struct {
	ctx context.Context
	qp1 *mm_service.QueryParams
}

// WordsRepositoryMockWordListParamPtrs contains pointers to parameters of the WordsRepository.WordList
type WordsRepositoryMockWordListParamPtrs struct {
	ctx *context.Context
	qp1 **mm_service.QueryParams
}

// WordsRepositoryMockWordListResults contains results of the WordsRepository.WordList
type WordsRepositoryMockWordListResults struct {
	wa1 []models.Word
	err error
}

// WordsRepositoryMockWordListOrigins contains origins of expectations of the WordsRepository.WordList
type WordsRepositoryMockWordListExpectationOrigins struct {
	origin    string
	originCtx string
	originQp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWordList *mWordsRepositoryMockWordList) Optional() *mWordsRepositoryMockWordList {
	mmWordList.optional = true
	return mmWordList
}

// Expect sets up expected params for WordsRepository.WordList
func (mmWordList *mWordsRepositoryMockWordList) Expect(ctx context.Context, qp1 *mm_service.QueryParams) *mWordsRepositoryMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("WordsRepositoryMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &WordsRepositoryMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.paramPtrs != nil {
		mmWordList.mock.t.Fatalf("WordsRepositoryMock.WordList mock is already set by ExpectParams functions")
	}

	mmWordList.defaultExpectation.params = &WordsRepositoryMockWordListParams{ctx, qp1}
	mmWordList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWordList.expectations {
		if minimock.Equal(e.params, mmWordList.defaultExpectation.params) {
			mmWordList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWordList.defaultExpectation.params)
		}
	}

	return mmWordList
}

// ExpectCtxParam1 sets up expected param ctx for WordsRepository.WordList
func (mmWordList *mWordsRepositoryMockWordList) ExpectCtxParam1(ctx context.Context) *mWordsRepositoryMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("WordsRepositoryMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &WordsRepositoryMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.params != nil {
		mmWordList.mock.t.Fatalf("WordsRepositoryMock.WordList mock is already set by Expect")
	}

	if mmWordList.defaultExpectation.paramPtrs == nil {
		mmWordList.defaultExpectation.paramPtrs = &WordsRepositoryMockWordListParamPtrs{}
	}
	mmWordList.defaultExpectation.paramPtrs.ctx = &ctx
	mmWordList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWordList
}

// ExpectQp1Param2 sets up expected param qp1 for WordsRepository.WordList
func (mmWordList *mWordsRepositoryMockWordList) ExpectQp1Param2(qp1 *mm_service.QueryParams) *mWordsRepositoryMockWordList {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("WordsRepositoryMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &WordsRepositoryMockWordListExpectation{}
	}

	if mmWordList.defaultExpectation.params != nil {
		mmWordList.mock.t.Fatalf("WordsRepositoryMock.WordList mock is already set by Expect")
	}

	if mmWordList.defaultExpectation.paramPtrs == nil {
		mmWordList.defaultExpectation.paramPtrs = &WordsRepositoryMockWordListParamPtrs{}
	}
	mmWordList.defaultExpectation.paramPtrs.qp1 = &qp1
	mmWordList.defaultExpectation.expectationOrigins.originQp1 = minimock.CallerInfo(1)

	return mmWordList
}

// Inspect accepts an inspector function that has same arguments as the WordsRepository.WordList
func (mmWordList *mWordsRepositoryMockWordList) Inspect(f func(ctx context.Context, qp1 *mm_service.QueryParams)) *mWordsRepositoryMockWordList {
	if mmWordList.mock.inspectFuncWordList != nil {
		mmWordList.mock.t.Fatalf("Inspect function is already set for WordsRepositoryMock.WordList")
	}

	mmWordList.mock.inspectFuncWordList = f

	return mmWordList
}

// Return sets up results that will be returned by WordsRepository.WordList
func (mmWordList *mWordsRepositoryMockWordList) Return(wa1 []models.Word, err error) *WordsRepositoryMock {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("WordsRepositoryMock.WordList mock is already set by Set")
	}

	if mmWordList.defaultExpectation == nil {
		mmWordList.defaultExpectation = &WordsRepositoryMockWordListExpectation{mock: mmWordList.mock}
	}
	mmWordList.defaultExpectation.results = &WordsRepositoryMockWordListResults{wa1, err}
	mmWordList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWordList.mock
}

// Set uses given function f to mock the WordsRepository.WordList method
func (mmWordList *mWordsRepositoryMockWordList) Set(f func(ctx context.Context, qp1 *mm_service.QueryParams) (wa1 []models.Word, err error)) *WordsRepositoryMock {
	if mmWordList.defaultExpectation != nil {
		mmWordList.mock.t.Fatalf("Default expectation is already set for the WordsRepository.WordList method")
	}

	if len(mmWordList.expectations) > 0 {
		mmWordList.mock.t.Fatalf("Some expectations are already set for the WordsRepository.WordList method")
	}

	mmWordList.mock.funcWordList = f
	mmWordList.mock.funcWordListOrigin = minimock.CallerInfo(1)
	return mmWordList.mock
}

// When sets expectation for the WordsRepository.WordList which will trigger the result defined by the following
// Then helper
func (mmWordList *mWordsRepositoryMockWordList) When(ctx context.Context, qp1 *mm_service.QueryParams) *WordsRepositoryMockWordListExpectation {
	if mmWordList.mock.funcWordList != nil {
		mmWordList.mock.t.Fatalf("WordsRepositoryMock.WordList mock is already set by Set")
	}

	expectation := &WordsRepositoryMockWordListExpectation{
		mock:               mmWordList.mock,
		params:             &WordsRepositoryMockWordListParams{ctx, qp1},
		expectationOrigins: WordsRepositoryMockWordListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWordList.expectations = append(mmWordList.expectations, expectation)
	return expectation
}

// Then sets up WordsRepository.WordList return parameters for the expectation previously defined by the When method
func (e *WordsRepositoryMockWordListExpectation) Then(wa1 []models.Word, err error) *WordsRepositoryMock {
	e.results = &WordsRepositoryMockWordListResults{wa1, err}
	return e.mock
}

// Times sets number of times WordsRepository.WordList should be invoked
func (mmWordList *mWordsRepositoryMockWordList) Times(n uint64) *mWordsRepositoryMockWordList {
	if n == 0 {
		mmWordList.mock.t.Fatalf("Times of WordsRepositoryMock.WordList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWordList.expectedInvocations, n)
	mmWordList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWordList
}

func (mmWordList *mWordsRepositoryMockWordList) invocationsDone() bool {
	if len(mmWordList.expectations) == 0 && mmWordList.defaultExpectation == nil && mmWordList.mock.funcWordList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWordList.mock.afterWordListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWordList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WordList implements mm_service.WordsRepository
func (mmWordList *WordsRepositoryMock) WordList(ctx context.Context, qp1 *mm_service.QueryParams) (wa1 []models.Word, err error) {
	mm_atomic.AddUint64(&mmWordList.beforeWordListCounter, 1)
	defer mm_atomic.AddUint64(&mmWordList.afterWordListCounter, 1)

	mmWordList.t.Helper()

	if mmWordList.inspectFuncWordList != nil {
		mmWordList.inspectFuncWordList(ctx, qp1)
	}

	mm_params := WordsRepositoryMockWordListParams{ctx, qp1}

	// Record call args
	mmWordList.WordListMock.mutex.Lock()
	mmWordList.WordListMock.callArgs = append(mmWordList.WordListMock.callArgs, &mm_params)
	mmWordList.WordListMock.mutex.Unlock()

	for _, e := range mmWordList.WordListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmWordList.WordListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWordList.WordListMock.defaultExpectation.Counter, 1)
		mm_want := mmWordList.WordListMock.defaultExpectation.params
		mm_want_ptrs := mmWordList.WordListMock.defaultExpectation.paramPtrs

		mm_got := WordsRepositoryMockWordListParams{ctx, qp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWordList.t.Errorf("WordsRepositoryMock.WordList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWordList.WordListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.qp1 != nil && !minimock.Equal(*mm_want_ptrs.qp1, mm_got.qp1) {
				mmWordList.t.Errorf("WordsRepositoryMock.WordList got unexpected parameter qp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWordList.WordListMock.defaultExpectation.expectationOrigins.originQp1, *mm_want_ptrs.qp1, mm_got.qp1, minimock.Diff(*mm_want_ptrs.qp1, mm_got.qp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWordList.t.Errorf("WordsRepositoryMock.WordList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWordList.WordListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWordList.WordListMock.defaultExpectation.results
		if mm_results == nil {
			mmWordList.t.Fatal("No results are set for the WordsRepositoryMock.WordList")
		}
		return (*mm_results).wa1, (*mm_results).err
	}
	if mmWordList.funcWordList != nil {
		return mmWordList.funcWordList(ctx, qp1)
	}
	mmWordList.t.Fatalf("Unexpected call to WordsRepositoryMock.WordList. %v %v", ctx, qp1)
	return
}

// WordListAfterCounter returns a count of finished WordsRepositoryMock.WordList invocations
func (mmWordList *WordsRepositoryMock) WordListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWordList.afterWordListCounter)
}

// WordListBeforeCounter returns a count of WordsRepositoryMock.WordList invocations
func (mmWordList *WordsRepositoryMock) WordListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWordList.beforeWordListCounter)
}

// Calls returns a list of arguments used in each call to WordsRepositoryMock.WordList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWordList *mWordsRepositoryMockWordList) Calls() []*WordsRepositoryMockWordListParams {
	mmWordList.mutex.RLock()

	argCopy := make([]*WordsRepositoryMockWordListParams, len(mmWordList.callArgs))
	copy(argCopy, mmWordList.callArgs)

	mmWordList.mutex.RUnlock()

	return argCopy
}

// MinimockWordListDone returns true if the count of the WordList invocations corresponds
// the number of defined expectations
func (m *WordsRepositoryMock) MinimockWordListDone() bool {
	if m.WordListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WordListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WordListMock.invocationsDone()
}

// MinimockWordListInspect logs each unmet expectation
func (m *WordsRepositoryMock) MinimockWordListInspect() {
	for _, e := range m.WordListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WordsRepositoryMock.WordList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWordListCounter := mm_atomic.LoadUint64(&m.afterWordListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WordListMock.defaultExpectation != nil && afterWordListCounter < 1 {
		if m.WordListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to WordsRepositoryMock.WordList at\n%s", m.WordListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to WordsRepositoryMock.WordList at\n%s with params: %#v", m.WordListMock.defaultExpectation.expectationOrigins.origin, *m.WordListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWordList != nil && afterWordListCounter < 1 {
		m.t.Errorf("Expected call to WordsRepositoryMock.WordList at\n%s", m.funcWordListOrigin)
	}

	if !m.WordListMock.invocationsDone() && afterWordListCounter > 0 {
		m.t.Errorf("Expected %d calls to WordsRepositoryMock.WordList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WordListMock.expectedInvocations), m.WordListMock.expectedInvocationsOrigin, afterWordListCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *WordsRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddWordInspect()

			m.MinimockGetWordByNameInspect()

			m.MinimockWordListInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *WordsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *WordsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddWordDone() &&
		m.MinimockGetWordByNameDone() &&
		m.MinimockWordListDone()
}
