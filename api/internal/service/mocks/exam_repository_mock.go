// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/service.ExamRepository -o exam_repository_mock.go -n ExamRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
	mm_service "github.com/maisiq/go-words-jar/internal/service"
)

// ExamRepositoryMock implements mm_service.ExamRepository
type ExamRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetJarWords          func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)
	funcGetJarWordsOrigin    string
	inspectFuncGetJarWords   func(ctx context.Context, username string, filters ...mm_service.Filter)
	afterGetJarWordsCounter  uint64
	beforeGetJarWordsCounter uint64
	GetJarWordsMock          mExamRepositoryMockGetJarWords

	funcGetUserWord          func(ctx context.Context, wordID string, username string) (up1 *models.UserWord, err error)
	funcGetUserWordOrigin    string
	inspectFuncGetUserWord   func(ctx context.Context, wordID string, username string)
	afterGetUserWordCounter  uint64
	beforeGetUserWordCounter uint64
	GetUserWordMock          mExamRepositoryMockGetUserWord

	funcGetWordByID          func(ctx context.Context, id string) (w1 models.Word, err error)
	funcGetWordByIDOrigin    string
	inspectFuncGetWordByID   func(ctx context.Context, id string)
	afterGetWordByIDCounter  uint64
	beforeGetWordByIDCounter uint64
	GetWordByIDMock          mExamRepositoryMockGetWordByID

	funcUpdateUserWord          func(ctx context.Context, userWord *models.UserWord) (err error)
	funcUpdateUserWordOrigin    string
	inspectFuncUpdateUserWord   func(ctx context.Context, userWord *models.UserWord)
	afterUpdateUserWordCounter  uint64
	beforeUpdateUserWordCounter uint64
	UpdateUserWordMock          mExamRepositoryMockUpdateUserWord
}

// NewExamRepositoryMock returns a mock for mm_service.ExamRepository
func NewExamRepositoryMock(t minimock.Tester) *ExamRepositoryMock {
	m := &ExamRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetJarWordsMock = mExamRepositoryMockGetJarWords{mock: m}
	m.GetJarWordsMock.callArgs = []*ExamRepositoryMockGetJarWordsParams{}

	m.GetUserWordMock = mExamRepositoryMockGetUserWord{mock: m}
	m.GetUserWordMock.callArgs = []*ExamRepositoryMockGetUserWordParams{}

	m.GetWordByIDMock = mExamRepositoryMockGetWordByID{mock: m}
	m.GetWordByIDMock.callArgs = []*ExamRepositoryMockGetWordByIDParams{}

	m.UpdateUserWordMock = mExamRepositoryMockUpdateUserWord{mock: m}
	m.UpdateUserWordMock.callArgs = []*ExamRepositoryMockUpdateUserWordParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mExamRepositoryMockGetJarWords struct {
	optional           bool
	mock               *ExamRepositoryMock
	defaultExpectation *ExamRepositoryMockGetJarWordsExpectation
	expectations       []*ExamRepositoryMockGetJarWordsExpectation

	callArgs []*ExamRepositoryMockGetJarWordsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamRepositoryMockGetJarWordsExpectation specifies expectation struct of the ExamRepository.GetJarWords
type ExamRepositoryMockGetJarWordsExpectation struct {
	mock               *ExamRepositoryMock
	params             *ExamRepositoryMockGetJarWordsParams
	paramPtrs          *ExamRepositoryMockGetJarWordsParamPtrs
	expectationOrigins ExamRepositoryMockGetJarWordsExpectationOrigins
	results            *ExamRepositoryMockGetJarWordsResults
	returnOrigin       string
	Counter            uint64
}

// ExamRepositoryMockGetJarWordsParams contains parameters of the ExamRepository.GetJarWords
type ExamRepositoryMockGetJarWordsParams struct {
	ctx      context.Context
	username string
	filters  []mm_service.Filter
}

// ExamRepositoryMockGetJarWordsParamPtrs contains pointers to parameters of the ExamRepository.GetJarWords
type ExamRepositoryMockGetJarWordsParamPtrs struct {
	ctx      *context.Context
	username *string
	filters  *[]mm_service.Filter
}

// ExamRepositoryMockGetJarWordsResults contains results of the ExamRepository.GetJarWords
type ExamRepositoryMockGetJarWordsResults struct {
	wa1 []models.Word
	err error
}

// ExamRepositoryMockGetJarWordsOrigins contains origins of expectations of the ExamRepository.GetJarWords
type ExamRepositoryMockGetJarWordsExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originFilters  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetJarWords *mExamRepositoryMockGetJarWords) Optional() *mExamRepositoryMockGetJarWords {
	mmGetJarWords.optional = true
	return mmGetJarWords
}

// Expect sets up expected params for ExamRepository.GetJarWords
func (mmGetJarWords *mExamRepositoryMockGetJarWords) Expect(ctx context.Context, username string, filters ...mm_service.Filter) *mExamRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &ExamRepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.paramPtrs != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by ExpectParams functions")
	}

	mmGetJarWords.defaultExpectation.params = &ExamRepositoryMockGetJarWordsParams{ctx, username, filters}
	mmGetJarWords.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetJarWords.expectations {
		if minimock.Equal(e.params, mmGetJarWords.defaultExpectation.params) {
			mmGetJarWords.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetJarWords.defaultExpectation.params)
		}
	}

	return mmGetJarWords
}

// ExpectCtxParam1 sets up expected param ctx for ExamRepository.GetJarWords
func (mmGetJarWords *mExamRepositoryMockGetJarWords) ExpectCtxParam1(ctx context.Context) *mExamRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &ExamRepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.params != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by Expect")
	}

	if mmGetJarWords.defaultExpectation.paramPtrs == nil {
		mmGetJarWords.defaultExpectation.paramPtrs = &ExamRepositoryMockGetJarWordsParamPtrs{}
	}
	mmGetJarWords.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetJarWords.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetJarWords
}

// ExpectUsernameParam2 sets up expected param username for ExamRepository.GetJarWords
func (mmGetJarWords *mExamRepositoryMockGetJarWords) ExpectUsernameParam2(username string) *mExamRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &ExamRepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.params != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by Expect")
	}

	if mmGetJarWords.defaultExpectation.paramPtrs == nil {
		mmGetJarWords.defaultExpectation.paramPtrs = &ExamRepositoryMockGetJarWordsParamPtrs{}
	}
	mmGetJarWords.defaultExpectation.paramPtrs.username = &username
	mmGetJarWords.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetJarWords
}

// ExpectFiltersParam3 sets up expected param filters for ExamRepository.GetJarWords
func (mmGetJarWords *mExamRepositoryMockGetJarWords) ExpectFiltersParam3(filters ...mm_service.Filter) *mExamRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &ExamRepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.params != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by Expect")
	}

	if mmGetJarWords.defaultExpectation.paramPtrs == nil {
		mmGetJarWords.defaultExpectation.paramPtrs = &ExamRepositoryMockGetJarWordsParamPtrs{}
	}
	mmGetJarWords.defaultExpectation.paramPtrs.filters = &filters
	mmGetJarWords.defaultExpectation.expectationOrigins.originFilters = minimock.CallerInfo(1)

	return mmGetJarWords
}

// Inspect accepts an inspector function that has same arguments as the ExamRepository.GetJarWords
func (mmGetJarWords *mExamRepositoryMockGetJarWords) Inspect(f func(ctx context.Context, username string, filters ...mm_service.Filter)) *mExamRepositoryMockGetJarWords {
	if mmGetJarWords.mock.inspectFuncGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("Inspect function is already set for ExamRepositoryMock.GetJarWords")
	}

	mmGetJarWords.mock.inspectFuncGetJarWords = f

	return mmGetJarWords
}

// Return sets up results that will be returned by ExamRepository.GetJarWords
func (mmGetJarWords *mExamRepositoryMockGetJarWords) Return(wa1 []models.Word, err error) *ExamRepositoryMock {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &ExamRepositoryMockGetJarWordsExpectation{mock: mmGetJarWords.mock}
	}
	mmGetJarWords.defaultExpectation.results = &ExamRepositoryMockGetJarWordsResults{wa1, err}
	mmGetJarWords.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetJarWords.mock
}

// Set uses given function f to mock the ExamRepository.GetJarWords method
func (mmGetJarWords *mExamRepositoryMockGetJarWords) Set(f func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)) *ExamRepositoryMock {
	if mmGetJarWords.defaultExpectation != nil {
		mmGetJarWords.mock.t.Fatalf("Default expectation is already set for the ExamRepository.GetJarWords method")
	}

	if len(mmGetJarWords.expectations) > 0 {
		mmGetJarWords.mock.t.Fatalf("Some expectations are already set for the ExamRepository.GetJarWords method")
	}

	mmGetJarWords.mock.funcGetJarWords = f
	mmGetJarWords.mock.funcGetJarWordsOrigin = minimock.CallerInfo(1)
	return mmGetJarWords.mock
}

// When sets expectation for the ExamRepository.GetJarWords which will trigger the result defined by the following
// Then helper
func (mmGetJarWords *mExamRepositoryMockGetJarWords) When(ctx context.Context, username string, filters ...mm_service.Filter) *ExamRepositoryMockGetJarWordsExpectation {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("ExamRepositoryMock.GetJarWords mock is already set by Set")
	}

	expectation := &ExamRepositoryMockGetJarWordsExpectation{
		mock:               mmGetJarWords.mock,
		params:             &ExamRepositoryMockGetJarWordsParams{ctx, username, filters},
		expectationOrigins: ExamRepositoryMockGetJarWordsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetJarWords.expectations = append(mmGetJarWords.expectations, expectation)
	return expectation
}

// Then sets up ExamRepository.GetJarWords return parameters for the expectation previously defined by the When method
func (e *ExamRepositoryMockGetJarWordsExpectation) Then(wa1 []models.Word, err error) *ExamRepositoryMock {
	e.results = &ExamRepositoryMockGetJarWordsResults{wa1, err}
	return e.mock
}

// Times sets number of times ExamRepository.GetJarWords should be invoked
func (mmGetJarWords *mExamRepositoryMockGetJarWords) Times(n uint64) *mExamRepositoryMockGetJarWords {
	if n == 0 {
		mmGetJarWords.mock.t.Fatalf("Times of ExamRepositoryMock.GetJarWords mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetJarWords.expectedInvocations, n)
	mmGetJarWords.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetJarWords
}

func (mmGetJarWords *mExamRepositoryMockGetJarWords) invocationsDone() bool {
	if len(mmGetJarWords.expectations) == 0 && mmGetJarWords.defaultExpectation == nil && mmGetJarWords.mock.funcGetJarWords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetJarWords.mock.afterGetJarWordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetJarWords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetJarWords implements mm_service.ExamRepository
func (mmGetJarWords *ExamRepositoryMock) GetJarWords(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error) {
	mm_atomic.AddUint64(&mmGetJarWords.beforeGetJarWordsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetJarWords.afterGetJarWordsCounter, 1)

	mmGetJarWords.t.Helper()

	if mmGetJarWords.inspectFuncGetJarWords != nil {
		mmGetJarWords.inspectFuncGetJarWords(ctx, username, filters...)
	}

	mm_params := ExamRepositoryMockGetJarWordsParams{ctx, username, filters}

	// Record call args
	mmGetJarWords.GetJarWordsMock.mutex.Lock()
	mmGetJarWords.GetJarWordsMock.callArgs = append(mmGetJarWords.GetJarWordsMock.callArgs, &mm_params)
	mmGetJarWords.GetJarWordsMock.mutex.Unlock()

	for _, e := range mmGetJarWords.GetJarWordsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmGetJarWords.GetJarWordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetJarWords.GetJarWordsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetJarWords.GetJarWordsMock.defaultExpectation.params
		mm_want_ptrs := mmGetJarWords.GetJarWordsMock.defaultExpectation.paramPtrs

		mm_got := ExamRepositoryMockGetJarWordsParams{ctx, username, filters}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetJarWords.t.Errorf("ExamRepositoryMock.GetJarWords got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetJarWords.t.Errorf("ExamRepositoryMock.GetJarWords got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.filters != nil && !minimock.Equal(*mm_want_ptrs.filters, mm_got.filters) {
				mmGetJarWords.t.Errorf("ExamRepositoryMock.GetJarWords got unexpected parameter filters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.originFilters, *mm_want_ptrs.filters, mm_got.filters, minimock.Diff(*mm_want_ptrs.filters, mm_got.filters))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetJarWords.t.Errorf("ExamRepositoryMock.GetJarWords got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetJarWords.GetJarWordsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetJarWords.t.Fatal("No results are set for the ExamRepositoryMock.GetJarWords")
		}
		return (*mm_results).wa1, (*mm_results).err
	}
	if mmGetJarWords.funcGetJarWords != nil {
		return mmGetJarWords.funcGetJarWords(ctx, username, filters...)
	}
	mmGetJarWords.t.Fatalf("Unexpected call to ExamRepositoryMock.GetJarWords. %v %v %v", ctx, username, filters)
	return
}

// GetJarWordsAfterCounter returns a count of finished ExamRepositoryMock.GetJarWords invocations
func (mmGetJarWords *ExamRepositoryMock) GetJarWordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJarWords.afterGetJarWordsCounter)
}

// GetJarWordsBeforeCounter returns a count of ExamRepositoryMock.GetJarWords invocations
func (mmGetJarWords *ExamRepositoryMock) GetJarWordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJarWords.beforeGetJarWordsCounter)
}

// Calls returns a list of arguments used in each call to ExamRepositoryMock.GetJarWords.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetJarWords *mExamRepositoryMockGetJarWords) Calls() []*ExamRepositoryMockGetJarWordsParams {
	mmGetJarWords.mutex.RLock()

	argCopy := make([]*ExamRepositoryMockGetJarWordsParams, len(mmGetJarWords.callArgs))
	copy(argCopy, mmGetJarWords.callArgs)

	mmGetJarWords.mutex.RUnlock()

	return argCopy
}

// MinimockGetJarWordsDone returns true if the count of the GetJarWords invocations corresponds
// the number of defined expectations
func (m *ExamRepositoryMock) MinimockGetJarWordsDone() bool {
	if m.GetJarWordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetJarWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetJarWordsMock.invocationsDone()
}

// MinimockGetJarWordsInspect logs each unmet expectation
func (m *ExamRepositoryMock) MinimockGetJarWordsInspect() {
	for _, e := range m.GetJarWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetJarWords at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetJarWordsCounter := mm_atomic.LoadUint64(&m.afterGetJarWordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetJarWordsMock.defaultExpectation != nil && afterGetJarWordsCounter < 1 {
		if m.GetJarWordsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetJarWords at\n%s", m.GetJarWordsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetJarWords at\n%s with params: %#v", m.GetJarWordsMock.defaultExpectation.expectationOrigins.origin, *m.GetJarWordsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJarWords != nil && afterGetJarWordsCounter < 1 {
		m.t.Errorf("Expected call to ExamRepositoryMock.GetJarWords at\n%s", m.funcGetJarWordsOrigin)
	}

	if !m.GetJarWordsMock.invocationsDone() && afterGetJarWordsCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamRepositoryMock.GetJarWords at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetJarWordsMock.expectedInvocations), m.GetJarWordsMock.expectedInvocationsOrigin, afterGetJarWordsCounter)
	}
}

type mExamRepositoryMockGetUserWord struct {
	optional           bool
	mock               *ExamRepositoryMock
	defaultExpectation *ExamRepositoryMockGetUserWordExpectation
	expectations       []*ExamRepositoryMockGetUserWordExpectation

	callArgs []*ExamRepositoryMockGetUserWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamRepositoryMockGetUserWordExpectation specifies expectation struct of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordExpectation struct {
	mock               *ExamRepositoryMock
	params             *ExamRepositoryMockGetUserWordParams
	paramPtrs          *ExamRepositoryMockGetUserWordParamPtrs
	expectationOrigins ExamRepositoryMockGetUserWordExpectationOrigins
	results            *ExamRepositoryMockGetUserWordResults
	returnOrigin       string
	Counter            uint64
}

// ExamRepositoryMockGetUserWordParams contains parameters of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordParams struct {
	ctx      context.Context
	wordID   string
	username string
}

// ExamRepositoryMockGetUserWordParamPtrs contains pointers to parameters of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordParamPtrs struct {
	ctx      *context.Context
	wordID   *string
	username *string
}

// ExamRepositoryMockGetUserWordResults contains results of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordResults struct {
	up1 *models.UserWord
	err error
}

// ExamRepositoryMockGetUserWordOrigins contains origins of expectations of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordExpectationOrigins struct {
	origin         string
	originCtx      string
	originWordID   string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Optional() *mExamRepositoryMockGetUserWord {
	mmGetUserWord.optional = true
	return mmGetUserWord
}

// Expect sets up expected params for ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Expect(ctx context.Context, wordID string, username string) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.paramPtrs != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by ExpectParams functions")
	}

	mmGetUserWord.defaultExpectation.params = &ExamRepositoryMockGetUserWordParams{ctx, wordID, username}
	mmGetUserWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserWord.expectations {
		if minimock.Equal(e.params, mmGetUserWord.defaultExpectation.params) {
			mmGetUserWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserWord.defaultExpectation.params)
		}
	}

	return mmGetUserWord
}

// ExpectCtxParam1 sets up expected param ctx for ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) ExpectCtxParam1(ctx context.Context) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.params != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Expect")
	}

	if mmGetUserWord.defaultExpectation.paramPtrs == nil {
		mmGetUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockGetUserWordParamPtrs{}
	}
	mmGetUserWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserWord
}

// ExpectWordIDParam2 sets up expected param wordID for ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) ExpectWordIDParam2(wordID string) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.params != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Expect")
	}

	if mmGetUserWord.defaultExpectation.paramPtrs == nil {
		mmGetUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockGetUserWordParamPtrs{}
	}
	mmGetUserWord.defaultExpectation.paramPtrs.wordID = &wordID
	mmGetUserWord.defaultExpectation.expectationOrigins.originWordID = minimock.CallerInfo(1)

	return mmGetUserWord
}

// ExpectUsernameParam3 sets up expected param username for ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) ExpectUsernameParam3(username string) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.params != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Expect")
	}

	if mmGetUserWord.defaultExpectation.paramPtrs == nil {
		mmGetUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockGetUserWordParamPtrs{}
	}
	mmGetUserWord.defaultExpectation.paramPtrs.username = &username
	mmGetUserWord.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserWord
}

// Inspect accepts an inspector function that has same arguments as the ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Inspect(f func(ctx context.Context, wordID string, username string)) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.inspectFuncGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("Inspect function is already set for ExamRepositoryMock.GetUserWord")
	}

	mmGetUserWord.mock.inspectFuncGetUserWord = f

	return mmGetUserWord
}

// Return sets up results that will be returned by ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Return(up1 *models.UserWord, err error) *ExamRepositoryMock {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{mock: mmGetUserWord.mock}
	}
	mmGetUserWord.defaultExpectation.results = &ExamRepositoryMockGetUserWordResults{up1, err}
	mmGetUserWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserWord.mock
}

// Set uses given function f to mock the ExamRepository.GetUserWord method
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Set(f func(ctx context.Context, wordID string, username string) (up1 *models.UserWord, err error)) *ExamRepositoryMock {
	if mmGetUserWord.defaultExpectation != nil {
		mmGetUserWord.mock.t.Fatalf("Default expectation is already set for the ExamRepository.GetUserWord method")
	}

	if len(mmGetUserWord.expectations) > 0 {
		mmGetUserWord.mock.t.Fatalf("Some expectations are already set for the ExamRepository.GetUserWord method")
	}

	mmGetUserWord.mock.funcGetUserWord = f
	mmGetUserWord.mock.funcGetUserWordOrigin = minimock.CallerInfo(1)
	return mmGetUserWord.mock
}

// When sets expectation for the ExamRepository.GetUserWord which will trigger the result defined by the following
// Then helper
func (mmGetUserWord *mExamRepositoryMockGetUserWord) When(ctx context.Context, wordID string, username string) *ExamRepositoryMockGetUserWordExpectation {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	expectation := &ExamRepositoryMockGetUserWordExpectation{
		mock:               mmGetUserWord.mock,
		params:             &ExamRepositoryMockGetUserWordParams{ctx, wordID, username},
		expectationOrigins: ExamRepositoryMockGetUserWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserWord.expectations = append(mmGetUserWord.expectations, expectation)
	return expectation
}

// Then sets up ExamRepository.GetUserWord return parameters for the expectation previously defined by the When method
func (e *ExamRepositoryMockGetUserWordExpectation) Then(up1 *models.UserWord, err error) *ExamRepositoryMock {
	e.results = &ExamRepositoryMockGetUserWordResults{up1, err}
	return e.mock
}

// Times sets number of times ExamRepository.GetUserWord should be invoked
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Times(n uint64) *mExamRepositoryMockGetUserWord {
	if n == 0 {
		mmGetUserWord.mock.t.Fatalf("Times of ExamRepositoryMock.GetUserWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserWord.expectedInvocations, n)
	mmGetUserWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserWord
}

func (mmGetUserWord *mExamRepositoryMockGetUserWord) invocationsDone() bool {
	if len(mmGetUserWord.expectations) == 0 && mmGetUserWord.defaultExpectation == nil && mmGetUserWord.mock.funcGetUserWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserWord.mock.afterGetUserWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserWord implements mm_service.ExamRepository
func (mmGetUserWord *ExamRepositoryMock) GetUserWord(ctx context.Context, wordID string, username string) (up1 *models.UserWord, err error) {
	mm_atomic.AddUint64(&mmGetUserWord.beforeGetUserWordCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserWord.afterGetUserWordCounter, 1)

	mmGetUserWord.t.Helper()

	if mmGetUserWord.inspectFuncGetUserWord != nil {
		mmGetUserWord.inspectFuncGetUserWord(ctx, wordID, username)
	}

	mm_params := ExamRepositoryMockGetUserWordParams{ctx, wordID, username}

	// Record call args
	mmGetUserWord.GetUserWordMock.mutex.Lock()
	mmGetUserWord.GetUserWordMock.callArgs = append(mmGetUserWord.GetUserWordMock.callArgs, &mm_params)
	mmGetUserWord.GetUserWordMock.mutex.Unlock()

	for _, e := range mmGetUserWord.GetUserWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserWord.GetUserWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserWord.GetUserWordMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserWord.GetUserWordMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserWord.GetUserWordMock.defaultExpectation.paramPtrs

		mm_got := ExamRepositoryMockGetUserWordParams{ctx, wordID, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserWord.t.Errorf("ExamRepositoryMock.GetUserWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wordID != nil && !minimock.Equal(*mm_want_ptrs.wordID, mm_got.wordID) {
				mmGetUserWord.t.Errorf("ExamRepositoryMock.GetUserWord got unexpected parameter wordID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.originWordID, *mm_want_ptrs.wordID, mm_got.wordID, minimock.Diff(*mm_want_ptrs.wordID, mm_got.wordID))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserWord.t.Errorf("ExamRepositoryMock.GetUserWord got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserWord.t.Errorf("ExamRepositoryMock.GetUserWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserWord.GetUserWordMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserWord.t.Fatal("No results are set for the ExamRepositoryMock.GetUserWord")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserWord.funcGetUserWord != nil {
		return mmGetUserWord.funcGetUserWord(ctx, wordID, username)
	}
	mmGetUserWord.t.Fatalf("Unexpected call to ExamRepositoryMock.GetUserWord. %v %v %v", ctx, wordID, username)
	return
}

// GetUserWordAfterCounter returns a count of finished ExamRepositoryMock.GetUserWord invocations
func (mmGetUserWord *ExamRepositoryMock) GetUserWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWord.afterGetUserWordCounter)
}

// GetUserWordBeforeCounter returns a count of ExamRepositoryMock.GetUserWord invocations
func (mmGetUserWord *ExamRepositoryMock) GetUserWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWord.beforeGetUserWordCounter)
}

// Calls returns a list of arguments used in each call to ExamRepositoryMock.GetUserWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Calls() []*ExamRepositoryMockGetUserWordParams {
	mmGetUserWord.mutex.RLock()

	argCopy := make([]*ExamRepositoryMockGetUserWordParams, len(mmGetUserWord.callArgs))
	copy(argCopy, mmGetUserWord.callArgs)

	mmGetUserWord.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserWordDone returns true if the count of the GetUserWord invocations corresponds
// the number of defined expectations
func (m *ExamRepositoryMock) MinimockGetUserWordDone() bool {
	if m.GetUserWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserWordMock.invocationsDone()
}

// MinimockGetUserWordInspect logs each unmet expectation
func (m *ExamRepositoryMock) MinimockGetUserWordInspect() {
	for _, e := range m.GetUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserWordCounter := mm_atomic.LoadUint64(&m.afterGetUserWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserWordMock.defaultExpectation != nil && afterGetUserWordCounter < 1 {
		if m.GetUserWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWord at\n%s", m.GetUserWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWord at\n%s with params: %#v", m.GetUserWordMock.defaultExpectation.expectationOrigins.origin, *m.GetUserWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserWord != nil && afterGetUserWordCounter < 1 {
		m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWord at\n%s", m.funcGetUserWordOrigin)
	}

	if !m.GetUserWordMock.invocationsDone() && afterGetUserWordCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamRepositoryMock.GetUserWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserWordMock.expectedInvocations), m.GetUserWordMock.expectedInvocationsOrigin, afterGetUserWordCounter)
	}
}

type mExamRepositoryMockGetWordByID struct {
	optional           bool
	mock               *ExamRepositoryMock
	defaultExpectation *ExamRepositoryMockGetWordByIDExpectation
	expectations       []*ExamRepositoryMockGetWordByIDExpectation

	callArgs []*ExamRepositoryMockGetWordByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamRepositoryMockGetWordByIDExpectation specifies expectation struct of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDExpectation struct {
	mock               *ExamRepositoryMock
	params             *ExamRepositoryMockGetWordByIDParams
	paramPtrs          *ExamRepositoryMockGetWordByIDParamPtrs
	expectationOrigins ExamRepositoryMockGetWordByIDExpectationOrigins
	results            *ExamRepositoryMockGetWordByIDResults
	returnOrigin       string
	Counter            uint64
}

// ExamRepositoryMockGetWordByIDParams contains parameters of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDParams struct {
	ctx context.Context
	id  string
}

// ExamRepositoryMockGetWordByIDParamPtrs contains pointers to parameters of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDParamPtrs struct {
	ctx *context.Context
	id  *string
}

// ExamRepositoryMockGetWordByIDResults contains results of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDResults struct {
	w1  models.Word
	err error
}

// ExamRepositoryMockGetWordByIDOrigins contains origins of expectations of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Optional() *mExamRepositoryMockGetWordByID {
	mmGetWordByID.optional = true
	return mmGetWordByID
}

// Expect sets up expected params for ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Expect(ctx context.Context, id string) *mExamRepositoryMockGetWordByID {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &ExamRepositoryMockGetWordByIDExpectation{}
	}

	if mmGetWordByID.defaultExpectation.paramPtrs != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by ExpectParams functions")
	}

	mmGetWordByID.defaultExpectation.params = &ExamRepositoryMockGetWordByIDParams{ctx, id}
	mmGetWordByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetWordByID.expectations {
		if minimock.Equal(e.params, mmGetWordByID.defaultExpectation.params) {
			mmGetWordByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWordByID.defaultExpectation.params)
		}
	}

	return mmGetWordByID
}

// ExpectCtxParam1 sets up expected param ctx for ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) ExpectCtxParam1(ctx context.Context) *mExamRepositoryMockGetWordByID {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &ExamRepositoryMockGetWordByIDExpectation{}
	}

	if mmGetWordByID.defaultExpectation.params != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Expect")
	}

	if mmGetWordByID.defaultExpectation.paramPtrs == nil {
		mmGetWordByID.defaultExpectation.paramPtrs = &ExamRepositoryMockGetWordByIDParamPtrs{}
	}
	mmGetWordByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetWordByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetWordByID
}

// ExpectIdParam2 sets up expected param id for ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) ExpectIdParam2(id string) *mExamRepositoryMockGetWordByID {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &ExamRepositoryMockGetWordByIDExpectation{}
	}

	if mmGetWordByID.defaultExpectation.params != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Expect")
	}

	if mmGetWordByID.defaultExpectation.paramPtrs == nil {
		mmGetWordByID.defaultExpectation.paramPtrs = &ExamRepositoryMockGetWordByIDParamPtrs{}
	}
	mmGetWordByID.defaultExpectation.paramPtrs.id = &id
	mmGetWordByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetWordByID
}

// Inspect accepts an inspector function that has same arguments as the ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Inspect(f func(ctx context.Context, id string)) *mExamRepositoryMockGetWordByID {
	if mmGetWordByID.mock.inspectFuncGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("Inspect function is already set for ExamRepositoryMock.GetWordByID")
	}

	mmGetWordByID.mock.inspectFuncGetWordByID = f

	return mmGetWordByID
}

// Return sets up results that will be returned by ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Return(w1 models.Word, err error) *ExamRepositoryMock {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &ExamRepositoryMockGetWordByIDExpectation{mock: mmGetWordByID.mock}
	}
	mmGetWordByID.defaultExpectation.results = &ExamRepositoryMockGetWordByIDResults{w1, err}
	mmGetWordByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetWordByID.mock
}

// Set uses given function f to mock the ExamRepository.GetWordByID method
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Set(f func(ctx context.Context, id string) (w1 models.Word, err error)) *ExamRepositoryMock {
	if mmGetWordByID.defaultExpectation != nil {
		mmGetWordByID.mock.t.Fatalf("Default expectation is already set for the ExamRepository.GetWordByID method")
	}

	if len(mmGetWordByID.expectations) > 0 {
		mmGetWordByID.mock.t.Fatalf("Some expectations are already set for the ExamRepository.GetWordByID method")
	}

	mmGetWordByID.mock.funcGetWordByID = f
	mmGetWordByID.mock.funcGetWordByIDOrigin = minimock.CallerInfo(1)
	return mmGetWordByID.mock
}

// When sets expectation for the ExamRepository.GetWordByID which will trigger the result defined by the following
// Then helper
func (mmGetWordByID *mExamRepositoryMockGetWordByID) When(ctx context.Context, id string) *ExamRepositoryMockGetWordByIDExpectation {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	expectation := &ExamRepositoryMockGetWordByIDExpectation{
		mock:               mmGetWordByID.mock,
		params:             &ExamRepositoryMockGetWordByIDParams{ctx, id},
		expectationOrigins: ExamRepositoryMockGetWordByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetWordByID.expectations = append(mmGetWordByID.expectations, expectation)
	return expectation
}

// Then sets up ExamRepository.GetWordByID return parameters for the expectation previously defined by the When method
func (e *ExamRepositoryMockGetWordByIDExpectation) Then(w1 models.Word, err error) *ExamRepositoryMock {
	e.results = &ExamRepositoryMockGetWordByIDResults{w1, err}
	return e.mock
}

// Times sets number of times ExamRepository.GetWordByID should be invoked
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Times(n uint64) *mExamRepositoryMockGetWordByID {
	if n == 0 {
		mmGetWordByID.mock.t.Fatalf("Times of ExamRepositoryMock.GetWordByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetWordByID.expectedInvocations, n)
	mmGetWordByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetWordByID
}

func (mmGetWordByID *mExamRepositoryMockGetWordByID) invocationsDone() bool {
	if len(mmGetWordByID.expectations) == 0 && mmGetWordByID.defaultExpectation == nil && mmGetWordByID.mock.funcGetWordByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetWordByID.mock.afterGetWordByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetWordByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetWordByID implements mm_service.ExamRepository
func (mmGetWordByID *ExamRepositoryMock) GetWordByID(ctx context.Context, id string) (w1 models.Word, err error) {
	mm_atomic.AddUint64(&mmGetWordByID.beforeGetWordByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWordByID.afterGetWordByIDCounter, 1)

	mmGetWordByID.t.Helper()

	if mmGetWordByID.inspectFuncGetWordByID != nil {
		mmGetWordByID.inspectFuncGetWordByID(ctx, id)
	}

	mm_params := ExamRepositoryMockGetWordByIDParams{ctx, id}

	// Record call args
	mmGetWordByID.GetWordByIDMock.mutex.Lock()
	mmGetWordByID.GetWordByIDMock.callArgs = append(mmGetWordByID.GetWordByIDMock.callArgs, &mm_params)
	mmGetWordByID.GetWordByIDMock.mutex.Unlock()

	for _, e := range mmGetWordByID.GetWordByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1, e.results.err
		}
	}

	if mmGetWordByID.GetWordByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWordByID.GetWordByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWordByID.GetWordByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetWordByID.GetWordByIDMock.defaultExpectation.paramPtrs

		mm_got := ExamRepositoryMockGetWordByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetWordByID.t.Errorf("ExamRepositoryMock.GetWordByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByID.GetWordByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetWordByID.t.Errorf("ExamRepositoryMock.GetWordByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByID.GetWordByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWordByID.t.Errorf("ExamRepositoryMock.GetWordByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetWordByID.GetWordByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWordByID.GetWordByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWordByID.t.Fatal("No results are set for the ExamRepositoryMock.GetWordByID")
		}
		return (*mm_results).w1, (*mm_results).err
	}
	if mmGetWordByID.funcGetWordByID != nil {
		return mmGetWordByID.funcGetWordByID(ctx, id)
	}
	mmGetWordByID.t.Fatalf("Unexpected call to ExamRepositoryMock.GetWordByID. %v %v", ctx, id)
	return
}

// GetWordByIDAfterCounter returns a count of finished ExamRepositoryMock.GetWordByID invocations
func (mmGetWordByID *ExamRepositoryMock) GetWordByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByID.afterGetWordByIDCounter)
}

// GetWordByIDBeforeCounter returns a count of ExamRepositoryMock.GetWordByID invocations
func (mmGetWordByID *ExamRepositoryMock) GetWordByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByID.beforeGetWordByIDCounter)
}

// Calls returns a list of arguments used in each call to ExamRepositoryMock.GetWordByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Calls() []*ExamRepositoryMockGetWordByIDParams {
	mmGetWordByID.mutex.RLock()

	argCopy := make([]*ExamRepositoryMockGetWordByIDParams, len(mmGetWordByID.callArgs))
	copy(argCopy, mmGetWordByID.callArgs)

	mmGetWordByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetWordByIDDone returns true if the count of the GetWordByID invocations corresponds
// the number of defined expectations
func (m *ExamRepositoryMock) MinimockGetWordByIDDone() bool {
	if m.GetWordByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetWordByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetWordByIDMock.invocationsDone()
}

// MinimockGetWordByIDInspect logs each unmet expectation
func (m *ExamRepositoryMock) MinimockGetWordByIDInspect() {
	for _, e := range m.GetWordByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetWordByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetWordByIDCounter := mm_atomic.LoadUint64(&m.afterGetWordByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetWordByIDMock.defaultExpectation != nil && afterGetWordByIDCounter < 1 {
		if m.GetWordByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetWordByID at\n%s", m.GetWordByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetWordByID at\n%s with params: %#v", m.GetWordByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetWordByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWordByID != nil && afterGetWordByIDCounter < 1 {
		m.t.Errorf("Expected call to ExamRepositoryMock.GetWordByID at\n%s", m.funcGetWordByIDOrigin)
	}

	if !m.GetWordByIDMock.invocationsDone() && afterGetWordByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamRepositoryMock.GetWordByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetWordByIDMock.expectedInvocations), m.GetWordByIDMock.expectedInvocationsOrigin, afterGetWordByIDCounter)
	}
}

type mExamRepositoryMockUpdateUserWord struct {
	optional           bool
	mock               *ExamRepositoryMock
	defaultExpectation *ExamRepositoryMockUpdateUserWordExpectation
	expectations       []*ExamRepositoryMockUpdateUserWordExpectation

	callArgs []*ExamRepositoryMockUpdateUserWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamRepositoryMockUpdateUserWordExpectation specifies expectation struct of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordExpectation struct {
	mock               *ExamRepositoryMock
	params             *ExamRepositoryMockUpdateUserWordParams
	paramPtrs          *ExamRepositoryMockUpdateUserWordParamPtrs
	expectationOrigins ExamRepositoryMockUpdateUserWordExpectationOrigins
	results            *ExamRepositoryMockUpdateUserWordResults
	returnOrigin       string
	Counter            uint64
}

// ExamRepositoryMockUpdateUserWordParams contains parameters of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordParams struct {
	ctx      context.Context
	userWord *models.UserWord
}

// ExamRepositoryMockUpdateUserWordParamPtrs contains pointers to parameters of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordParamPtrs struct {
	ctx      *context.Context
	userWord **models.UserWord
}

// ExamRepositoryMockUpdateUserWordResults contains results of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordResults struct {
	err error
}

// ExamRepositoryMockUpdateUserWordOrigins contains origins of expectations of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserWord string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Optional() *mExamRepositoryMockUpdateUserWord {
	mmUpdateUserWord.optional = true
	return mmUpdateUserWord
}

// Expect sets up expected params for ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Expect(ctx context.Context, userWord *models.UserWord) *mExamRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &ExamRepositoryMockUpdateUserWordExpectation{}
	}

	if mmUpdateUserWord.defaultExpectation.paramPtrs != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by ExpectParams functions")
	}

	mmUpdateUserWord.defaultExpectation.params = &ExamRepositoryMockUpdateUserWordParams{ctx, userWord}
	mmUpdateUserWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUserWord.expectations {
		if minimock.Equal(e.params, mmUpdateUserWord.defaultExpectation.params) {
			mmUpdateUserWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUserWord.defaultExpectation.params)
		}
	}

	return mmUpdateUserWord
}

// ExpectCtxParam1 sets up expected param ctx for ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) ExpectCtxParam1(ctx context.Context) *mExamRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &ExamRepositoryMockUpdateUserWordExpectation{}
	}

	if mmUpdateUserWord.defaultExpectation.params != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Expect")
	}

	if mmUpdateUserWord.defaultExpectation.paramPtrs == nil {
		mmUpdateUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockUpdateUserWordParamPtrs{}
	}
	mmUpdateUserWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUserWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUserWord
}

// ExpectUserWordParam2 sets up expected param userWord for ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) ExpectUserWordParam2(userWord *models.UserWord) *mExamRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &ExamRepositoryMockUpdateUserWordExpectation{}
	}

	if mmUpdateUserWord.defaultExpectation.params != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Expect")
	}

	if mmUpdateUserWord.defaultExpectation.paramPtrs == nil {
		mmUpdateUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockUpdateUserWordParamPtrs{}
	}
	mmUpdateUserWord.defaultExpectation.paramPtrs.userWord = &userWord
	mmUpdateUserWord.defaultExpectation.expectationOrigins.originUserWord = minimock.CallerInfo(1)

	return mmUpdateUserWord
}

// Inspect accepts an inspector function that has same arguments as the ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Inspect(f func(ctx context.Context, userWord *models.UserWord)) *mExamRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.inspectFuncUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("Inspect function is already set for ExamRepositoryMock.UpdateUserWord")
	}

	mmUpdateUserWord.mock.inspectFuncUpdateUserWord = f

	return mmUpdateUserWord
}

// Return sets up results that will be returned by ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Return(err error) *ExamRepositoryMock {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &ExamRepositoryMockUpdateUserWordExpectation{mock: mmUpdateUserWord.mock}
	}
	mmUpdateUserWord.defaultExpectation.results = &ExamRepositoryMockUpdateUserWordResults{err}
	mmUpdateUserWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUserWord.mock
}

// Set uses given function f to mock the ExamRepository.UpdateUserWord method
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Set(f func(ctx context.Context, userWord *models.UserWord) (err error)) *ExamRepositoryMock {
	if mmUpdateUserWord.defaultExpectation != nil {
		mmUpdateUserWord.mock.t.Fatalf("Default expectation is already set for the ExamRepository.UpdateUserWord method")
	}

	if len(mmUpdateUserWord.expectations) > 0 {
		mmUpdateUserWord.mock.t.Fatalf("Some expectations are already set for the ExamRepository.UpdateUserWord method")
	}

	mmUpdateUserWord.mock.funcUpdateUserWord = f
	mmUpdateUserWord.mock.funcUpdateUserWordOrigin = minimock.CallerInfo(1)
	return mmUpdateUserWord.mock
}

// When sets expectation for the ExamRepository.UpdateUserWord which will trigger the result defined by the following
// Then helper
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) When(ctx context.Context, userWord *models.UserWord) *ExamRepositoryMockUpdateUserWordExpectation {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	expectation := &ExamRepositoryMockUpdateUserWordExpectation{
		mock:               mmUpdateUserWord.mock,
		params:             &ExamRepositoryMockUpdateUserWordParams{ctx, userWord},
		expectationOrigins: ExamRepositoryMockUpdateUserWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUserWord.expectations = append(mmUpdateUserWord.expectations, expectation)
	return expectation
}

// Then sets up ExamRepository.UpdateUserWord return parameters for the expectation previously defined by the When method
func (e *ExamRepositoryMockUpdateUserWordExpectation) Then(err error) *ExamRepositoryMock {
	e.results = &ExamRepositoryMockUpdateUserWordResults{err}
	return e.mock
}

// Times sets number of times ExamRepository.UpdateUserWord should be invoked
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Times(n uint64) *mExamRepositoryMockUpdateUserWord {
	if n == 0 {
		mmUpdateUserWord.mock.t.Fatalf("Times of ExamRepositoryMock.UpdateUserWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUserWord.expectedInvocations, n)
	mmUpdateUserWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserWord
}

func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) invocationsDone() bool {
	if len(mmUpdateUserWord.expectations) == 0 && mmUpdateUserWord.defaultExpectation == nil && mmUpdateUserWord.mock.funcUpdateUserWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUserWord.mock.afterUpdateUserWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUserWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUserWord implements mm_service.ExamRepository
func (mmUpdateUserWord *ExamRepositoryMock) UpdateUserWord(ctx context.Context, userWord *models.UserWord) (err error) {
	mm_atomic.AddUint64(&mmUpdateUserWord.beforeUpdateUserWordCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUserWord.afterUpdateUserWordCounter, 1)

	mmUpdateUserWord.t.Helper()

	if mmUpdateUserWord.inspectFuncUpdateUserWord != nil {
		mmUpdateUserWord.inspectFuncUpdateUserWord(ctx, userWord)
	}

	mm_params := ExamRepositoryMockUpdateUserWordParams{ctx, userWord}

	// Record call args
	mmUpdateUserWord.UpdateUserWordMock.mutex.Lock()
	mmUpdateUserWord.UpdateUserWordMock.callArgs = append(mmUpdateUserWord.UpdateUserWordMock.callArgs, &mm_params)
	mmUpdateUserWord.UpdateUserWordMock.mutex.Unlock()

	for _, e := range mmUpdateUserWord.UpdateUserWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUserWord.UpdateUserWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.paramPtrs

		mm_got := ExamRepositoryMockUpdateUserWordParams{ctx, userWord}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUserWord.t.Errorf("ExamRepositoryMock.UpdateUserWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userWord != nil && !minimock.Equal(*mm_want_ptrs.userWord, mm_got.userWord) {
				mmUpdateUserWord.t.Errorf("ExamRepositoryMock.UpdateUserWord got unexpected parameter userWord, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.expectationOrigins.originUserWord, *mm_want_ptrs.userWord, mm_got.userWord, minimock.Diff(*mm_want_ptrs.userWord, mm_got.userWord))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUserWord.t.Errorf("ExamRepositoryMock.UpdateUserWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUserWord.t.Fatal("No results are set for the ExamRepositoryMock.UpdateUserWord")
		}
		return (*mm_results).err
	}
	if mmUpdateUserWord.funcUpdateUserWord != nil {
		return mmUpdateUserWord.funcUpdateUserWord(ctx, userWord)
	}
	mmUpdateUserWord.t.Fatalf("Unexpected call to ExamRepositoryMock.UpdateUserWord. %v %v", ctx, userWord)
	return
}

// UpdateUserWordAfterCounter returns a count of finished ExamRepositoryMock.UpdateUserWord invocations
func (mmUpdateUserWord *ExamRepositoryMock) UpdateUserWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserWord.afterUpdateUserWordCounter)
}

// UpdateUserWordBeforeCounter returns a count of ExamRepositoryMock.UpdateUserWord invocations
func (mmUpdateUserWord *ExamRepositoryMock) UpdateUserWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserWord.beforeUpdateUserWordCounter)
}

// Calls returns a list of arguments used in each call to ExamRepositoryMock.UpdateUserWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Calls() []*ExamRepositoryMockUpdateUserWordParams {
	mmUpdateUserWord.mutex.RLock()

	argCopy := make([]*ExamRepositoryMockUpdateUserWordParams, len(mmUpdateUserWord.callArgs))
	copy(argCopy, mmUpdateUserWord.callArgs)

	mmUpdateUserWord.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserWordDone returns true if the count of the UpdateUserWord invocations corresponds
// the number of defined expectations
func (m *ExamRepositoryMock) MinimockUpdateUserWordDone() bool {
	if m.UpdateUserWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserWordMock.invocationsDone()
}

// MinimockUpdateUserWordInspect logs each unmet expectation
func (m *ExamRepositoryMock) MinimockUpdateUserWordInspect() {
	for _, e := range m.UpdateUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamRepositoryMock.UpdateUserWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserWordCounter := mm_atomic.LoadUint64(&m.afterUpdateUserWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserWordMock.defaultExpectation != nil && afterUpdateUserWordCounter < 1 {
		if m.UpdateUserWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamRepositoryMock.UpdateUserWord at\n%s", m.UpdateUserWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamRepositoryMock.UpdateUserWord at\n%s with params: %#v", m.UpdateUserWordMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserWord != nil && afterUpdateUserWordCounter < 1 {
		m.t.Errorf("Expected call to ExamRepositoryMock.UpdateUserWord at\n%s", m.funcUpdateUserWordOrigin)
	}

	if !m.UpdateUserWordMock.invocationsDone() && afterUpdateUserWordCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamRepositoryMock.UpdateUserWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserWordMock.expectedInvocations), m.UpdateUserWordMock.expectedInvocationsOrigin, afterUpdateUserWordCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExamRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetJarWordsInspect()

			m.MinimockGetUserWordInspect()

			m.MinimockGetWordByIDInspect()

			m.MinimockUpdateUserWordInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExamRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExamRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetJarWordsDone() &&
		m.MinimockGetUserWordDone() &&
		m.MinimockGetWordByIDDone() &&
		m.MinimockUpdateUserWordDone()
}
