// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/service.ExamRepository -o exam_repository_mock.go -n ExamRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
	mm_service "github.com/maisiq/go-words-jar/internal/service"
)

// ExamRepositoryMock implements mm_service.ExamRepository
type ExamRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetUserWord          func(ctx context.Context, wordID string, username string) (up1 *models.UserWord, err error)
	funcGetUserWordOrigin    string
	inspectFuncGetUserWord   func(ctx context.Context, wordID string, username string)
	afterGetUserWordCounter  uint64
	beforeGetUserWordCounter uint64
	GetUserWordMock          mExamRepositoryMockGetUserWord

	funcGetUserWords          func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)
	funcGetUserWordsOrigin    string
	inspectFuncGetUserWords   func(ctx context.Context, username string, filters ...mm_service.Filter)
	afterGetUserWordsCounter  uint64
	beforeGetUserWordsCounter uint64
	GetUserWordsMock          mExamRepositoryMockGetUserWords

	funcGetWordByID          func(ctx context.Context, id string) (w1 models.Word, err error)
	funcGetWordByIDOrigin    string
	inspectFuncGetWordByID   func(ctx context.Context, id string)
	afterGetWordByIDCounter  uint64
	beforeGetWordByIDCounter uint64
	GetWordByIDMock          mExamRepositoryMockGetWordByID

	funcUpdateUserWord          func(ctx context.Context, userWord *models.UserWord) (err error)
	funcUpdateUserWordOrigin    string
	inspectFuncUpdateUserWord   func(ctx context.Context, userWord *models.UserWord)
	afterUpdateUserWordCounter  uint64
	beforeUpdateUserWordCounter uint64
	UpdateUserWordMock          mExamRepositoryMockUpdateUserWord
}

// NewExamRepositoryMock returns a mock for mm_service.ExamRepository
func NewExamRepositoryMock(t minimock.Tester) *ExamRepositoryMock {
	m := &ExamRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetUserWordMock = mExamRepositoryMockGetUserWord{mock: m}
	m.GetUserWordMock.callArgs = []*ExamRepositoryMockGetUserWordParams{}

	m.GetUserWordsMock = mExamRepositoryMockGetUserWords{mock: m}
	m.GetUserWordsMock.callArgs = []*ExamRepositoryMockGetUserWordsParams{}

	m.GetWordByIDMock = mExamRepositoryMockGetWordByID{mock: m}
	m.GetWordByIDMock.callArgs = []*ExamRepositoryMockGetWordByIDParams{}

	m.UpdateUserWordMock = mExamRepositoryMockUpdateUserWord{mock: m}
	m.UpdateUserWordMock.callArgs = []*ExamRepositoryMockUpdateUserWordParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mExamRepositoryMockGetUserWord struct {
	optional           bool
	mock               *ExamRepositoryMock
	defaultExpectation *ExamRepositoryMockGetUserWordExpectation
	expectations       []*ExamRepositoryMockGetUserWordExpectation

	callArgs []*ExamRepositoryMockGetUserWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamRepositoryMockGetUserWordExpectation specifies expectation struct of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordExpectation struct {
	mock               *ExamRepositoryMock
	params             *ExamRepositoryMockGetUserWordParams
	paramPtrs          *ExamRepositoryMockGetUserWordParamPtrs
	expectationOrigins ExamRepositoryMockGetUserWordExpectationOrigins
	results            *ExamRepositoryMockGetUserWordResults
	returnOrigin       string
	Counter            uint64
}

// ExamRepositoryMockGetUserWordParams contains parameters of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordParams struct {
	ctx      context.Context
	wordID   string
	username string
}

// ExamRepositoryMockGetUserWordParamPtrs contains pointers to parameters of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordParamPtrs struct {
	ctx      *context.Context
	wordID   *string
	username *string
}

// ExamRepositoryMockGetUserWordResults contains results of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordResults struct {
	up1 *models.UserWord
	err error
}

// ExamRepositoryMockGetUserWordOrigins contains origins of expectations of the ExamRepository.GetUserWord
type ExamRepositoryMockGetUserWordExpectationOrigins struct {
	origin         string
	originCtx      string
	originWordID   string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Optional() *mExamRepositoryMockGetUserWord {
	mmGetUserWord.optional = true
	return mmGetUserWord
}

// Expect sets up expected params for ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Expect(ctx context.Context, wordID string, username string) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.paramPtrs != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by ExpectParams functions")
	}

	mmGetUserWord.defaultExpectation.params = &ExamRepositoryMockGetUserWordParams{ctx, wordID, username}
	mmGetUserWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserWord.expectations {
		if minimock.Equal(e.params, mmGetUserWord.defaultExpectation.params) {
			mmGetUserWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserWord.defaultExpectation.params)
		}
	}

	return mmGetUserWord
}

// ExpectCtxParam1 sets up expected param ctx for ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) ExpectCtxParam1(ctx context.Context) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.params != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Expect")
	}

	if mmGetUserWord.defaultExpectation.paramPtrs == nil {
		mmGetUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockGetUserWordParamPtrs{}
	}
	mmGetUserWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserWord
}

// ExpectWordIDParam2 sets up expected param wordID for ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) ExpectWordIDParam2(wordID string) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.params != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Expect")
	}

	if mmGetUserWord.defaultExpectation.paramPtrs == nil {
		mmGetUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockGetUserWordParamPtrs{}
	}
	mmGetUserWord.defaultExpectation.paramPtrs.wordID = &wordID
	mmGetUserWord.defaultExpectation.expectationOrigins.originWordID = minimock.CallerInfo(1)

	return mmGetUserWord
}

// ExpectUsernameParam3 sets up expected param username for ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) ExpectUsernameParam3(username string) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{}
	}

	if mmGetUserWord.defaultExpectation.params != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Expect")
	}

	if mmGetUserWord.defaultExpectation.paramPtrs == nil {
		mmGetUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockGetUserWordParamPtrs{}
	}
	mmGetUserWord.defaultExpectation.paramPtrs.username = &username
	mmGetUserWord.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserWord
}

// Inspect accepts an inspector function that has same arguments as the ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Inspect(f func(ctx context.Context, wordID string, username string)) *mExamRepositoryMockGetUserWord {
	if mmGetUserWord.mock.inspectFuncGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("Inspect function is already set for ExamRepositoryMock.GetUserWord")
	}

	mmGetUserWord.mock.inspectFuncGetUserWord = f

	return mmGetUserWord
}

// Return sets up results that will be returned by ExamRepository.GetUserWord
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Return(up1 *models.UserWord, err error) *ExamRepositoryMock {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	if mmGetUserWord.defaultExpectation == nil {
		mmGetUserWord.defaultExpectation = &ExamRepositoryMockGetUserWordExpectation{mock: mmGetUserWord.mock}
	}
	mmGetUserWord.defaultExpectation.results = &ExamRepositoryMockGetUserWordResults{up1, err}
	mmGetUserWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserWord.mock
}

// Set uses given function f to mock the ExamRepository.GetUserWord method
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Set(f func(ctx context.Context, wordID string, username string) (up1 *models.UserWord, err error)) *ExamRepositoryMock {
	if mmGetUserWord.defaultExpectation != nil {
		mmGetUserWord.mock.t.Fatalf("Default expectation is already set for the ExamRepository.GetUserWord method")
	}

	if len(mmGetUserWord.expectations) > 0 {
		mmGetUserWord.mock.t.Fatalf("Some expectations are already set for the ExamRepository.GetUserWord method")
	}

	mmGetUserWord.mock.funcGetUserWord = f
	mmGetUserWord.mock.funcGetUserWordOrigin = minimock.CallerInfo(1)
	return mmGetUserWord.mock
}

// When sets expectation for the ExamRepository.GetUserWord which will trigger the result defined by the following
// Then helper
func (mmGetUserWord *mExamRepositoryMockGetUserWord) When(ctx context.Context, wordID string, username string) *ExamRepositoryMockGetUserWordExpectation {
	if mmGetUserWord.mock.funcGetUserWord != nil {
		mmGetUserWord.mock.t.Fatalf("ExamRepositoryMock.GetUserWord mock is already set by Set")
	}

	expectation := &ExamRepositoryMockGetUserWordExpectation{
		mock:               mmGetUserWord.mock,
		params:             &ExamRepositoryMockGetUserWordParams{ctx, wordID, username},
		expectationOrigins: ExamRepositoryMockGetUserWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserWord.expectations = append(mmGetUserWord.expectations, expectation)
	return expectation
}

// Then sets up ExamRepository.GetUserWord return parameters for the expectation previously defined by the When method
func (e *ExamRepositoryMockGetUserWordExpectation) Then(up1 *models.UserWord, err error) *ExamRepositoryMock {
	e.results = &ExamRepositoryMockGetUserWordResults{up1, err}
	return e.mock
}

// Times sets number of times ExamRepository.GetUserWord should be invoked
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Times(n uint64) *mExamRepositoryMockGetUserWord {
	if n == 0 {
		mmGetUserWord.mock.t.Fatalf("Times of ExamRepositoryMock.GetUserWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserWord.expectedInvocations, n)
	mmGetUserWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserWord
}

func (mmGetUserWord *mExamRepositoryMockGetUserWord) invocationsDone() bool {
	if len(mmGetUserWord.expectations) == 0 && mmGetUserWord.defaultExpectation == nil && mmGetUserWord.mock.funcGetUserWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserWord.mock.afterGetUserWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserWord implements mm_service.ExamRepository
func (mmGetUserWord *ExamRepositoryMock) GetUserWord(ctx context.Context, wordID string, username string) (up1 *models.UserWord, err error) {
	mm_atomic.AddUint64(&mmGetUserWord.beforeGetUserWordCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserWord.afterGetUserWordCounter, 1)

	mmGetUserWord.t.Helper()

	if mmGetUserWord.inspectFuncGetUserWord != nil {
		mmGetUserWord.inspectFuncGetUserWord(ctx, wordID, username)
	}

	mm_params := ExamRepositoryMockGetUserWordParams{ctx, wordID, username}

	// Record call args
	mmGetUserWord.GetUserWordMock.mutex.Lock()
	mmGetUserWord.GetUserWordMock.callArgs = append(mmGetUserWord.GetUserWordMock.callArgs, &mm_params)
	mmGetUserWord.GetUserWordMock.mutex.Unlock()

	for _, e := range mmGetUserWord.GetUserWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserWord.GetUserWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserWord.GetUserWordMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserWord.GetUserWordMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserWord.GetUserWordMock.defaultExpectation.paramPtrs

		mm_got := ExamRepositoryMockGetUserWordParams{ctx, wordID, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserWord.t.Errorf("ExamRepositoryMock.GetUserWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wordID != nil && !minimock.Equal(*mm_want_ptrs.wordID, mm_got.wordID) {
				mmGetUserWord.t.Errorf("ExamRepositoryMock.GetUserWord got unexpected parameter wordID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.originWordID, *mm_want_ptrs.wordID, mm_got.wordID, minimock.Diff(*mm_want_ptrs.wordID, mm_got.wordID))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserWord.t.Errorf("ExamRepositoryMock.GetUserWord got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserWord.t.Errorf("ExamRepositoryMock.GetUserWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserWord.GetUserWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserWord.GetUserWordMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserWord.t.Fatal("No results are set for the ExamRepositoryMock.GetUserWord")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserWord.funcGetUserWord != nil {
		return mmGetUserWord.funcGetUserWord(ctx, wordID, username)
	}
	mmGetUserWord.t.Fatalf("Unexpected call to ExamRepositoryMock.GetUserWord. %v %v %v", ctx, wordID, username)
	return
}

// GetUserWordAfterCounter returns a count of finished ExamRepositoryMock.GetUserWord invocations
func (mmGetUserWord *ExamRepositoryMock) GetUserWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWord.afterGetUserWordCounter)
}

// GetUserWordBeforeCounter returns a count of ExamRepositoryMock.GetUserWord invocations
func (mmGetUserWord *ExamRepositoryMock) GetUserWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWord.beforeGetUserWordCounter)
}

// Calls returns a list of arguments used in each call to ExamRepositoryMock.GetUserWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserWord *mExamRepositoryMockGetUserWord) Calls() []*ExamRepositoryMockGetUserWordParams {
	mmGetUserWord.mutex.RLock()

	argCopy := make([]*ExamRepositoryMockGetUserWordParams, len(mmGetUserWord.callArgs))
	copy(argCopy, mmGetUserWord.callArgs)

	mmGetUserWord.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserWordDone returns true if the count of the GetUserWord invocations corresponds
// the number of defined expectations
func (m *ExamRepositoryMock) MinimockGetUserWordDone() bool {
	if m.GetUserWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserWordMock.invocationsDone()
}

// MinimockGetUserWordInspect logs each unmet expectation
func (m *ExamRepositoryMock) MinimockGetUserWordInspect() {
	for _, e := range m.GetUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserWordCounter := mm_atomic.LoadUint64(&m.afterGetUserWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserWordMock.defaultExpectation != nil && afterGetUserWordCounter < 1 {
		if m.GetUserWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWord at\n%s", m.GetUserWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWord at\n%s with params: %#v", m.GetUserWordMock.defaultExpectation.expectationOrigins.origin, *m.GetUserWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserWord != nil && afterGetUserWordCounter < 1 {
		m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWord at\n%s", m.funcGetUserWordOrigin)
	}

	if !m.GetUserWordMock.invocationsDone() && afterGetUserWordCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamRepositoryMock.GetUserWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserWordMock.expectedInvocations), m.GetUserWordMock.expectedInvocationsOrigin, afterGetUserWordCounter)
	}
}

type mExamRepositoryMockGetUserWords struct {
	optional           bool
	mock               *ExamRepositoryMock
	defaultExpectation *ExamRepositoryMockGetUserWordsExpectation
	expectations       []*ExamRepositoryMockGetUserWordsExpectation

	callArgs []*ExamRepositoryMockGetUserWordsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamRepositoryMockGetUserWordsExpectation specifies expectation struct of the ExamRepository.GetUserWords
type ExamRepositoryMockGetUserWordsExpectation struct {
	mock               *ExamRepositoryMock
	params             *ExamRepositoryMockGetUserWordsParams
	paramPtrs          *ExamRepositoryMockGetUserWordsParamPtrs
	expectationOrigins ExamRepositoryMockGetUserWordsExpectationOrigins
	results            *ExamRepositoryMockGetUserWordsResults
	returnOrigin       string
	Counter            uint64
}

// ExamRepositoryMockGetUserWordsParams contains parameters of the ExamRepository.GetUserWords
type ExamRepositoryMockGetUserWordsParams struct {
	ctx      context.Context
	username string
	filters  []mm_service.Filter
}

// ExamRepositoryMockGetUserWordsParamPtrs contains pointers to parameters of the ExamRepository.GetUserWords
type ExamRepositoryMockGetUserWordsParamPtrs struct {
	ctx      *context.Context
	username *string
	filters  *[]mm_service.Filter
}

// ExamRepositoryMockGetUserWordsResults contains results of the ExamRepository.GetUserWords
type ExamRepositoryMockGetUserWordsResults struct {
	wa1 []models.Word
	err error
}

// ExamRepositoryMockGetUserWordsOrigins contains origins of expectations of the ExamRepository.GetUserWords
type ExamRepositoryMockGetUserWordsExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originFilters  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserWords *mExamRepositoryMockGetUserWords) Optional() *mExamRepositoryMockGetUserWords {
	mmGetUserWords.optional = true
	return mmGetUserWords
}

// Expect sets up expected params for ExamRepository.GetUserWords
func (mmGetUserWords *mExamRepositoryMockGetUserWords) Expect(ctx context.Context, username string, filters ...mm_service.Filter) *mExamRepositoryMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ExamRepositoryMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.paramPtrs != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by ExpectParams functions")
	}

	mmGetUserWords.defaultExpectation.params = &ExamRepositoryMockGetUserWordsParams{ctx, username, filters}
	mmGetUserWords.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserWords.expectations {
		if minimock.Equal(e.params, mmGetUserWords.defaultExpectation.params) {
			mmGetUserWords.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserWords.defaultExpectation.params)
		}
	}

	return mmGetUserWords
}

// ExpectCtxParam1 sets up expected param ctx for ExamRepository.GetUserWords
func (mmGetUserWords *mExamRepositoryMockGetUserWords) ExpectCtxParam1(ctx context.Context) *mExamRepositoryMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ExamRepositoryMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &ExamRepositoryMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserWords.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserWords
}

// ExpectUsernameParam2 sets up expected param username for ExamRepository.GetUserWords
func (mmGetUserWords *mExamRepositoryMockGetUserWords) ExpectUsernameParam2(username string) *mExamRepositoryMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ExamRepositoryMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &ExamRepositoryMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.username = &username
	mmGetUserWords.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserWords
}

// ExpectFiltersParam3 sets up expected param filters for ExamRepository.GetUserWords
func (mmGetUserWords *mExamRepositoryMockGetUserWords) ExpectFiltersParam3(filters ...mm_service.Filter) *mExamRepositoryMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ExamRepositoryMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &ExamRepositoryMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.filters = &filters
	mmGetUserWords.defaultExpectation.expectationOrigins.originFilters = minimock.CallerInfo(1)

	return mmGetUserWords
}

// Inspect accepts an inspector function that has same arguments as the ExamRepository.GetUserWords
func (mmGetUserWords *mExamRepositoryMockGetUserWords) Inspect(f func(ctx context.Context, username string, filters ...mm_service.Filter)) *mExamRepositoryMockGetUserWords {
	if mmGetUserWords.mock.inspectFuncGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("Inspect function is already set for ExamRepositoryMock.GetUserWords")
	}

	mmGetUserWords.mock.inspectFuncGetUserWords = f

	return mmGetUserWords
}

// Return sets up results that will be returned by ExamRepository.GetUserWords
func (mmGetUserWords *mExamRepositoryMockGetUserWords) Return(wa1 []models.Word, err error) *ExamRepositoryMock {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &ExamRepositoryMockGetUserWordsExpectation{mock: mmGetUserWords.mock}
	}
	mmGetUserWords.defaultExpectation.results = &ExamRepositoryMockGetUserWordsResults{wa1, err}
	mmGetUserWords.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserWords.mock
}

// Set uses given function f to mock the ExamRepository.GetUserWords method
func (mmGetUserWords *mExamRepositoryMockGetUserWords) Set(f func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)) *ExamRepositoryMock {
	if mmGetUserWords.defaultExpectation != nil {
		mmGetUserWords.mock.t.Fatalf("Default expectation is already set for the ExamRepository.GetUserWords method")
	}

	if len(mmGetUserWords.expectations) > 0 {
		mmGetUserWords.mock.t.Fatalf("Some expectations are already set for the ExamRepository.GetUserWords method")
	}

	mmGetUserWords.mock.funcGetUserWords = f
	mmGetUserWords.mock.funcGetUserWordsOrigin = minimock.CallerInfo(1)
	return mmGetUserWords.mock
}

// When sets expectation for the ExamRepository.GetUserWords which will trigger the result defined by the following
// Then helper
func (mmGetUserWords *mExamRepositoryMockGetUserWords) When(ctx context.Context, username string, filters ...mm_service.Filter) *ExamRepositoryMockGetUserWordsExpectation {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("ExamRepositoryMock.GetUserWords mock is already set by Set")
	}

	expectation := &ExamRepositoryMockGetUserWordsExpectation{
		mock:               mmGetUserWords.mock,
		params:             &ExamRepositoryMockGetUserWordsParams{ctx, username, filters},
		expectationOrigins: ExamRepositoryMockGetUserWordsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserWords.expectations = append(mmGetUserWords.expectations, expectation)
	return expectation
}

// Then sets up ExamRepository.GetUserWords return parameters for the expectation previously defined by the When method
func (e *ExamRepositoryMockGetUserWordsExpectation) Then(wa1 []models.Word, err error) *ExamRepositoryMock {
	e.results = &ExamRepositoryMockGetUserWordsResults{wa1, err}
	return e.mock
}

// Times sets number of times ExamRepository.GetUserWords should be invoked
func (mmGetUserWords *mExamRepositoryMockGetUserWords) Times(n uint64) *mExamRepositoryMockGetUserWords {
	if n == 0 {
		mmGetUserWords.mock.t.Fatalf("Times of ExamRepositoryMock.GetUserWords mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserWords.expectedInvocations, n)
	mmGetUserWords.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserWords
}

func (mmGetUserWords *mExamRepositoryMockGetUserWords) invocationsDone() bool {
	if len(mmGetUserWords.expectations) == 0 && mmGetUserWords.defaultExpectation == nil && mmGetUserWords.mock.funcGetUserWords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserWords.mock.afterGetUserWordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserWords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserWords implements mm_service.ExamRepository
func (mmGetUserWords *ExamRepositoryMock) GetUserWords(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error) {
	mm_atomic.AddUint64(&mmGetUserWords.beforeGetUserWordsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserWords.afterGetUserWordsCounter, 1)

	mmGetUserWords.t.Helper()

	if mmGetUserWords.inspectFuncGetUserWords != nil {
		mmGetUserWords.inspectFuncGetUserWords(ctx, username, filters...)
	}

	mm_params := ExamRepositoryMockGetUserWordsParams{ctx, username, filters}

	// Record call args
	mmGetUserWords.GetUserWordsMock.mutex.Lock()
	mmGetUserWords.GetUserWordsMock.callArgs = append(mmGetUserWords.GetUserWordsMock.callArgs, &mm_params)
	mmGetUserWords.GetUserWordsMock.mutex.Unlock()

	for _, e := range mmGetUserWords.GetUserWordsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmGetUserWords.GetUserWordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserWords.GetUserWordsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserWords.GetUserWordsMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserWords.GetUserWordsMock.defaultExpectation.paramPtrs

		mm_got := ExamRepositoryMockGetUserWordsParams{ctx, username, filters}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserWords.t.Errorf("ExamRepositoryMock.GetUserWords got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserWords.t.Errorf("ExamRepositoryMock.GetUserWords got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.filters != nil && !minimock.Equal(*mm_want_ptrs.filters, mm_got.filters) {
				mmGetUserWords.t.Errorf("ExamRepositoryMock.GetUserWords got unexpected parameter filters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originFilters, *mm_want_ptrs.filters, mm_got.filters, minimock.Diff(*mm_want_ptrs.filters, mm_got.filters))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserWords.t.Errorf("ExamRepositoryMock.GetUserWords got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserWords.GetUserWordsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserWords.t.Fatal("No results are set for the ExamRepositoryMock.GetUserWords")
		}
		return (*mm_results).wa1, (*mm_results).err
	}
	if mmGetUserWords.funcGetUserWords != nil {
		return mmGetUserWords.funcGetUserWords(ctx, username, filters...)
	}
	mmGetUserWords.t.Fatalf("Unexpected call to ExamRepositoryMock.GetUserWords. %v %v %v", ctx, username, filters)
	return
}

// GetUserWordsAfterCounter returns a count of finished ExamRepositoryMock.GetUserWords invocations
func (mmGetUserWords *ExamRepositoryMock) GetUserWordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWords.afterGetUserWordsCounter)
}

// GetUserWordsBeforeCounter returns a count of ExamRepositoryMock.GetUserWords invocations
func (mmGetUserWords *ExamRepositoryMock) GetUserWordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWords.beforeGetUserWordsCounter)
}

// Calls returns a list of arguments used in each call to ExamRepositoryMock.GetUserWords.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserWords *mExamRepositoryMockGetUserWords) Calls() []*ExamRepositoryMockGetUserWordsParams {
	mmGetUserWords.mutex.RLock()

	argCopy := make([]*ExamRepositoryMockGetUserWordsParams, len(mmGetUserWords.callArgs))
	copy(argCopy, mmGetUserWords.callArgs)

	mmGetUserWords.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserWordsDone returns true if the count of the GetUserWords invocations corresponds
// the number of defined expectations
func (m *ExamRepositoryMock) MinimockGetUserWordsDone() bool {
	if m.GetUserWordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserWordsMock.invocationsDone()
}

// MinimockGetUserWordsInspect logs each unmet expectation
func (m *ExamRepositoryMock) MinimockGetUserWordsInspect() {
	for _, e := range m.GetUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWords at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserWordsCounter := mm_atomic.LoadUint64(&m.afterGetUserWordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserWordsMock.defaultExpectation != nil && afterGetUserWordsCounter < 1 {
		if m.GetUserWordsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWords at\n%s", m.GetUserWordsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWords at\n%s with params: %#v", m.GetUserWordsMock.defaultExpectation.expectationOrigins.origin, *m.GetUserWordsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserWords != nil && afterGetUserWordsCounter < 1 {
		m.t.Errorf("Expected call to ExamRepositoryMock.GetUserWords at\n%s", m.funcGetUserWordsOrigin)
	}

	if !m.GetUserWordsMock.invocationsDone() && afterGetUserWordsCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamRepositoryMock.GetUserWords at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserWordsMock.expectedInvocations), m.GetUserWordsMock.expectedInvocationsOrigin, afterGetUserWordsCounter)
	}
}

type mExamRepositoryMockGetWordByID struct {
	optional           bool
	mock               *ExamRepositoryMock
	defaultExpectation *ExamRepositoryMockGetWordByIDExpectation
	expectations       []*ExamRepositoryMockGetWordByIDExpectation

	callArgs []*ExamRepositoryMockGetWordByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamRepositoryMockGetWordByIDExpectation specifies expectation struct of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDExpectation struct {
	mock               *ExamRepositoryMock
	params             *ExamRepositoryMockGetWordByIDParams
	paramPtrs          *ExamRepositoryMockGetWordByIDParamPtrs
	expectationOrigins ExamRepositoryMockGetWordByIDExpectationOrigins
	results            *ExamRepositoryMockGetWordByIDResults
	returnOrigin       string
	Counter            uint64
}

// ExamRepositoryMockGetWordByIDParams contains parameters of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDParams struct {
	ctx context.Context
	id  string
}

// ExamRepositoryMockGetWordByIDParamPtrs contains pointers to parameters of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDParamPtrs struct {
	ctx *context.Context
	id  *string
}

// ExamRepositoryMockGetWordByIDResults contains results of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDResults struct {
	w1  models.Word
	err error
}

// ExamRepositoryMockGetWordByIDOrigins contains origins of expectations of the ExamRepository.GetWordByID
type ExamRepositoryMockGetWordByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Optional() *mExamRepositoryMockGetWordByID {
	mmGetWordByID.optional = true
	return mmGetWordByID
}

// Expect sets up expected params for ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Expect(ctx context.Context, id string) *mExamRepositoryMockGetWordByID {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &ExamRepositoryMockGetWordByIDExpectation{}
	}

	if mmGetWordByID.defaultExpectation.paramPtrs != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by ExpectParams functions")
	}

	mmGetWordByID.defaultExpectation.params = &ExamRepositoryMockGetWordByIDParams{ctx, id}
	mmGetWordByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetWordByID.expectations {
		if minimock.Equal(e.params, mmGetWordByID.defaultExpectation.params) {
			mmGetWordByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWordByID.defaultExpectation.params)
		}
	}

	return mmGetWordByID
}

// ExpectCtxParam1 sets up expected param ctx for ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) ExpectCtxParam1(ctx context.Context) *mExamRepositoryMockGetWordByID {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &ExamRepositoryMockGetWordByIDExpectation{}
	}

	if mmGetWordByID.defaultExpectation.params != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Expect")
	}

	if mmGetWordByID.defaultExpectation.paramPtrs == nil {
		mmGetWordByID.defaultExpectation.paramPtrs = &ExamRepositoryMockGetWordByIDParamPtrs{}
	}
	mmGetWordByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetWordByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetWordByID
}

// ExpectIdParam2 sets up expected param id for ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) ExpectIdParam2(id string) *mExamRepositoryMockGetWordByID {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &ExamRepositoryMockGetWordByIDExpectation{}
	}

	if mmGetWordByID.defaultExpectation.params != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Expect")
	}

	if mmGetWordByID.defaultExpectation.paramPtrs == nil {
		mmGetWordByID.defaultExpectation.paramPtrs = &ExamRepositoryMockGetWordByIDParamPtrs{}
	}
	mmGetWordByID.defaultExpectation.paramPtrs.id = &id
	mmGetWordByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetWordByID
}

// Inspect accepts an inspector function that has same arguments as the ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Inspect(f func(ctx context.Context, id string)) *mExamRepositoryMockGetWordByID {
	if mmGetWordByID.mock.inspectFuncGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("Inspect function is already set for ExamRepositoryMock.GetWordByID")
	}

	mmGetWordByID.mock.inspectFuncGetWordByID = f

	return mmGetWordByID
}

// Return sets up results that will be returned by ExamRepository.GetWordByID
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Return(w1 models.Word, err error) *ExamRepositoryMock {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	if mmGetWordByID.defaultExpectation == nil {
		mmGetWordByID.defaultExpectation = &ExamRepositoryMockGetWordByIDExpectation{mock: mmGetWordByID.mock}
	}
	mmGetWordByID.defaultExpectation.results = &ExamRepositoryMockGetWordByIDResults{w1, err}
	mmGetWordByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetWordByID.mock
}

// Set uses given function f to mock the ExamRepository.GetWordByID method
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Set(f func(ctx context.Context, id string) (w1 models.Word, err error)) *ExamRepositoryMock {
	if mmGetWordByID.defaultExpectation != nil {
		mmGetWordByID.mock.t.Fatalf("Default expectation is already set for the ExamRepository.GetWordByID method")
	}

	if len(mmGetWordByID.expectations) > 0 {
		mmGetWordByID.mock.t.Fatalf("Some expectations are already set for the ExamRepository.GetWordByID method")
	}

	mmGetWordByID.mock.funcGetWordByID = f
	mmGetWordByID.mock.funcGetWordByIDOrigin = minimock.CallerInfo(1)
	return mmGetWordByID.mock
}

// When sets expectation for the ExamRepository.GetWordByID which will trigger the result defined by the following
// Then helper
func (mmGetWordByID *mExamRepositoryMockGetWordByID) When(ctx context.Context, id string) *ExamRepositoryMockGetWordByIDExpectation {
	if mmGetWordByID.mock.funcGetWordByID != nil {
		mmGetWordByID.mock.t.Fatalf("ExamRepositoryMock.GetWordByID mock is already set by Set")
	}

	expectation := &ExamRepositoryMockGetWordByIDExpectation{
		mock:               mmGetWordByID.mock,
		params:             &ExamRepositoryMockGetWordByIDParams{ctx, id},
		expectationOrigins: ExamRepositoryMockGetWordByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetWordByID.expectations = append(mmGetWordByID.expectations, expectation)
	return expectation
}

// Then sets up ExamRepository.GetWordByID return parameters for the expectation previously defined by the When method
func (e *ExamRepositoryMockGetWordByIDExpectation) Then(w1 models.Word, err error) *ExamRepositoryMock {
	e.results = &ExamRepositoryMockGetWordByIDResults{w1, err}
	return e.mock
}

// Times sets number of times ExamRepository.GetWordByID should be invoked
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Times(n uint64) *mExamRepositoryMockGetWordByID {
	if n == 0 {
		mmGetWordByID.mock.t.Fatalf("Times of ExamRepositoryMock.GetWordByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetWordByID.expectedInvocations, n)
	mmGetWordByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetWordByID
}

func (mmGetWordByID *mExamRepositoryMockGetWordByID) invocationsDone() bool {
	if len(mmGetWordByID.expectations) == 0 && mmGetWordByID.defaultExpectation == nil && mmGetWordByID.mock.funcGetWordByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetWordByID.mock.afterGetWordByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetWordByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetWordByID implements mm_service.ExamRepository
func (mmGetWordByID *ExamRepositoryMock) GetWordByID(ctx context.Context, id string) (w1 models.Word, err error) {
	mm_atomic.AddUint64(&mmGetWordByID.beforeGetWordByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWordByID.afterGetWordByIDCounter, 1)

	mmGetWordByID.t.Helper()

	if mmGetWordByID.inspectFuncGetWordByID != nil {
		mmGetWordByID.inspectFuncGetWordByID(ctx, id)
	}

	mm_params := ExamRepositoryMockGetWordByIDParams{ctx, id}

	// Record call args
	mmGetWordByID.GetWordByIDMock.mutex.Lock()
	mmGetWordByID.GetWordByIDMock.callArgs = append(mmGetWordByID.GetWordByIDMock.callArgs, &mm_params)
	mmGetWordByID.GetWordByIDMock.mutex.Unlock()

	for _, e := range mmGetWordByID.GetWordByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1, e.results.err
		}
	}

	if mmGetWordByID.GetWordByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWordByID.GetWordByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWordByID.GetWordByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetWordByID.GetWordByIDMock.defaultExpectation.paramPtrs

		mm_got := ExamRepositoryMockGetWordByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetWordByID.t.Errorf("ExamRepositoryMock.GetWordByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByID.GetWordByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetWordByID.t.Errorf("ExamRepositoryMock.GetWordByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetWordByID.GetWordByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWordByID.t.Errorf("ExamRepositoryMock.GetWordByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetWordByID.GetWordByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWordByID.GetWordByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWordByID.t.Fatal("No results are set for the ExamRepositoryMock.GetWordByID")
		}
		return (*mm_results).w1, (*mm_results).err
	}
	if mmGetWordByID.funcGetWordByID != nil {
		return mmGetWordByID.funcGetWordByID(ctx, id)
	}
	mmGetWordByID.t.Fatalf("Unexpected call to ExamRepositoryMock.GetWordByID. %v %v", ctx, id)
	return
}

// GetWordByIDAfterCounter returns a count of finished ExamRepositoryMock.GetWordByID invocations
func (mmGetWordByID *ExamRepositoryMock) GetWordByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByID.afterGetWordByIDCounter)
}

// GetWordByIDBeforeCounter returns a count of ExamRepositoryMock.GetWordByID invocations
func (mmGetWordByID *ExamRepositoryMock) GetWordByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWordByID.beforeGetWordByIDCounter)
}

// Calls returns a list of arguments used in each call to ExamRepositoryMock.GetWordByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWordByID *mExamRepositoryMockGetWordByID) Calls() []*ExamRepositoryMockGetWordByIDParams {
	mmGetWordByID.mutex.RLock()

	argCopy := make([]*ExamRepositoryMockGetWordByIDParams, len(mmGetWordByID.callArgs))
	copy(argCopy, mmGetWordByID.callArgs)

	mmGetWordByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetWordByIDDone returns true if the count of the GetWordByID invocations corresponds
// the number of defined expectations
func (m *ExamRepositoryMock) MinimockGetWordByIDDone() bool {
	if m.GetWordByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetWordByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetWordByIDMock.invocationsDone()
}

// MinimockGetWordByIDInspect logs each unmet expectation
func (m *ExamRepositoryMock) MinimockGetWordByIDInspect() {
	for _, e := range m.GetWordByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetWordByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetWordByIDCounter := mm_atomic.LoadUint64(&m.afterGetWordByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetWordByIDMock.defaultExpectation != nil && afterGetWordByIDCounter < 1 {
		if m.GetWordByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetWordByID at\n%s", m.GetWordByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamRepositoryMock.GetWordByID at\n%s with params: %#v", m.GetWordByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetWordByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWordByID != nil && afterGetWordByIDCounter < 1 {
		m.t.Errorf("Expected call to ExamRepositoryMock.GetWordByID at\n%s", m.funcGetWordByIDOrigin)
	}

	if !m.GetWordByIDMock.invocationsDone() && afterGetWordByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamRepositoryMock.GetWordByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetWordByIDMock.expectedInvocations), m.GetWordByIDMock.expectedInvocationsOrigin, afterGetWordByIDCounter)
	}
}

type mExamRepositoryMockUpdateUserWord struct {
	optional           bool
	mock               *ExamRepositoryMock
	defaultExpectation *ExamRepositoryMockUpdateUserWordExpectation
	expectations       []*ExamRepositoryMockUpdateUserWordExpectation

	callArgs []*ExamRepositoryMockUpdateUserWordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ExamRepositoryMockUpdateUserWordExpectation specifies expectation struct of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordExpectation struct {
	mock               *ExamRepositoryMock
	params             *ExamRepositoryMockUpdateUserWordParams
	paramPtrs          *ExamRepositoryMockUpdateUserWordParamPtrs
	expectationOrigins ExamRepositoryMockUpdateUserWordExpectationOrigins
	results            *ExamRepositoryMockUpdateUserWordResults
	returnOrigin       string
	Counter            uint64
}

// ExamRepositoryMockUpdateUserWordParams contains parameters of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordParams struct {
	ctx      context.Context
	userWord *models.UserWord
}

// ExamRepositoryMockUpdateUserWordParamPtrs contains pointers to parameters of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordParamPtrs struct {
	ctx      *context.Context
	userWord **models.UserWord
}

// ExamRepositoryMockUpdateUserWordResults contains results of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordResults struct {
	err error
}

// ExamRepositoryMockUpdateUserWordOrigins contains origins of expectations of the ExamRepository.UpdateUserWord
type ExamRepositoryMockUpdateUserWordExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserWord string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Optional() *mExamRepositoryMockUpdateUserWord {
	mmUpdateUserWord.optional = true
	return mmUpdateUserWord
}

// Expect sets up expected params for ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Expect(ctx context.Context, userWord *models.UserWord) *mExamRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &ExamRepositoryMockUpdateUserWordExpectation{}
	}

	if mmUpdateUserWord.defaultExpectation.paramPtrs != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by ExpectParams functions")
	}

	mmUpdateUserWord.defaultExpectation.params = &ExamRepositoryMockUpdateUserWordParams{ctx, userWord}
	mmUpdateUserWord.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUserWord.expectations {
		if minimock.Equal(e.params, mmUpdateUserWord.defaultExpectation.params) {
			mmUpdateUserWord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUserWord.defaultExpectation.params)
		}
	}

	return mmUpdateUserWord
}

// ExpectCtxParam1 sets up expected param ctx for ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) ExpectCtxParam1(ctx context.Context) *mExamRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &ExamRepositoryMockUpdateUserWordExpectation{}
	}

	if mmUpdateUserWord.defaultExpectation.params != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Expect")
	}

	if mmUpdateUserWord.defaultExpectation.paramPtrs == nil {
		mmUpdateUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockUpdateUserWordParamPtrs{}
	}
	mmUpdateUserWord.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUserWord.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUserWord
}

// ExpectUserWordParam2 sets up expected param userWord for ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) ExpectUserWordParam2(userWord *models.UserWord) *mExamRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &ExamRepositoryMockUpdateUserWordExpectation{}
	}

	if mmUpdateUserWord.defaultExpectation.params != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Expect")
	}

	if mmUpdateUserWord.defaultExpectation.paramPtrs == nil {
		mmUpdateUserWord.defaultExpectation.paramPtrs = &ExamRepositoryMockUpdateUserWordParamPtrs{}
	}
	mmUpdateUserWord.defaultExpectation.paramPtrs.userWord = &userWord
	mmUpdateUserWord.defaultExpectation.expectationOrigins.originUserWord = minimock.CallerInfo(1)

	return mmUpdateUserWord
}

// Inspect accepts an inspector function that has same arguments as the ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Inspect(f func(ctx context.Context, userWord *models.UserWord)) *mExamRepositoryMockUpdateUserWord {
	if mmUpdateUserWord.mock.inspectFuncUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("Inspect function is already set for ExamRepositoryMock.UpdateUserWord")
	}

	mmUpdateUserWord.mock.inspectFuncUpdateUserWord = f

	return mmUpdateUserWord
}

// Return sets up results that will be returned by ExamRepository.UpdateUserWord
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Return(err error) *ExamRepositoryMock {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	if mmUpdateUserWord.defaultExpectation == nil {
		mmUpdateUserWord.defaultExpectation = &ExamRepositoryMockUpdateUserWordExpectation{mock: mmUpdateUserWord.mock}
	}
	mmUpdateUserWord.defaultExpectation.results = &ExamRepositoryMockUpdateUserWordResults{err}
	mmUpdateUserWord.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUserWord.mock
}

// Set uses given function f to mock the ExamRepository.UpdateUserWord method
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Set(f func(ctx context.Context, userWord *models.UserWord) (err error)) *ExamRepositoryMock {
	if mmUpdateUserWord.defaultExpectation != nil {
		mmUpdateUserWord.mock.t.Fatalf("Default expectation is already set for the ExamRepository.UpdateUserWord method")
	}

	if len(mmUpdateUserWord.expectations) > 0 {
		mmUpdateUserWord.mock.t.Fatalf("Some expectations are already set for the ExamRepository.UpdateUserWord method")
	}

	mmUpdateUserWord.mock.funcUpdateUserWord = f
	mmUpdateUserWord.mock.funcUpdateUserWordOrigin = minimock.CallerInfo(1)
	return mmUpdateUserWord.mock
}

// When sets expectation for the ExamRepository.UpdateUserWord which will trigger the result defined by the following
// Then helper
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) When(ctx context.Context, userWord *models.UserWord) *ExamRepositoryMockUpdateUserWordExpectation {
	if mmUpdateUserWord.mock.funcUpdateUserWord != nil {
		mmUpdateUserWord.mock.t.Fatalf("ExamRepositoryMock.UpdateUserWord mock is already set by Set")
	}

	expectation := &ExamRepositoryMockUpdateUserWordExpectation{
		mock:               mmUpdateUserWord.mock,
		params:             &ExamRepositoryMockUpdateUserWordParams{ctx, userWord},
		expectationOrigins: ExamRepositoryMockUpdateUserWordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUserWord.expectations = append(mmUpdateUserWord.expectations, expectation)
	return expectation
}

// Then sets up ExamRepository.UpdateUserWord return parameters for the expectation previously defined by the When method
func (e *ExamRepositoryMockUpdateUserWordExpectation) Then(err error) *ExamRepositoryMock {
	e.results = &ExamRepositoryMockUpdateUserWordResults{err}
	return e.mock
}

// Times sets number of times ExamRepository.UpdateUserWord should be invoked
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Times(n uint64) *mExamRepositoryMockUpdateUserWord {
	if n == 0 {
		mmUpdateUserWord.mock.t.Fatalf("Times of ExamRepositoryMock.UpdateUserWord mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUserWord.expectedInvocations, n)
	mmUpdateUserWord.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserWord
}

func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) invocationsDone() bool {
	if len(mmUpdateUserWord.expectations) == 0 && mmUpdateUserWord.defaultExpectation == nil && mmUpdateUserWord.mock.funcUpdateUserWord == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUserWord.mock.afterUpdateUserWordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUserWord.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUserWord implements mm_service.ExamRepository
func (mmUpdateUserWord *ExamRepositoryMock) UpdateUserWord(ctx context.Context, userWord *models.UserWord) (err error) {
	mm_atomic.AddUint64(&mmUpdateUserWord.beforeUpdateUserWordCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUserWord.afterUpdateUserWordCounter, 1)

	mmUpdateUserWord.t.Helper()

	if mmUpdateUserWord.inspectFuncUpdateUserWord != nil {
		mmUpdateUserWord.inspectFuncUpdateUserWord(ctx, userWord)
	}

	mm_params := ExamRepositoryMockUpdateUserWordParams{ctx, userWord}

	// Record call args
	mmUpdateUserWord.UpdateUserWordMock.mutex.Lock()
	mmUpdateUserWord.UpdateUserWordMock.callArgs = append(mmUpdateUserWord.UpdateUserWordMock.callArgs, &mm_params)
	mmUpdateUserWord.UpdateUserWordMock.mutex.Unlock()

	for _, e := range mmUpdateUserWord.UpdateUserWordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUserWord.UpdateUserWordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.paramPtrs

		mm_got := ExamRepositoryMockUpdateUserWordParams{ctx, userWord}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUserWord.t.Errorf("ExamRepositoryMock.UpdateUserWord got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userWord != nil && !minimock.Equal(*mm_want_ptrs.userWord, mm_got.userWord) {
				mmUpdateUserWord.t.Errorf("ExamRepositoryMock.UpdateUserWord got unexpected parameter userWord, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.expectationOrigins.originUserWord, *mm_want_ptrs.userWord, mm_got.userWord, minimock.Diff(*mm_want_ptrs.userWord, mm_got.userWord))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUserWord.t.Errorf("ExamRepositoryMock.UpdateUserWord got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUserWord.UpdateUserWordMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUserWord.t.Fatal("No results are set for the ExamRepositoryMock.UpdateUserWord")
		}
		return (*mm_results).err
	}
	if mmUpdateUserWord.funcUpdateUserWord != nil {
		return mmUpdateUserWord.funcUpdateUserWord(ctx, userWord)
	}
	mmUpdateUserWord.t.Fatalf("Unexpected call to ExamRepositoryMock.UpdateUserWord. %v %v", ctx, userWord)
	return
}

// UpdateUserWordAfterCounter returns a count of finished ExamRepositoryMock.UpdateUserWord invocations
func (mmUpdateUserWord *ExamRepositoryMock) UpdateUserWordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserWord.afterUpdateUserWordCounter)
}

// UpdateUserWordBeforeCounter returns a count of ExamRepositoryMock.UpdateUserWord invocations
func (mmUpdateUserWord *ExamRepositoryMock) UpdateUserWordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserWord.beforeUpdateUserWordCounter)
}

// Calls returns a list of arguments used in each call to ExamRepositoryMock.UpdateUserWord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUserWord *mExamRepositoryMockUpdateUserWord) Calls() []*ExamRepositoryMockUpdateUserWordParams {
	mmUpdateUserWord.mutex.RLock()

	argCopy := make([]*ExamRepositoryMockUpdateUserWordParams, len(mmUpdateUserWord.callArgs))
	copy(argCopy, mmUpdateUserWord.callArgs)

	mmUpdateUserWord.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserWordDone returns true if the count of the UpdateUserWord invocations corresponds
// the number of defined expectations
func (m *ExamRepositoryMock) MinimockUpdateUserWordDone() bool {
	if m.UpdateUserWordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserWordMock.invocationsDone()
}

// MinimockUpdateUserWordInspect logs each unmet expectation
func (m *ExamRepositoryMock) MinimockUpdateUserWordInspect() {
	for _, e := range m.UpdateUserWordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExamRepositoryMock.UpdateUserWord at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserWordCounter := mm_atomic.LoadUint64(&m.afterUpdateUserWordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserWordMock.defaultExpectation != nil && afterUpdateUserWordCounter < 1 {
		if m.UpdateUserWordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ExamRepositoryMock.UpdateUserWord at\n%s", m.UpdateUserWordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ExamRepositoryMock.UpdateUserWord at\n%s with params: %#v", m.UpdateUserWordMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserWordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserWord != nil && afterUpdateUserWordCounter < 1 {
		m.t.Errorf("Expected call to ExamRepositoryMock.UpdateUserWord at\n%s", m.funcUpdateUserWordOrigin)
	}

	if !m.UpdateUserWordMock.invocationsDone() && afterUpdateUserWordCounter > 0 {
		m.t.Errorf("Expected %d calls to ExamRepositoryMock.UpdateUserWord at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserWordMock.expectedInvocations), m.UpdateUserWordMock.expectedInvocationsOrigin, afterUpdateUserWordCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExamRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetUserWordInspect()

			m.MinimockGetUserWordsInspect()

			m.MinimockGetWordByIDInspect()

			m.MinimockUpdateUserWordInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExamRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExamRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetUserWordDone() &&
		m.MinimockGetUserWordsDone() &&
		m.MinimockGetWordByIDDone() &&
		m.MinimockUpdateUserWordDone()
}
