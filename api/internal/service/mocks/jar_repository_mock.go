// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/service.JarRepository -o jar_repository_mock.go -n JarRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
	mm_service "github.com/maisiq/go-words-jar/internal/service"
)

// JarRepositoryMock implements mm_service.JarRepository
type JarRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddWordToJar          func(ctx context.Context, username string, setRating float32, words ...string) (i1 int64, err error)
	funcAddWordToJarOrigin    string
	inspectFuncAddWordToJar   func(ctx context.Context, username string, setRating float32, words ...string)
	afterAddWordToJarCounter  uint64
	beforeAddWordToJarCounter uint64
	AddWordToJarMock          mJarRepositoryMockAddWordToJar

	funcGetUserWords          func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)
	funcGetUserWordsOrigin    string
	inspectFuncGetUserWords   func(ctx context.Context, username string, filters ...mm_service.Filter)
	afterGetUserWordsCounter  uint64
	beforeGetUserWordsCounter uint64
	GetUserWordsMock          mJarRepositoryMockGetUserWords
}

// NewJarRepositoryMock returns a mock for mm_service.JarRepository
func NewJarRepositoryMock(t minimock.Tester) *JarRepositoryMock {
	m := &JarRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddWordToJarMock = mJarRepositoryMockAddWordToJar{mock: m}
	m.AddWordToJarMock.callArgs = []*JarRepositoryMockAddWordToJarParams{}

	m.GetUserWordsMock = mJarRepositoryMockGetUserWords{mock: m}
	m.GetUserWordsMock.callArgs = []*JarRepositoryMockGetUserWordsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mJarRepositoryMockAddWordToJar struct {
	optional           bool
	mock               *JarRepositoryMock
	defaultExpectation *JarRepositoryMockAddWordToJarExpectation
	expectations       []*JarRepositoryMockAddWordToJarExpectation

	callArgs []*JarRepositoryMockAddWordToJarParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JarRepositoryMockAddWordToJarExpectation specifies expectation struct of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarExpectation struct {
	mock               *JarRepositoryMock
	params             *JarRepositoryMockAddWordToJarParams
	paramPtrs          *JarRepositoryMockAddWordToJarParamPtrs
	expectationOrigins JarRepositoryMockAddWordToJarExpectationOrigins
	results            *JarRepositoryMockAddWordToJarResults
	returnOrigin       string
	Counter            uint64
}

// JarRepositoryMockAddWordToJarParams contains parameters of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarParams struct {
	ctx       context.Context
	username  string
	setRating float32
	words     []string
}

// JarRepositoryMockAddWordToJarParamPtrs contains pointers to parameters of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarParamPtrs struct {
	ctx       *context.Context
	username  *string
	setRating *float32
	words     *[]string
}

// JarRepositoryMockAddWordToJarResults contains results of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarResults struct {
	i1  int64
	err error
}

// JarRepositoryMockAddWordToJarOrigins contains origins of expectations of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarExpectationOrigins struct {
	origin          string
	originCtx       string
	originUsername  string
	originSetRating string
	originWords     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Optional() *mJarRepositoryMockAddWordToJar {
	mmAddWordToJar.optional = true
	return mmAddWordToJar
}

// Expect sets up expected params for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Expect(ctx context.Context, username string, setRating float32, words ...string) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by ExpectParams functions")
	}

	mmAddWordToJar.defaultExpectation.params = &JarRepositoryMockAddWordToJarParams{ctx, username, setRating, words}
	mmAddWordToJar.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddWordToJar.expectations {
		if minimock.Equal(e.params, mmAddWordToJar.defaultExpectation.params) {
			mmAddWordToJar.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddWordToJar.defaultExpectation.params)
		}
	}

	return mmAddWordToJar
}

// ExpectCtxParam1 sets up expected param ctx for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) ExpectCtxParam1(ctx context.Context) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &JarRepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddWordToJar.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// ExpectUsernameParam2 sets up expected param username for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) ExpectUsernameParam2(username string) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &JarRepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.username = &username
	mmAddWordToJar.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// ExpectSetRatingParam3 sets up expected param setRating for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) ExpectSetRatingParam3(setRating float32) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &JarRepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.setRating = &setRating
	mmAddWordToJar.defaultExpectation.expectationOrigins.originSetRating = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// ExpectWordsParam4 sets up expected param words for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) ExpectWordsParam4(words ...string) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &JarRepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.words = &words
	mmAddWordToJar.defaultExpectation.expectationOrigins.originWords = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// Inspect accepts an inspector function that has same arguments as the JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Inspect(f func(ctx context.Context, username string, setRating float32, words ...string)) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.inspectFuncAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("Inspect function is already set for JarRepositoryMock.AddWordToJar")
	}

	mmAddWordToJar.mock.inspectFuncAddWordToJar = f

	return mmAddWordToJar
}

// Return sets up results that will be returned by JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Return(i1 int64, err error) *JarRepositoryMock {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{mock: mmAddWordToJar.mock}
	}
	mmAddWordToJar.defaultExpectation.results = &JarRepositoryMockAddWordToJarResults{i1, err}
	mmAddWordToJar.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar.mock
}

// Set uses given function f to mock the JarRepository.AddWordToJar method
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Set(f func(ctx context.Context, username string, setRating float32, words ...string) (i1 int64, err error)) *JarRepositoryMock {
	if mmAddWordToJar.defaultExpectation != nil {
		mmAddWordToJar.mock.t.Fatalf("Default expectation is already set for the JarRepository.AddWordToJar method")
	}

	if len(mmAddWordToJar.expectations) > 0 {
		mmAddWordToJar.mock.t.Fatalf("Some expectations are already set for the JarRepository.AddWordToJar method")
	}

	mmAddWordToJar.mock.funcAddWordToJar = f
	mmAddWordToJar.mock.funcAddWordToJarOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar.mock
}

// When sets expectation for the JarRepository.AddWordToJar which will trigger the result defined by the following
// Then helper
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) When(ctx context.Context, username string, setRating float32, words ...string) *JarRepositoryMockAddWordToJarExpectation {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	expectation := &JarRepositoryMockAddWordToJarExpectation{
		mock:               mmAddWordToJar.mock,
		params:             &JarRepositoryMockAddWordToJarParams{ctx, username, setRating, words},
		expectationOrigins: JarRepositoryMockAddWordToJarExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddWordToJar.expectations = append(mmAddWordToJar.expectations, expectation)
	return expectation
}

// Then sets up JarRepository.AddWordToJar return parameters for the expectation previously defined by the When method
func (e *JarRepositoryMockAddWordToJarExpectation) Then(i1 int64, err error) *JarRepositoryMock {
	e.results = &JarRepositoryMockAddWordToJarResults{i1, err}
	return e.mock
}

// Times sets number of times JarRepository.AddWordToJar should be invoked
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Times(n uint64) *mJarRepositoryMockAddWordToJar {
	if n == 0 {
		mmAddWordToJar.mock.t.Fatalf("Times of JarRepositoryMock.AddWordToJar mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddWordToJar.expectedInvocations, n)
	mmAddWordToJar.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar
}

func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) invocationsDone() bool {
	if len(mmAddWordToJar.expectations) == 0 && mmAddWordToJar.defaultExpectation == nil && mmAddWordToJar.mock.funcAddWordToJar == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddWordToJar.mock.afterAddWordToJarCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddWordToJar.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddWordToJar implements mm_service.JarRepository
func (mmAddWordToJar *JarRepositoryMock) AddWordToJar(ctx context.Context, username string, setRating float32, words ...string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmAddWordToJar.beforeAddWordToJarCounter, 1)
	defer mm_atomic.AddUint64(&mmAddWordToJar.afterAddWordToJarCounter, 1)

	mmAddWordToJar.t.Helper()

	if mmAddWordToJar.inspectFuncAddWordToJar != nil {
		mmAddWordToJar.inspectFuncAddWordToJar(ctx, username, setRating, words...)
	}

	mm_params := JarRepositoryMockAddWordToJarParams{ctx, username, setRating, words}

	// Record call args
	mmAddWordToJar.AddWordToJarMock.mutex.Lock()
	mmAddWordToJar.AddWordToJarMock.callArgs = append(mmAddWordToJar.AddWordToJarMock.callArgs, &mm_params)
	mmAddWordToJar.AddWordToJarMock.mutex.Unlock()

	for _, e := range mmAddWordToJar.AddWordToJarMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddWordToJar.AddWordToJarMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddWordToJar.AddWordToJarMock.defaultExpectation.Counter, 1)
		mm_want := mmAddWordToJar.AddWordToJarMock.defaultExpectation.params
		mm_want_ptrs := mmAddWordToJar.AddWordToJarMock.defaultExpectation.paramPtrs

		mm_got := JarRepositoryMockAddWordToJarParams{ctx, username, setRating, words}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.setRating != nil && !minimock.Equal(*mm_want_ptrs.setRating, mm_got.setRating) {
				mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameter setRating, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originSetRating, *mm_want_ptrs.setRating, mm_got.setRating, minimock.Diff(*mm_want_ptrs.setRating, mm_got.setRating))
			}

			if mm_want_ptrs.words != nil && !minimock.Equal(*mm_want_ptrs.words, mm_got.words) {
				mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameter words, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originWords, *mm_want_ptrs.words, mm_got.words, minimock.Diff(*mm_want_ptrs.words, mm_got.words))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddWordToJar.AddWordToJarMock.defaultExpectation.results
		if mm_results == nil {
			mmAddWordToJar.t.Fatal("No results are set for the JarRepositoryMock.AddWordToJar")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddWordToJar.funcAddWordToJar != nil {
		return mmAddWordToJar.funcAddWordToJar(ctx, username, setRating, words...)
	}
	mmAddWordToJar.t.Fatalf("Unexpected call to JarRepositoryMock.AddWordToJar. %v %v %v %v", ctx, username, setRating, words)
	return
}

// AddWordToJarAfterCounter returns a count of finished JarRepositoryMock.AddWordToJar invocations
func (mmAddWordToJar *JarRepositoryMock) AddWordToJarAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordToJar.afterAddWordToJarCounter)
}

// AddWordToJarBeforeCounter returns a count of JarRepositoryMock.AddWordToJar invocations
func (mmAddWordToJar *JarRepositoryMock) AddWordToJarBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordToJar.beforeAddWordToJarCounter)
}

// Calls returns a list of arguments used in each call to JarRepositoryMock.AddWordToJar.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Calls() []*JarRepositoryMockAddWordToJarParams {
	mmAddWordToJar.mutex.RLock()

	argCopy := make([]*JarRepositoryMockAddWordToJarParams, len(mmAddWordToJar.callArgs))
	copy(argCopy, mmAddWordToJar.callArgs)

	mmAddWordToJar.mutex.RUnlock()

	return argCopy
}

// MinimockAddWordToJarDone returns true if the count of the AddWordToJar invocations corresponds
// the number of defined expectations
func (m *JarRepositoryMock) MinimockAddWordToJarDone() bool {
	if m.AddWordToJarMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddWordToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddWordToJarMock.invocationsDone()
}

// MinimockAddWordToJarInspect logs each unmet expectation
func (m *JarRepositoryMock) MinimockAddWordToJarInspect() {
	for _, e := range m.AddWordToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JarRepositoryMock.AddWordToJar at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddWordToJarCounter := mm_atomic.LoadUint64(&m.afterAddWordToJarCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddWordToJarMock.defaultExpectation != nil && afterAddWordToJarCounter < 1 {
		if m.AddWordToJarMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JarRepositoryMock.AddWordToJar at\n%s", m.AddWordToJarMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JarRepositoryMock.AddWordToJar at\n%s with params: %#v", m.AddWordToJarMock.defaultExpectation.expectationOrigins.origin, *m.AddWordToJarMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddWordToJar != nil && afterAddWordToJarCounter < 1 {
		m.t.Errorf("Expected call to JarRepositoryMock.AddWordToJar at\n%s", m.funcAddWordToJarOrigin)
	}

	if !m.AddWordToJarMock.invocationsDone() && afterAddWordToJarCounter > 0 {
		m.t.Errorf("Expected %d calls to JarRepositoryMock.AddWordToJar at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddWordToJarMock.expectedInvocations), m.AddWordToJarMock.expectedInvocationsOrigin, afterAddWordToJarCounter)
	}
}

type mJarRepositoryMockGetUserWords struct {
	optional           bool
	mock               *JarRepositoryMock
	defaultExpectation *JarRepositoryMockGetUserWordsExpectation
	expectations       []*JarRepositoryMockGetUserWordsExpectation

	callArgs []*JarRepositoryMockGetUserWordsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JarRepositoryMockGetUserWordsExpectation specifies expectation struct of the JarRepository.GetUserWords
type JarRepositoryMockGetUserWordsExpectation struct {
	mock               *JarRepositoryMock
	params             *JarRepositoryMockGetUserWordsParams
	paramPtrs          *JarRepositoryMockGetUserWordsParamPtrs
	expectationOrigins JarRepositoryMockGetUserWordsExpectationOrigins
	results            *JarRepositoryMockGetUserWordsResults
	returnOrigin       string
	Counter            uint64
}

// JarRepositoryMockGetUserWordsParams contains parameters of the JarRepository.GetUserWords
type JarRepositoryMockGetUserWordsParams struct {
	ctx      context.Context
	username string
	filters  []mm_service.Filter
}

// JarRepositoryMockGetUserWordsParamPtrs contains pointers to parameters of the JarRepository.GetUserWords
type JarRepositoryMockGetUserWordsParamPtrs struct {
	ctx      *context.Context
	username *string
	filters  *[]mm_service.Filter
}

// JarRepositoryMockGetUserWordsResults contains results of the JarRepository.GetUserWords
type JarRepositoryMockGetUserWordsResults struct {
	wa1 []models.Word
	err error
}

// JarRepositoryMockGetUserWordsOrigins contains origins of expectations of the JarRepository.GetUserWords
type JarRepositoryMockGetUserWordsExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originFilters  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserWords *mJarRepositoryMockGetUserWords) Optional() *mJarRepositoryMockGetUserWords {
	mmGetUserWords.optional = true
	return mmGetUserWords
}

// Expect sets up expected params for JarRepository.GetUserWords
func (mmGetUserWords *mJarRepositoryMockGetUserWords) Expect(ctx context.Context, username string, filters ...mm_service.Filter) *mJarRepositoryMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &JarRepositoryMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.paramPtrs != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by ExpectParams functions")
	}

	mmGetUserWords.defaultExpectation.params = &JarRepositoryMockGetUserWordsParams{ctx, username, filters}
	mmGetUserWords.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserWords.expectations {
		if minimock.Equal(e.params, mmGetUserWords.defaultExpectation.params) {
			mmGetUserWords.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserWords.defaultExpectation.params)
		}
	}

	return mmGetUserWords
}

// ExpectCtxParam1 sets up expected param ctx for JarRepository.GetUserWords
func (mmGetUserWords *mJarRepositoryMockGetUserWords) ExpectCtxParam1(ctx context.Context) *mJarRepositoryMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &JarRepositoryMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &JarRepositoryMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserWords.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserWords
}

// ExpectUsernameParam2 sets up expected param username for JarRepository.GetUserWords
func (mmGetUserWords *mJarRepositoryMockGetUserWords) ExpectUsernameParam2(username string) *mJarRepositoryMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &JarRepositoryMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &JarRepositoryMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.username = &username
	mmGetUserWords.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserWords
}

// ExpectFiltersParam3 sets up expected param filters for JarRepository.GetUserWords
func (mmGetUserWords *mJarRepositoryMockGetUserWords) ExpectFiltersParam3(filters ...mm_service.Filter) *mJarRepositoryMockGetUserWords {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &JarRepositoryMockGetUserWordsExpectation{}
	}

	if mmGetUserWords.defaultExpectation.params != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by Expect")
	}

	if mmGetUserWords.defaultExpectation.paramPtrs == nil {
		mmGetUserWords.defaultExpectation.paramPtrs = &JarRepositoryMockGetUserWordsParamPtrs{}
	}
	mmGetUserWords.defaultExpectation.paramPtrs.filters = &filters
	mmGetUserWords.defaultExpectation.expectationOrigins.originFilters = minimock.CallerInfo(1)

	return mmGetUserWords
}

// Inspect accepts an inspector function that has same arguments as the JarRepository.GetUserWords
func (mmGetUserWords *mJarRepositoryMockGetUserWords) Inspect(f func(ctx context.Context, username string, filters ...mm_service.Filter)) *mJarRepositoryMockGetUserWords {
	if mmGetUserWords.mock.inspectFuncGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("Inspect function is already set for JarRepositoryMock.GetUserWords")
	}

	mmGetUserWords.mock.inspectFuncGetUserWords = f

	return mmGetUserWords
}

// Return sets up results that will be returned by JarRepository.GetUserWords
func (mmGetUserWords *mJarRepositoryMockGetUserWords) Return(wa1 []models.Word, err error) *JarRepositoryMock {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by Set")
	}

	if mmGetUserWords.defaultExpectation == nil {
		mmGetUserWords.defaultExpectation = &JarRepositoryMockGetUserWordsExpectation{mock: mmGetUserWords.mock}
	}
	mmGetUserWords.defaultExpectation.results = &JarRepositoryMockGetUserWordsResults{wa1, err}
	mmGetUserWords.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserWords.mock
}

// Set uses given function f to mock the JarRepository.GetUserWords method
func (mmGetUserWords *mJarRepositoryMockGetUserWords) Set(f func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)) *JarRepositoryMock {
	if mmGetUserWords.defaultExpectation != nil {
		mmGetUserWords.mock.t.Fatalf("Default expectation is already set for the JarRepository.GetUserWords method")
	}

	if len(mmGetUserWords.expectations) > 0 {
		mmGetUserWords.mock.t.Fatalf("Some expectations are already set for the JarRepository.GetUserWords method")
	}

	mmGetUserWords.mock.funcGetUserWords = f
	mmGetUserWords.mock.funcGetUserWordsOrigin = minimock.CallerInfo(1)
	return mmGetUserWords.mock
}

// When sets expectation for the JarRepository.GetUserWords which will trigger the result defined by the following
// Then helper
func (mmGetUserWords *mJarRepositoryMockGetUserWords) When(ctx context.Context, username string, filters ...mm_service.Filter) *JarRepositoryMockGetUserWordsExpectation {
	if mmGetUserWords.mock.funcGetUserWords != nil {
		mmGetUserWords.mock.t.Fatalf("JarRepositoryMock.GetUserWords mock is already set by Set")
	}

	expectation := &JarRepositoryMockGetUserWordsExpectation{
		mock:               mmGetUserWords.mock,
		params:             &JarRepositoryMockGetUserWordsParams{ctx, username, filters},
		expectationOrigins: JarRepositoryMockGetUserWordsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserWords.expectations = append(mmGetUserWords.expectations, expectation)
	return expectation
}

// Then sets up JarRepository.GetUserWords return parameters for the expectation previously defined by the When method
func (e *JarRepositoryMockGetUserWordsExpectation) Then(wa1 []models.Word, err error) *JarRepositoryMock {
	e.results = &JarRepositoryMockGetUserWordsResults{wa1, err}
	return e.mock
}

// Times sets number of times JarRepository.GetUserWords should be invoked
func (mmGetUserWords *mJarRepositoryMockGetUserWords) Times(n uint64) *mJarRepositoryMockGetUserWords {
	if n == 0 {
		mmGetUserWords.mock.t.Fatalf("Times of JarRepositoryMock.GetUserWords mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserWords.expectedInvocations, n)
	mmGetUserWords.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserWords
}

func (mmGetUserWords *mJarRepositoryMockGetUserWords) invocationsDone() bool {
	if len(mmGetUserWords.expectations) == 0 && mmGetUserWords.defaultExpectation == nil && mmGetUserWords.mock.funcGetUserWords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserWords.mock.afterGetUserWordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserWords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserWords implements mm_service.JarRepository
func (mmGetUserWords *JarRepositoryMock) GetUserWords(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error) {
	mm_atomic.AddUint64(&mmGetUserWords.beforeGetUserWordsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserWords.afterGetUserWordsCounter, 1)

	mmGetUserWords.t.Helper()

	if mmGetUserWords.inspectFuncGetUserWords != nil {
		mmGetUserWords.inspectFuncGetUserWords(ctx, username, filters...)
	}

	mm_params := JarRepositoryMockGetUserWordsParams{ctx, username, filters}

	// Record call args
	mmGetUserWords.GetUserWordsMock.mutex.Lock()
	mmGetUserWords.GetUserWordsMock.callArgs = append(mmGetUserWords.GetUserWordsMock.callArgs, &mm_params)
	mmGetUserWords.GetUserWordsMock.mutex.Unlock()

	for _, e := range mmGetUserWords.GetUserWordsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmGetUserWords.GetUserWordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserWords.GetUserWordsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserWords.GetUserWordsMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserWords.GetUserWordsMock.defaultExpectation.paramPtrs

		mm_got := JarRepositoryMockGetUserWordsParams{ctx, username, filters}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserWords.t.Errorf("JarRepositoryMock.GetUserWords got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserWords.t.Errorf("JarRepositoryMock.GetUserWords got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.filters != nil && !minimock.Equal(*mm_want_ptrs.filters, mm_got.filters) {
				mmGetUserWords.t.Errorf("JarRepositoryMock.GetUserWords got unexpected parameter filters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.originFilters, *mm_want_ptrs.filters, mm_got.filters, minimock.Diff(*mm_want_ptrs.filters, mm_got.filters))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserWords.t.Errorf("JarRepositoryMock.GetUserWords got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserWords.GetUserWordsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserWords.GetUserWordsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserWords.t.Fatal("No results are set for the JarRepositoryMock.GetUserWords")
		}
		return (*mm_results).wa1, (*mm_results).err
	}
	if mmGetUserWords.funcGetUserWords != nil {
		return mmGetUserWords.funcGetUserWords(ctx, username, filters...)
	}
	mmGetUserWords.t.Fatalf("Unexpected call to JarRepositoryMock.GetUserWords. %v %v %v", ctx, username, filters)
	return
}

// GetUserWordsAfterCounter returns a count of finished JarRepositoryMock.GetUserWords invocations
func (mmGetUserWords *JarRepositoryMock) GetUserWordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWords.afterGetUserWordsCounter)
}

// GetUserWordsBeforeCounter returns a count of JarRepositoryMock.GetUserWords invocations
func (mmGetUserWords *JarRepositoryMock) GetUserWordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserWords.beforeGetUserWordsCounter)
}

// Calls returns a list of arguments used in each call to JarRepositoryMock.GetUserWords.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserWords *mJarRepositoryMockGetUserWords) Calls() []*JarRepositoryMockGetUserWordsParams {
	mmGetUserWords.mutex.RLock()

	argCopy := make([]*JarRepositoryMockGetUserWordsParams, len(mmGetUserWords.callArgs))
	copy(argCopy, mmGetUserWords.callArgs)

	mmGetUserWords.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserWordsDone returns true if the count of the GetUserWords invocations corresponds
// the number of defined expectations
func (m *JarRepositoryMock) MinimockGetUserWordsDone() bool {
	if m.GetUserWordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserWordsMock.invocationsDone()
}

// MinimockGetUserWordsInspect logs each unmet expectation
func (m *JarRepositoryMock) MinimockGetUserWordsInspect() {
	for _, e := range m.GetUserWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JarRepositoryMock.GetUserWords at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserWordsCounter := mm_atomic.LoadUint64(&m.afterGetUserWordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserWordsMock.defaultExpectation != nil && afterGetUserWordsCounter < 1 {
		if m.GetUserWordsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JarRepositoryMock.GetUserWords at\n%s", m.GetUserWordsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JarRepositoryMock.GetUserWords at\n%s with params: %#v", m.GetUserWordsMock.defaultExpectation.expectationOrigins.origin, *m.GetUserWordsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserWords != nil && afterGetUserWordsCounter < 1 {
		m.t.Errorf("Expected call to JarRepositoryMock.GetUserWords at\n%s", m.funcGetUserWordsOrigin)
	}

	if !m.GetUserWordsMock.invocationsDone() && afterGetUserWordsCounter > 0 {
		m.t.Errorf("Expected %d calls to JarRepositoryMock.GetUserWords at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserWordsMock.expectedInvocations), m.GetUserWordsMock.expectedInvocationsOrigin, afterGetUserWordsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JarRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddWordToJarInspect()

			m.MinimockGetUserWordsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JarRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JarRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddWordToJarDone() &&
		m.MinimockGetUserWordsDone()
}
