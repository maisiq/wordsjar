// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/service.JarRepository -o jar_repository_mock.go -n JarRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
	mm_service "github.com/maisiq/go-words-jar/internal/service"
)

// JarRepositoryMock implements mm_service.JarRepository
type JarRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddWordToJar          func(ctx context.Context, username string, setRating float32, words ...string) (i1 int64, err error)
	funcAddWordToJarOrigin    string
	inspectFuncAddWordToJar   func(ctx context.Context, username string, setRating float32, words ...string)
	afterAddWordToJarCounter  uint64
	beforeAddWordToJarCounter uint64
	AddWordToJarMock          mJarRepositoryMockAddWordToJar

	funcGetJarWords          func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)
	funcGetJarWordsOrigin    string
	inspectFuncGetJarWords   func(ctx context.Context, username string, filters ...mm_service.Filter)
	afterGetJarWordsCounter  uint64
	beforeGetJarWordsCounter uint64
	GetJarWordsMock          mJarRepositoryMockGetJarWords
}

// NewJarRepositoryMock returns a mock for mm_service.JarRepository
func NewJarRepositoryMock(t minimock.Tester) *JarRepositoryMock {
	m := &JarRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddWordToJarMock = mJarRepositoryMockAddWordToJar{mock: m}
	m.AddWordToJarMock.callArgs = []*JarRepositoryMockAddWordToJarParams{}

	m.GetJarWordsMock = mJarRepositoryMockGetJarWords{mock: m}
	m.GetJarWordsMock.callArgs = []*JarRepositoryMockGetJarWordsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mJarRepositoryMockAddWordToJar struct {
	optional           bool
	mock               *JarRepositoryMock
	defaultExpectation *JarRepositoryMockAddWordToJarExpectation
	expectations       []*JarRepositoryMockAddWordToJarExpectation

	callArgs []*JarRepositoryMockAddWordToJarParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JarRepositoryMockAddWordToJarExpectation specifies expectation struct of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarExpectation struct {
	mock               *JarRepositoryMock
	params             *JarRepositoryMockAddWordToJarParams
	paramPtrs          *JarRepositoryMockAddWordToJarParamPtrs
	expectationOrigins JarRepositoryMockAddWordToJarExpectationOrigins
	results            *JarRepositoryMockAddWordToJarResults
	returnOrigin       string
	Counter            uint64
}

// JarRepositoryMockAddWordToJarParams contains parameters of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarParams struct {
	ctx       context.Context
	username  string
	setRating float32
	words     []string
}

// JarRepositoryMockAddWordToJarParamPtrs contains pointers to parameters of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarParamPtrs struct {
	ctx       *context.Context
	username  *string
	setRating *float32
	words     *[]string
}

// JarRepositoryMockAddWordToJarResults contains results of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarResults struct {
	i1  int64
	err error
}

// JarRepositoryMockAddWordToJarOrigins contains origins of expectations of the JarRepository.AddWordToJar
type JarRepositoryMockAddWordToJarExpectationOrigins struct {
	origin          string
	originCtx       string
	originUsername  string
	originSetRating string
	originWords     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Optional() *mJarRepositoryMockAddWordToJar {
	mmAddWordToJar.optional = true
	return mmAddWordToJar
}

// Expect sets up expected params for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Expect(ctx context.Context, username string, setRating float32, words ...string) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by ExpectParams functions")
	}

	mmAddWordToJar.defaultExpectation.params = &JarRepositoryMockAddWordToJarParams{ctx, username, setRating, words}
	mmAddWordToJar.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddWordToJar.expectations {
		if minimock.Equal(e.params, mmAddWordToJar.defaultExpectation.params) {
			mmAddWordToJar.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddWordToJar.defaultExpectation.params)
		}
	}

	return mmAddWordToJar
}

// ExpectCtxParam1 sets up expected param ctx for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) ExpectCtxParam1(ctx context.Context) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &JarRepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddWordToJar.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// ExpectUsernameParam2 sets up expected param username for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) ExpectUsernameParam2(username string) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &JarRepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.username = &username
	mmAddWordToJar.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// ExpectSetRatingParam3 sets up expected param setRating for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) ExpectSetRatingParam3(setRating float32) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &JarRepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.setRating = &setRating
	mmAddWordToJar.defaultExpectation.expectationOrigins.originSetRating = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// ExpectWordsParam4 sets up expected param words for JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) ExpectWordsParam4(words ...string) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{}
	}

	if mmAddWordToJar.defaultExpectation.params != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Expect")
	}

	if mmAddWordToJar.defaultExpectation.paramPtrs == nil {
		mmAddWordToJar.defaultExpectation.paramPtrs = &JarRepositoryMockAddWordToJarParamPtrs{}
	}
	mmAddWordToJar.defaultExpectation.paramPtrs.words = &words
	mmAddWordToJar.defaultExpectation.expectationOrigins.originWords = minimock.CallerInfo(1)

	return mmAddWordToJar
}

// Inspect accepts an inspector function that has same arguments as the JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Inspect(f func(ctx context.Context, username string, setRating float32, words ...string)) *mJarRepositoryMockAddWordToJar {
	if mmAddWordToJar.mock.inspectFuncAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("Inspect function is already set for JarRepositoryMock.AddWordToJar")
	}

	mmAddWordToJar.mock.inspectFuncAddWordToJar = f

	return mmAddWordToJar
}

// Return sets up results that will be returned by JarRepository.AddWordToJar
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Return(i1 int64, err error) *JarRepositoryMock {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	if mmAddWordToJar.defaultExpectation == nil {
		mmAddWordToJar.defaultExpectation = &JarRepositoryMockAddWordToJarExpectation{mock: mmAddWordToJar.mock}
	}
	mmAddWordToJar.defaultExpectation.results = &JarRepositoryMockAddWordToJarResults{i1, err}
	mmAddWordToJar.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar.mock
}

// Set uses given function f to mock the JarRepository.AddWordToJar method
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Set(f func(ctx context.Context, username string, setRating float32, words ...string) (i1 int64, err error)) *JarRepositoryMock {
	if mmAddWordToJar.defaultExpectation != nil {
		mmAddWordToJar.mock.t.Fatalf("Default expectation is already set for the JarRepository.AddWordToJar method")
	}

	if len(mmAddWordToJar.expectations) > 0 {
		mmAddWordToJar.mock.t.Fatalf("Some expectations are already set for the JarRepository.AddWordToJar method")
	}

	mmAddWordToJar.mock.funcAddWordToJar = f
	mmAddWordToJar.mock.funcAddWordToJarOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar.mock
}

// When sets expectation for the JarRepository.AddWordToJar which will trigger the result defined by the following
// Then helper
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) When(ctx context.Context, username string, setRating float32, words ...string) *JarRepositoryMockAddWordToJarExpectation {
	if mmAddWordToJar.mock.funcAddWordToJar != nil {
		mmAddWordToJar.mock.t.Fatalf("JarRepositoryMock.AddWordToJar mock is already set by Set")
	}

	expectation := &JarRepositoryMockAddWordToJarExpectation{
		mock:               mmAddWordToJar.mock,
		params:             &JarRepositoryMockAddWordToJarParams{ctx, username, setRating, words},
		expectationOrigins: JarRepositoryMockAddWordToJarExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddWordToJar.expectations = append(mmAddWordToJar.expectations, expectation)
	return expectation
}

// Then sets up JarRepository.AddWordToJar return parameters for the expectation previously defined by the When method
func (e *JarRepositoryMockAddWordToJarExpectation) Then(i1 int64, err error) *JarRepositoryMock {
	e.results = &JarRepositoryMockAddWordToJarResults{i1, err}
	return e.mock
}

// Times sets number of times JarRepository.AddWordToJar should be invoked
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Times(n uint64) *mJarRepositoryMockAddWordToJar {
	if n == 0 {
		mmAddWordToJar.mock.t.Fatalf("Times of JarRepositoryMock.AddWordToJar mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddWordToJar.expectedInvocations, n)
	mmAddWordToJar.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddWordToJar
}

func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) invocationsDone() bool {
	if len(mmAddWordToJar.expectations) == 0 && mmAddWordToJar.defaultExpectation == nil && mmAddWordToJar.mock.funcAddWordToJar == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddWordToJar.mock.afterAddWordToJarCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddWordToJar.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddWordToJar implements mm_service.JarRepository
func (mmAddWordToJar *JarRepositoryMock) AddWordToJar(ctx context.Context, username string, setRating float32, words ...string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmAddWordToJar.beforeAddWordToJarCounter, 1)
	defer mm_atomic.AddUint64(&mmAddWordToJar.afterAddWordToJarCounter, 1)

	mmAddWordToJar.t.Helper()

	if mmAddWordToJar.inspectFuncAddWordToJar != nil {
		mmAddWordToJar.inspectFuncAddWordToJar(ctx, username, setRating, words...)
	}

	mm_params := JarRepositoryMockAddWordToJarParams{ctx, username, setRating, words}

	// Record call args
	mmAddWordToJar.AddWordToJarMock.mutex.Lock()
	mmAddWordToJar.AddWordToJarMock.callArgs = append(mmAddWordToJar.AddWordToJarMock.callArgs, &mm_params)
	mmAddWordToJar.AddWordToJarMock.mutex.Unlock()

	for _, e := range mmAddWordToJar.AddWordToJarMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddWordToJar.AddWordToJarMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddWordToJar.AddWordToJarMock.defaultExpectation.Counter, 1)
		mm_want := mmAddWordToJar.AddWordToJarMock.defaultExpectation.params
		mm_want_ptrs := mmAddWordToJar.AddWordToJarMock.defaultExpectation.paramPtrs

		mm_got := JarRepositoryMockAddWordToJarParams{ctx, username, setRating, words}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.setRating != nil && !minimock.Equal(*mm_want_ptrs.setRating, mm_got.setRating) {
				mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameter setRating, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originSetRating, *mm_want_ptrs.setRating, mm_got.setRating, minimock.Diff(*mm_want_ptrs.setRating, mm_got.setRating))
			}

			if mm_want_ptrs.words != nil && !minimock.Equal(*mm_want_ptrs.words, mm_got.words) {
				mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameter words, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.originWords, *mm_want_ptrs.words, mm_got.words, minimock.Diff(*mm_want_ptrs.words, mm_got.words))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddWordToJar.t.Errorf("JarRepositoryMock.AddWordToJar got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddWordToJar.AddWordToJarMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddWordToJar.AddWordToJarMock.defaultExpectation.results
		if mm_results == nil {
			mmAddWordToJar.t.Fatal("No results are set for the JarRepositoryMock.AddWordToJar")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddWordToJar.funcAddWordToJar != nil {
		return mmAddWordToJar.funcAddWordToJar(ctx, username, setRating, words...)
	}
	mmAddWordToJar.t.Fatalf("Unexpected call to JarRepositoryMock.AddWordToJar. %v %v %v %v", ctx, username, setRating, words)
	return
}

// AddWordToJarAfterCounter returns a count of finished JarRepositoryMock.AddWordToJar invocations
func (mmAddWordToJar *JarRepositoryMock) AddWordToJarAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordToJar.afterAddWordToJarCounter)
}

// AddWordToJarBeforeCounter returns a count of JarRepositoryMock.AddWordToJar invocations
func (mmAddWordToJar *JarRepositoryMock) AddWordToJarBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddWordToJar.beforeAddWordToJarCounter)
}

// Calls returns a list of arguments used in each call to JarRepositoryMock.AddWordToJar.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddWordToJar *mJarRepositoryMockAddWordToJar) Calls() []*JarRepositoryMockAddWordToJarParams {
	mmAddWordToJar.mutex.RLock()

	argCopy := make([]*JarRepositoryMockAddWordToJarParams, len(mmAddWordToJar.callArgs))
	copy(argCopy, mmAddWordToJar.callArgs)

	mmAddWordToJar.mutex.RUnlock()

	return argCopy
}

// MinimockAddWordToJarDone returns true if the count of the AddWordToJar invocations corresponds
// the number of defined expectations
func (m *JarRepositoryMock) MinimockAddWordToJarDone() bool {
	if m.AddWordToJarMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddWordToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddWordToJarMock.invocationsDone()
}

// MinimockAddWordToJarInspect logs each unmet expectation
func (m *JarRepositoryMock) MinimockAddWordToJarInspect() {
	for _, e := range m.AddWordToJarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JarRepositoryMock.AddWordToJar at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddWordToJarCounter := mm_atomic.LoadUint64(&m.afterAddWordToJarCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddWordToJarMock.defaultExpectation != nil && afterAddWordToJarCounter < 1 {
		if m.AddWordToJarMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JarRepositoryMock.AddWordToJar at\n%s", m.AddWordToJarMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JarRepositoryMock.AddWordToJar at\n%s with params: %#v", m.AddWordToJarMock.defaultExpectation.expectationOrigins.origin, *m.AddWordToJarMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddWordToJar != nil && afterAddWordToJarCounter < 1 {
		m.t.Errorf("Expected call to JarRepositoryMock.AddWordToJar at\n%s", m.funcAddWordToJarOrigin)
	}

	if !m.AddWordToJarMock.invocationsDone() && afterAddWordToJarCounter > 0 {
		m.t.Errorf("Expected %d calls to JarRepositoryMock.AddWordToJar at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddWordToJarMock.expectedInvocations), m.AddWordToJarMock.expectedInvocationsOrigin, afterAddWordToJarCounter)
	}
}

type mJarRepositoryMockGetJarWords struct {
	optional           bool
	mock               *JarRepositoryMock
	defaultExpectation *JarRepositoryMockGetJarWordsExpectation
	expectations       []*JarRepositoryMockGetJarWordsExpectation

	callArgs []*JarRepositoryMockGetJarWordsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JarRepositoryMockGetJarWordsExpectation specifies expectation struct of the JarRepository.GetJarWords
type JarRepositoryMockGetJarWordsExpectation struct {
	mock               *JarRepositoryMock
	params             *JarRepositoryMockGetJarWordsParams
	paramPtrs          *JarRepositoryMockGetJarWordsParamPtrs
	expectationOrigins JarRepositoryMockGetJarWordsExpectationOrigins
	results            *JarRepositoryMockGetJarWordsResults
	returnOrigin       string
	Counter            uint64
}

// JarRepositoryMockGetJarWordsParams contains parameters of the JarRepository.GetJarWords
type JarRepositoryMockGetJarWordsParams struct {
	ctx      context.Context
	username string
	filters  []mm_service.Filter
}

// JarRepositoryMockGetJarWordsParamPtrs contains pointers to parameters of the JarRepository.GetJarWords
type JarRepositoryMockGetJarWordsParamPtrs struct {
	ctx      *context.Context
	username *string
	filters  *[]mm_service.Filter
}

// JarRepositoryMockGetJarWordsResults contains results of the JarRepository.GetJarWords
type JarRepositoryMockGetJarWordsResults struct {
	wa1 []models.Word
	err error
}

// JarRepositoryMockGetJarWordsOrigins contains origins of expectations of the JarRepository.GetJarWords
type JarRepositoryMockGetJarWordsExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originFilters  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetJarWords *mJarRepositoryMockGetJarWords) Optional() *mJarRepositoryMockGetJarWords {
	mmGetJarWords.optional = true
	return mmGetJarWords
}

// Expect sets up expected params for JarRepository.GetJarWords
func (mmGetJarWords *mJarRepositoryMockGetJarWords) Expect(ctx context.Context, username string, filters ...mm_service.Filter) *mJarRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &JarRepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.paramPtrs != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by ExpectParams functions")
	}

	mmGetJarWords.defaultExpectation.params = &JarRepositoryMockGetJarWordsParams{ctx, username, filters}
	mmGetJarWords.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetJarWords.expectations {
		if minimock.Equal(e.params, mmGetJarWords.defaultExpectation.params) {
			mmGetJarWords.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetJarWords.defaultExpectation.params)
		}
	}

	return mmGetJarWords
}

// ExpectCtxParam1 sets up expected param ctx for JarRepository.GetJarWords
func (mmGetJarWords *mJarRepositoryMockGetJarWords) ExpectCtxParam1(ctx context.Context) *mJarRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &JarRepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.params != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by Expect")
	}

	if mmGetJarWords.defaultExpectation.paramPtrs == nil {
		mmGetJarWords.defaultExpectation.paramPtrs = &JarRepositoryMockGetJarWordsParamPtrs{}
	}
	mmGetJarWords.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetJarWords.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetJarWords
}

// ExpectUsernameParam2 sets up expected param username for JarRepository.GetJarWords
func (mmGetJarWords *mJarRepositoryMockGetJarWords) ExpectUsernameParam2(username string) *mJarRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &JarRepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.params != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by Expect")
	}

	if mmGetJarWords.defaultExpectation.paramPtrs == nil {
		mmGetJarWords.defaultExpectation.paramPtrs = &JarRepositoryMockGetJarWordsParamPtrs{}
	}
	mmGetJarWords.defaultExpectation.paramPtrs.username = &username
	mmGetJarWords.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetJarWords
}

// ExpectFiltersParam3 sets up expected param filters for JarRepository.GetJarWords
func (mmGetJarWords *mJarRepositoryMockGetJarWords) ExpectFiltersParam3(filters ...mm_service.Filter) *mJarRepositoryMockGetJarWords {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &JarRepositoryMockGetJarWordsExpectation{}
	}

	if mmGetJarWords.defaultExpectation.params != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by Expect")
	}

	if mmGetJarWords.defaultExpectation.paramPtrs == nil {
		mmGetJarWords.defaultExpectation.paramPtrs = &JarRepositoryMockGetJarWordsParamPtrs{}
	}
	mmGetJarWords.defaultExpectation.paramPtrs.filters = &filters
	mmGetJarWords.defaultExpectation.expectationOrigins.originFilters = minimock.CallerInfo(1)

	return mmGetJarWords
}

// Inspect accepts an inspector function that has same arguments as the JarRepository.GetJarWords
func (mmGetJarWords *mJarRepositoryMockGetJarWords) Inspect(f func(ctx context.Context, username string, filters ...mm_service.Filter)) *mJarRepositoryMockGetJarWords {
	if mmGetJarWords.mock.inspectFuncGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("Inspect function is already set for JarRepositoryMock.GetJarWords")
	}

	mmGetJarWords.mock.inspectFuncGetJarWords = f

	return mmGetJarWords
}

// Return sets up results that will be returned by JarRepository.GetJarWords
func (mmGetJarWords *mJarRepositoryMockGetJarWords) Return(wa1 []models.Word, err error) *JarRepositoryMock {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by Set")
	}

	if mmGetJarWords.defaultExpectation == nil {
		mmGetJarWords.defaultExpectation = &JarRepositoryMockGetJarWordsExpectation{mock: mmGetJarWords.mock}
	}
	mmGetJarWords.defaultExpectation.results = &JarRepositoryMockGetJarWordsResults{wa1, err}
	mmGetJarWords.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetJarWords.mock
}

// Set uses given function f to mock the JarRepository.GetJarWords method
func (mmGetJarWords *mJarRepositoryMockGetJarWords) Set(f func(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error)) *JarRepositoryMock {
	if mmGetJarWords.defaultExpectation != nil {
		mmGetJarWords.mock.t.Fatalf("Default expectation is already set for the JarRepository.GetJarWords method")
	}

	if len(mmGetJarWords.expectations) > 0 {
		mmGetJarWords.mock.t.Fatalf("Some expectations are already set for the JarRepository.GetJarWords method")
	}

	mmGetJarWords.mock.funcGetJarWords = f
	mmGetJarWords.mock.funcGetJarWordsOrigin = minimock.CallerInfo(1)
	return mmGetJarWords.mock
}

// When sets expectation for the JarRepository.GetJarWords which will trigger the result defined by the following
// Then helper
func (mmGetJarWords *mJarRepositoryMockGetJarWords) When(ctx context.Context, username string, filters ...mm_service.Filter) *JarRepositoryMockGetJarWordsExpectation {
	if mmGetJarWords.mock.funcGetJarWords != nil {
		mmGetJarWords.mock.t.Fatalf("JarRepositoryMock.GetJarWords mock is already set by Set")
	}

	expectation := &JarRepositoryMockGetJarWordsExpectation{
		mock:               mmGetJarWords.mock,
		params:             &JarRepositoryMockGetJarWordsParams{ctx, username, filters},
		expectationOrigins: JarRepositoryMockGetJarWordsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetJarWords.expectations = append(mmGetJarWords.expectations, expectation)
	return expectation
}

// Then sets up JarRepository.GetJarWords return parameters for the expectation previously defined by the When method
func (e *JarRepositoryMockGetJarWordsExpectation) Then(wa1 []models.Word, err error) *JarRepositoryMock {
	e.results = &JarRepositoryMockGetJarWordsResults{wa1, err}
	return e.mock
}

// Times sets number of times JarRepository.GetJarWords should be invoked
func (mmGetJarWords *mJarRepositoryMockGetJarWords) Times(n uint64) *mJarRepositoryMockGetJarWords {
	if n == 0 {
		mmGetJarWords.mock.t.Fatalf("Times of JarRepositoryMock.GetJarWords mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetJarWords.expectedInvocations, n)
	mmGetJarWords.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetJarWords
}

func (mmGetJarWords *mJarRepositoryMockGetJarWords) invocationsDone() bool {
	if len(mmGetJarWords.expectations) == 0 && mmGetJarWords.defaultExpectation == nil && mmGetJarWords.mock.funcGetJarWords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetJarWords.mock.afterGetJarWordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetJarWords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetJarWords implements mm_service.JarRepository
func (mmGetJarWords *JarRepositoryMock) GetJarWords(ctx context.Context, username string, filters ...mm_service.Filter) (wa1 []models.Word, err error) {
	mm_atomic.AddUint64(&mmGetJarWords.beforeGetJarWordsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetJarWords.afterGetJarWordsCounter, 1)

	mmGetJarWords.t.Helper()

	if mmGetJarWords.inspectFuncGetJarWords != nil {
		mmGetJarWords.inspectFuncGetJarWords(ctx, username, filters...)
	}

	mm_params := JarRepositoryMockGetJarWordsParams{ctx, username, filters}

	// Record call args
	mmGetJarWords.GetJarWordsMock.mutex.Lock()
	mmGetJarWords.GetJarWordsMock.callArgs = append(mmGetJarWords.GetJarWordsMock.callArgs, &mm_params)
	mmGetJarWords.GetJarWordsMock.mutex.Unlock()

	for _, e := range mmGetJarWords.GetJarWordsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmGetJarWords.GetJarWordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetJarWords.GetJarWordsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetJarWords.GetJarWordsMock.defaultExpectation.params
		mm_want_ptrs := mmGetJarWords.GetJarWordsMock.defaultExpectation.paramPtrs

		mm_got := JarRepositoryMockGetJarWordsParams{ctx, username, filters}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetJarWords.t.Errorf("JarRepositoryMock.GetJarWords got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetJarWords.t.Errorf("JarRepositoryMock.GetJarWords got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.filters != nil && !minimock.Equal(*mm_want_ptrs.filters, mm_got.filters) {
				mmGetJarWords.t.Errorf("JarRepositoryMock.GetJarWords got unexpected parameter filters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.originFilters, *mm_want_ptrs.filters, mm_got.filters, minimock.Diff(*mm_want_ptrs.filters, mm_got.filters))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetJarWords.t.Errorf("JarRepositoryMock.GetJarWords got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetJarWords.GetJarWordsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetJarWords.GetJarWordsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetJarWords.t.Fatal("No results are set for the JarRepositoryMock.GetJarWords")
		}
		return (*mm_results).wa1, (*mm_results).err
	}
	if mmGetJarWords.funcGetJarWords != nil {
		return mmGetJarWords.funcGetJarWords(ctx, username, filters...)
	}
	mmGetJarWords.t.Fatalf("Unexpected call to JarRepositoryMock.GetJarWords. %v %v %v", ctx, username, filters)
	return
}

// GetJarWordsAfterCounter returns a count of finished JarRepositoryMock.GetJarWords invocations
func (mmGetJarWords *JarRepositoryMock) GetJarWordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJarWords.afterGetJarWordsCounter)
}

// GetJarWordsBeforeCounter returns a count of JarRepositoryMock.GetJarWords invocations
func (mmGetJarWords *JarRepositoryMock) GetJarWordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJarWords.beforeGetJarWordsCounter)
}

// Calls returns a list of arguments used in each call to JarRepositoryMock.GetJarWords.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetJarWords *mJarRepositoryMockGetJarWords) Calls() []*JarRepositoryMockGetJarWordsParams {
	mmGetJarWords.mutex.RLock()

	argCopy := make([]*JarRepositoryMockGetJarWordsParams, len(mmGetJarWords.callArgs))
	copy(argCopy, mmGetJarWords.callArgs)

	mmGetJarWords.mutex.RUnlock()

	return argCopy
}

// MinimockGetJarWordsDone returns true if the count of the GetJarWords invocations corresponds
// the number of defined expectations
func (m *JarRepositoryMock) MinimockGetJarWordsDone() bool {
	if m.GetJarWordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetJarWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetJarWordsMock.invocationsDone()
}

// MinimockGetJarWordsInspect logs each unmet expectation
func (m *JarRepositoryMock) MinimockGetJarWordsInspect() {
	for _, e := range m.GetJarWordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JarRepositoryMock.GetJarWords at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetJarWordsCounter := mm_atomic.LoadUint64(&m.afterGetJarWordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetJarWordsMock.defaultExpectation != nil && afterGetJarWordsCounter < 1 {
		if m.GetJarWordsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JarRepositoryMock.GetJarWords at\n%s", m.GetJarWordsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JarRepositoryMock.GetJarWords at\n%s with params: %#v", m.GetJarWordsMock.defaultExpectation.expectationOrigins.origin, *m.GetJarWordsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJarWords != nil && afterGetJarWordsCounter < 1 {
		m.t.Errorf("Expected call to JarRepositoryMock.GetJarWords at\n%s", m.funcGetJarWordsOrigin)
	}

	if !m.GetJarWordsMock.invocationsDone() && afterGetJarWordsCounter > 0 {
		m.t.Errorf("Expected %d calls to JarRepositoryMock.GetJarWords at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetJarWordsMock.expectedInvocations), m.GetJarWordsMock.expectedInvocationsOrigin, afterGetJarWordsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JarRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddWordToJarInspect()

			m.MinimockGetJarWordsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JarRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JarRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddWordToJarDone() &&
		m.MinimockGetJarWordsDone()
}
