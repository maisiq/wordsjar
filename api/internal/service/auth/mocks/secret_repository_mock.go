// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/service/auth.SecretRepository -o secret_repository_mock.go -n SecretRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SecretRepositoryMock implements mm_auth.SecretRepository
type SecretRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetKID          func(ctx context.Context) (s1 string, err error)
	funcGetKIDOrigin    string
	inspectFuncGetKID   func(ctx context.Context)
	afterGetKIDCounter  uint64
	beforeGetKIDCounter uint64
	GetKIDMock          mSecretRepositoryMockGetKID

	funcPublicKeys          func(ctx context.Context) (m1 map[string]any, err error)
	funcPublicKeysOrigin    string
	inspectFuncPublicKeys   func(ctx context.Context)
	afterPublicKeysCounter  uint64
	beforePublicKeysCounter uint64
	PublicKeysMock          mSecretRepositoryMockPublicKeys

	funcSignData          func(ctx context.Context, data string) (signedData string, err error)
	funcSignDataOrigin    string
	inspectFuncSignData   func(ctx context.Context, data string)
	afterSignDataCounter  uint64
	beforeSignDataCounter uint64
	SignDataMock          mSecretRepositoryMockSignData
}

// NewSecretRepositoryMock returns a mock for mm_auth.SecretRepository
func NewSecretRepositoryMock(t minimock.Tester) *SecretRepositoryMock {
	m := &SecretRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetKIDMock = mSecretRepositoryMockGetKID{mock: m}
	m.GetKIDMock.callArgs = []*SecretRepositoryMockGetKIDParams{}

	m.PublicKeysMock = mSecretRepositoryMockPublicKeys{mock: m}
	m.PublicKeysMock.callArgs = []*SecretRepositoryMockPublicKeysParams{}

	m.SignDataMock = mSecretRepositoryMockSignData{mock: m}
	m.SignDataMock.callArgs = []*SecretRepositoryMockSignDataParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSecretRepositoryMockGetKID struct {
	optional           bool
	mock               *SecretRepositoryMock
	defaultExpectation *SecretRepositoryMockGetKIDExpectation
	expectations       []*SecretRepositoryMockGetKIDExpectation

	callArgs []*SecretRepositoryMockGetKIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SecretRepositoryMockGetKIDExpectation specifies expectation struct of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDExpectation struct {
	mock               *SecretRepositoryMock
	params             *SecretRepositoryMockGetKIDParams
	paramPtrs          *SecretRepositoryMockGetKIDParamPtrs
	expectationOrigins SecretRepositoryMockGetKIDExpectationOrigins
	results            *SecretRepositoryMockGetKIDResults
	returnOrigin       string
	Counter            uint64
}

// SecretRepositoryMockGetKIDParams contains parameters of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDParams struct {
	ctx context.Context
}

// SecretRepositoryMockGetKIDParamPtrs contains pointers to parameters of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDParamPtrs struct {
	ctx *context.Context
}

// SecretRepositoryMockGetKIDResults contains results of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDResults struct {
	s1  string
	err error
}

// SecretRepositoryMockGetKIDOrigins contains origins of expectations of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKID *mSecretRepositoryMockGetKID) Optional() *mSecretRepositoryMockGetKID {
	mmGetKID.optional = true
	return mmGetKID
}

// Expect sets up expected params for SecretRepository.GetKID
func (mmGetKID *mSecretRepositoryMockGetKID) Expect(ctx context.Context) *mSecretRepositoryMockGetKID {
	if mmGetKID.mock.funcGetKID != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Set")
	}

	if mmGetKID.defaultExpectation == nil {
		mmGetKID.defaultExpectation = &SecretRepositoryMockGetKIDExpectation{}
	}

	if mmGetKID.defaultExpectation.paramPtrs != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by ExpectParams functions")
	}

	mmGetKID.defaultExpectation.params = &SecretRepositoryMockGetKIDParams{ctx}
	mmGetKID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKID.expectations {
		if minimock.Equal(e.params, mmGetKID.defaultExpectation.params) {
			mmGetKID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKID.defaultExpectation.params)
		}
	}

	return mmGetKID
}

// ExpectCtxParam1 sets up expected param ctx for SecretRepository.GetKID
func (mmGetKID *mSecretRepositoryMockGetKID) ExpectCtxParam1(ctx context.Context) *mSecretRepositoryMockGetKID {
	if mmGetKID.mock.funcGetKID != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Set")
	}

	if mmGetKID.defaultExpectation == nil {
		mmGetKID.defaultExpectation = &SecretRepositoryMockGetKIDExpectation{}
	}

	if mmGetKID.defaultExpectation.params != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Expect")
	}

	if mmGetKID.defaultExpectation.paramPtrs == nil {
		mmGetKID.defaultExpectation.paramPtrs = &SecretRepositoryMockGetKIDParamPtrs{}
	}
	mmGetKID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKID
}

// Inspect accepts an inspector function that has same arguments as the SecretRepository.GetKID
func (mmGetKID *mSecretRepositoryMockGetKID) Inspect(f func(ctx context.Context)) *mSecretRepositoryMockGetKID {
	if mmGetKID.mock.inspectFuncGetKID != nil {
		mmGetKID.mock.t.Fatalf("Inspect function is already set for SecretRepositoryMock.GetKID")
	}

	mmGetKID.mock.inspectFuncGetKID = f

	return mmGetKID
}

// Return sets up results that will be returned by SecretRepository.GetKID
func (mmGetKID *mSecretRepositoryMockGetKID) Return(s1 string, err error) *SecretRepositoryMock {
	if mmGetKID.mock.funcGetKID != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Set")
	}

	if mmGetKID.defaultExpectation == nil {
		mmGetKID.defaultExpectation = &SecretRepositoryMockGetKIDExpectation{mock: mmGetKID.mock}
	}
	mmGetKID.defaultExpectation.results = &SecretRepositoryMockGetKIDResults{s1, err}
	mmGetKID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKID.mock
}

// Set uses given function f to mock the SecretRepository.GetKID method
func (mmGetKID *mSecretRepositoryMockGetKID) Set(f func(ctx context.Context) (s1 string, err error)) *SecretRepositoryMock {
	if mmGetKID.defaultExpectation != nil {
		mmGetKID.mock.t.Fatalf("Default expectation is already set for the SecretRepository.GetKID method")
	}

	if len(mmGetKID.expectations) > 0 {
		mmGetKID.mock.t.Fatalf("Some expectations are already set for the SecretRepository.GetKID method")
	}

	mmGetKID.mock.funcGetKID = f
	mmGetKID.mock.funcGetKIDOrigin = minimock.CallerInfo(1)
	return mmGetKID.mock
}

// When sets expectation for the SecretRepository.GetKID which will trigger the result defined by the following
// Then helper
func (mmGetKID *mSecretRepositoryMockGetKID) When(ctx context.Context) *SecretRepositoryMockGetKIDExpectation {
	if mmGetKID.mock.funcGetKID != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Set")
	}

	expectation := &SecretRepositoryMockGetKIDExpectation{
		mock:               mmGetKID.mock,
		params:             &SecretRepositoryMockGetKIDParams{ctx},
		expectationOrigins: SecretRepositoryMockGetKIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKID.expectations = append(mmGetKID.expectations, expectation)
	return expectation
}

// Then sets up SecretRepository.GetKID return parameters for the expectation previously defined by the When method
func (e *SecretRepositoryMockGetKIDExpectation) Then(s1 string, err error) *SecretRepositoryMock {
	e.results = &SecretRepositoryMockGetKIDResults{s1, err}
	return e.mock
}

// Times sets number of times SecretRepository.GetKID should be invoked
func (mmGetKID *mSecretRepositoryMockGetKID) Times(n uint64) *mSecretRepositoryMockGetKID {
	if n == 0 {
		mmGetKID.mock.t.Fatalf("Times of SecretRepositoryMock.GetKID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKID.expectedInvocations, n)
	mmGetKID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKID
}

func (mmGetKID *mSecretRepositoryMockGetKID) invocationsDone() bool {
	if len(mmGetKID.expectations) == 0 && mmGetKID.defaultExpectation == nil && mmGetKID.mock.funcGetKID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKID.mock.afterGetKIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKID implements mm_auth.SecretRepository
func (mmGetKID *SecretRepositoryMock) GetKID(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetKID.beforeGetKIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKID.afterGetKIDCounter, 1)

	mmGetKID.t.Helper()

	if mmGetKID.inspectFuncGetKID != nil {
		mmGetKID.inspectFuncGetKID(ctx)
	}

	mm_params := SecretRepositoryMockGetKIDParams{ctx}

	// Record call args
	mmGetKID.GetKIDMock.mutex.Lock()
	mmGetKID.GetKIDMock.callArgs = append(mmGetKID.GetKIDMock.callArgs, &mm_params)
	mmGetKID.GetKIDMock.mutex.Unlock()

	for _, e := range mmGetKID.GetKIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetKID.GetKIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKID.GetKIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKID.GetKIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKID.GetKIDMock.defaultExpectation.paramPtrs

		mm_got := SecretRepositoryMockGetKIDParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKID.t.Errorf("SecretRepositoryMock.GetKID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKID.GetKIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKID.t.Errorf("SecretRepositoryMock.GetKID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKID.GetKIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKID.GetKIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKID.t.Fatal("No results are set for the SecretRepositoryMock.GetKID")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetKID.funcGetKID != nil {
		return mmGetKID.funcGetKID(ctx)
	}
	mmGetKID.t.Fatalf("Unexpected call to SecretRepositoryMock.GetKID. %v", ctx)
	return
}

// GetKIDAfterCounter returns a count of finished SecretRepositoryMock.GetKID invocations
func (mmGetKID *SecretRepositoryMock) GetKIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKID.afterGetKIDCounter)
}

// GetKIDBeforeCounter returns a count of SecretRepositoryMock.GetKID invocations
func (mmGetKID *SecretRepositoryMock) GetKIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKID.beforeGetKIDCounter)
}

// Calls returns a list of arguments used in each call to SecretRepositoryMock.GetKID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKID *mSecretRepositoryMockGetKID) Calls() []*SecretRepositoryMockGetKIDParams {
	mmGetKID.mutex.RLock()

	argCopy := make([]*SecretRepositoryMockGetKIDParams, len(mmGetKID.callArgs))
	copy(argCopy, mmGetKID.callArgs)

	mmGetKID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKIDDone returns true if the count of the GetKID invocations corresponds
// the number of defined expectations
func (m *SecretRepositoryMock) MinimockGetKIDDone() bool {
	if m.GetKIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKIDMock.invocationsDone()
}

// MinimockGetKIDInspect logs each unmet expectation
func (m *SecretRepositoryMock) MinimockGetKIDInspect() {
	for _, e := range m.GetKIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SecretRepositoryMock.GetKID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKIDCounter := mm_atomic.LoadUint64(&m.afterGetKIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKIDMock.defaultExpectation != nil && afterGetKIDCounter < 1 {
		if m.GetKIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SecretRepositoryMock.GetKID at\n%s", m.GetKIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SecretRepositoryMock.GetKID at\n%s with params: %#v", m.GetKIDMock.defaultExpectation.expectationOrigins.origin, *m.GetKIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKID != nil && afterGetKIDCounter < 1 {
		m.t.Errorf("Expected call to SecretRepositoryMock.GetKID at\n%s", m.funcGetKIDOrigin)
	}

	if !m.GetKIDMock.invocationsDone() && afterGetKIDCounter > 0 {
		m.t.Errorf("Expected %d calls to SecretRepositoryMock.GetKID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKIDMock.expectedInvocations), m.GetKIDMock.expectedInvocationsOrigin, afterGetKIDCounter)
	}
}

type mSecretRepositoryMockPublicKeys struct {
	optional           bool
	mock               *SecretRepositoryMock
	defaultExpectation *SecretRepositoryMockPublicKeysExpectation
	expectations       []*SecretRepositoryMockPublicKeysExpectation

	callArgs []*SecretRepositoryMockPublicKeysParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SecretRepositoryMockPublicKeysExpectation specifies expectation struct of the SecretRepository.PublicKeys
type SecretRepositoryMockPublicKeysExpectation struct {
	mock               *SecretRepositoryMock
	params             *SecretRepositoryMockPublicKeysParams
	paramPtrs          *SecretRepositoryMockPublicKeysParamPtrs
	expectationOrigins SecretRepositoryMockPublicKeysExpectationOrigins
	results            *SecretRepositoryMockPublicKeysResults
	returnOrigin       string
	Counter            uint64
}

// SecretRepositoryMockPublicKeysParams contains parameters of the SecretRepository.PublicKeys
type SecretRepositoryMockPublicKeysParams struct {
	ctx context.Context
}

// SecretRepositoryMockPublicKeysParamPtrs contains pointers to parameters of the SecretRepository.PublicKeys
type SecretRepositoryMockPublicKeysParamPtrs struct {
	ctx *context.Context
}

// SecretRepositoryMockPublicKeysResults contains results of the SecretRepository.PublicKeys
type SecretRepositoryMockPublicKeysResults struct {
	m1  map[string]any
	err error
}

// SecretRepositoryMockPublicKeysOrigins contains origins of expectations of the SecretRepository.PublicKeys
type SecretRepositoryMockPublicKeysExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPublicKeys *mSecretRepositoryMockPublicKeys) Optional() *mSecretRepositoryMockPublicKeys {
	mmPublicKeys.optional = true
	return mmPublicKeys
}

// Expect sets up expected params for SecretRepository.PublicKeys
func (mmPublicKeys *mSecretRepositoryMockPublicKeys) Expect(ctx context.Context) *mSecretRepositoryMockPublicKeys {
	if mmPublicKeys.mock.funcPublicKeys != nil {
		mmPublicKeys.mock.t.Fatalf("SecretRepositoryMock.PublicKeys mock is already set by Set")
	}

	if mmPublicKeys.defaultExpectation == nil {
		mmPublicKeys.defaultExpectation = &SecretRepositoryMockPublicKeysExpectation{}
	}

	if mmPublicKeys.defaultExpectation.paramPtrs != nil {
		mmPublicKeys.mock.t.Fatalf("SecretRepositoryMock.PublicKeys mock is already set by ExpectParams functions")
	}

	mmPublicKeys.defaultExpectation.params = &SecretRepositoryMockPublicKeysParams{ctx}
	mmPublicKeys.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPublicKeys.expectations {
		if minimock.Equal(e.params, mmPublicKeys.defaultExpectation.params) {
			mmPublicKeys.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublicKeys.defaultExpectation.params)
		}
	}

	return mmPublicKeys
}

// ExpectCtxParam1 sets up expected param ctx for SecretRepository.PublicKeys
func (mmPublicKeys *mSecretRepositoryMockPublicKeys) ExpectCtxParam1(ctx context.Context) *mSecretRepositoryMockPublicKeys {
	if mmPublicKeys.mock.funcPublicKeys != nil {
		mmPublicKeys.mock.t.Fatalf("SecretRepositoryMock.PublicKeys mock is already set by Set")
	}

	if mmPublicKeys.defaultExpectation == nil {
		mmPublicKeys.defaultExpectation = &SecretRepositoryMockPublicKeysExpectation{}
	}

	if mmPublicKeys.defaultExpectation.params != nil {
		mmPublicKeys.mock.t.Fatalf("SecretRepositoryMock.PublicKeys mock is already set by Expect")
	}

	if mmPublicKeys.defaultExpectation.paramPtrs == nil {
		mmPublicKeys.defaultExpectation.paramPtrs = &SecretRepositoryMockPublicKeysParamPtrs{}
	}
	mmPublicKeys.defaultExpectation.paramPtrs.ctx = &ctx
	mmPublicKeys.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPublicKeys
}

// Inspect accepts an inspector function that has same arguments as the SecretRepository.PublicKeys
func (mmPublicKeys *mSecretRepositoryMockPublicKeys) Inspect(f func(ctx context.Context)) *mSecretRepositoryMockPublicKeys {
	if mmPublicKeys.mock.inspectFuncPublicKeys != nil {
		mmPublicKeys.mock.t.Fatalf("Inspect function is already set for SecretRepositoryMock.PublicKeys")
	}

	mmPublicKeys.mock.inspectFuncPublicKeys = f

	return mmPublicKeys
}

// Return sets up results that will be returned by SecretRepository.PublicKeys
func (mmPublicKeys *mSecretRepositoryMockPublicKeys) Return(m1 map[string]any, err error) *SecretRepositoryMock {
	if mmPublicKeys.mock.funcPublicKeys != nil {
		mmPublicKeys.mock.t.Fatalf("SecretRepositoryMock.PublicKeys mock is already set by Set")
	}

	if mmPublicKeys.defaultExpectation == nil {
		mmPublicKeys.defaultExpectation = &SecretRepositoryMockPublicKeysExpectation{mock: mmPublicKeys.mock}
	}
	mmPublicKeys.defaultExpectation.results = &SecretRepositoryMockPublicKeysResults{m1, err}
	mmPublicKeys.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPublicKeys.mock
}

// Set uses given function f to mock the SecretRepository.PublicKeys method
func (mmPublicKeys *mSecretRepositoryMockPublicKeys) Set(f func(ctx context.Context) (m1 map[string]any, err error)) *SecretRepositoryMock {
	if mmPublicKeys.defaultExpectation != nil {
		mmPublicKeys.mock.t.Fatalf("Default expectation is already set for the SecretRepository.PublicKeys method")
	}

	if len(mmPublicKeys.expectations) > 0 {
		mmPublicKeys.mock.t.Fatalf("Some expectations are already set for the SecretRepository.PublicKeys method")
	}

	mmPublicKeys.mock.funcPublicKeys = f
	mmPublicKeys.mock.funcPublicKeysOrigin = minimock.CallerInfo(1)
	return mmPublicKeys.mock
}

// When sets expectation for the SecretRepository.PublicKeys which will trigger the result defined by the following
// Then helper
func (mmPublicKeys *mSecretRepositoryMockPublicKeys) When(ctx context.Context) *SecretRepositoryMockPublicKeysExpectation {
	if mmPublicKeys.mock.funcPublicKeys != nil {
		mmPublicKeys.mock.t.Fatalf("SecretRepositoryMock.PublicKeys mock is already set by Set")
	}

	expectation := &SecretRepositoryMockPublicKeysExpectation{
		mock:               mmPublicKeys.mock,
		params:             &SecretRepositoryMockPublicKeysParams{ctx},
		expectationOrigins: SecretRepositoryMockPublicKeysExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPublicKeys.expectations = append(mmPublicKeys.expectations, expectation)
	return expectation
}

// Then sets up SecretRepository.PublicKeys return parameters for the expectation previously defined by the When method
func (e *SecretRepositoryMockPublicKeysExpectation) Then(m1 map[string]any, err error) *SecretRepositoryMock {
	e.results = &SecretRepositoryMockPublicKeysResults{m1, err}
	return e.mock
}

// Times sets number of times SecretRepository.PublicKeys should be invoked
func (mmPublicKeys *mSecretRepositoryMockPublicKeys) Times(n uint64) *mSecretRepositoryMockPublicKeys {
	if n == 0 {
		mmPublicKeys.mock.t.Fatalf("Times of SecretRepositoryMock.PublicKeys mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPublicKeys.expectedInvocations, n)
	mmPublicKeys.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPublicKeys
}

func (mmPublicKeys *mSecretRepositoryMockPublicKeys) invocationsDone() bool {
	if len(mmPublicKeys.expectations) == 0 && mmPublicKeys.defaultExpectation == nil && mmPublicKeys.mock.funcPublicKeys == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPublicKeys.mock.afterPublicKeysCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPublicKeys.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PublicKeys implements mm_auth.SecretRepository
func (mmPublicKeys *SecretRepositoryMock) PublicKeys(ctx context.Context) (m1 map[string]any, err error) {
	mm_atomic.AddUint64(&mmPublicKeys.beforePublicKeysCounter, 1)
	defer mm_atomic.AddUint64(&mmPublicKeys.afterPublicKeysCounter, 1)

	mmPublicKeys.t.Helper()

	if mmPublicKeys.inspectFuncPublicKeys != nil {
		mmPublicKeys.inspectFuncPublicKeys(ctx)
	}

	mm_params := SecretRepositoryMockPublicKeysParams{ctx}

	// Record call args
	mmPublicKeys.PublicKeysMock.mutex.Lock()
	mmPublicKeys.PublicKeysMock.callArgs = append(mmPublicKeys.PublicKeysMock.callArgs, &mm_params)
	mmPublicKeys.PublicKeysMock.mutex.Unlock()

	for _, e := range mmPublicKeys.PublicKeysMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmPublicKeys.PublicKeysMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublicKeys.PublicKeysMock.defaultExpectation.Counter, 1)
		mm_want := mmPublicKeys.PublicKeysMock.defaultExpectation.params
		mm_want_ptrs := mmPublicKeys.PublicKeysMock.defaultExpectation.paramPtrs

		mm_got := SecretRepositoryMockPublicKeysParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPublicKeys.t.Errorf("SecretRepositoryMock.PublicKeys got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPublicKeys.PublicKeysMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublicKeys.t.Errorf("SecretRepositoryMock.PublicKeys got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPublicKeys.PublicKeysMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublicKeys.PublicKeysMock.defaultExpectation.results
		if mm_results == nil {
			mmPublicKeys.t.Fatal("No results are set for the SecretRepositoryMock.PublicKeys")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmPublicKeys.funcPublicKeys != nil {
		return mmPublicKeys.funcPublicKeys(ctx)
	}
	mmPublicKeys.t.Fatalf("Unexpected call to SecretRepositoryMock.PublicKeys. %v", ctx)
	return
}

// PublicKeysAfterCounter returns a count of finished SecretRepositoryMock.PublicKeys invocations
func (mmPublicKeys *SecretRepositoryMock) PublicKeysAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicKeys.afterPublicKeysCounter)
}

// PublicKeysBeforeCounter returns a count of SecretRepositoryMock.PublicKeys invocations
func (mmPublicKeys *SecretRepositoryMock) PublicKeysBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicKeys.beforePublicKeysCounter)
}

// Calls returns a list of arguments used in each call to SecretRepositoryMock.PublicKeys.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublicKeys *mSecretRepositoryMockPublicKeys) Calls() []*SecretRepositoryMockPublicKeysParams {
	mmPublicKeys.mutex.RLock()

	argCopy := make([]*SecretRepositoryMockPublicKeysParams, len(mmPublicKeys.callArgs))
	copy(argCopy, mmPublicKeys.callArgs)

	mmPublicKeys.mutex.RUnlock()

	return argCopy
}

// MinimockPublicKeysDone returns true if the count of the PublicKeys invocations corresponds
// the number of defined expectations
func (m *SecretRepositoryMock) MinimockPublicKeysDone() bool {
	if m.PublicKeysMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PublicKeysMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PublicKeysMock.invocationsDone()
}

// MinimockPublicKeysInspect logs each unmet expectation
func (m *SecretRepositoryMock) MinimockPublicKeysInspect() {
	for _, e := range m.PublicKeysMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SecretRepositoryMock.PublicKeys at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPublicKeysCounter := mm_atomic.LoadUint64(&m.afterPublicKeysCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PublicKeysMock.defaultExpectation != nil && afterPublicKeysCounter < 1 {
		if m.PublicKeysMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SecretRepositoryMock.PublicKeys at\n%s", m.PublicKeysMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SecretRepositoryMock.PublicKeys at\n%s with params: %#v", m.PublicKeysMock.defaultExpectation.expectationOrigins.origin, *m.PublicKeysMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicKeys != nil && afterPublicKeysCounter < 1 {
		m.t.Errorf("Expected call to SecretRepositoryMock.PublicKeys at\n%s", m.funcPublicKeysOrigin)
	}

	if !m.PublicKeysMock.invocationsDone() && afterPublicKeysCounter > 0 {
		m.t.Errorf("Expected %d calls to SecretRepositoryMock.PublicKeys at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PublicKeysMock.expectedInvocations), m.PublicKeysMock.expectedInvocationsOrigin, afterPublicKeysCounter)
	}
}

type mSecretRepositoryMockSignData struct {
	optional           bool
	mock               *SecretRepositoryMock
	defaultExpectation *SecretRepositoryMockSignDataExpectation
	expectations       []*SecretRepositoryMockSignDataExpectation

	callArgs []*SecretRepositoryMockSignDataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SecretRepositoryMockSignDataExpectation specifies expectation struct of the SecretRepository.SignData
type SecretRepositoryMockSignDataExpectation struct {
	mock               *SecretRepositoryMock
	params             *SecretRepositoryMockSignDataParams
	paramPtrs          *SecretRepositoryMockSignDataParamPtrs
	expectationOrigins SecretRepositoryMockSignDataExpectationOrigins
	results            *SecretRepositoryMockSignDataResults
	returnOrigin       string
	Counter            uint64
}

// SecretRepositoryMockSignDataParams contains parameters of the SecretRepository.SignData
type SecretRepositoryMockSignDataParams struct {
	ctx  context.Context
	data string
}

// SecretRepositoryMockSignDataParamPtrs contains pointers to parameters of the SecretRepository.SignData
type SecretRepositoryMockSignDataParamPtrs struct {
	ctx  *context.Context
	data *string
}

// SecretRepositoryMockSignDataResults contains results of the SecretRepository.SignData
type SecretRepositoryMockSignDataResults struct {
	signedData string
	err        error
}

// SecretRepositoryMockSignDataOrigins contains origins of expectations of the SecretRepository.SignData
type SecretRepositoryMockSignDataExpectationOrigins struct {
	origin     string
	originCtx  string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSignData *mSecretRepositoryMockSignData) Optional() *mSecretRepositoryMockSignData {
	mmSignData.optional = true
	return mmSignData
}

// Expect sets up expected params for SecretRepository.SignData
func (mmSignData *mSecretRepositoryMockSignData) Expect(ctx context.Context, data string) *mSecretRepositoryMockSignData {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("SecretRepositoryMock.SignData mock is already set by Set")
	}

	if mmSignData.defaultExpectation == nil {
		mmSignData.defaultExpectation = &SecretRepositoryMockSignDataExpectation{}
	}

	if mmSignData.defaultExpectation.paramPtrs != nil {
		mmSignData.mock.t.Fatalf("SecretRepositoryMock.SignData mock is already set by ExpectParams functions")
	}

	mmSignData.defaultExpectation.params = &SecretRepositoryMockSignDataParams{ctx, data}
	mmSignData.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSignData.expectations {
		if minimock.Equal(e.params, mmSignData.defaultExpectation.params) {
			mmSignData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignData.defaultExpectation.params)
		}
	}

	return mmSignData
}

// ExpectCtxParam1 sets up expected param ctx for SecretRepository.SignData
func (mmSignData *mSecretRepositoryMockSignData) ExpectCtxParam1(ctx context.Context) *mSecretRepositoryMockSignData {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("SecretRepositoryMock.SignData mock is already set by Set")
	}

	if mmSignData.defaultExpectation == nil {
		mmSignData.defaultExpectation = &SecretRepositoryMockSignDataExpectation{}
	}

	if mmSignData.defaultExpectation.params != nil {
		mmSignData.mock.t.Fatalf("SecretRepositoryMock.SignData mock is already set by Expect")
	}

	if mmSignData.defaultExpectation.paramPtrs == nil {
		mmSignData.defaultExpectation.paramPtrs = &SecretRepositoryMockSignDataParamPtrs{}
	}
	mmSignData.defaultExpectation.paramPtrs.ctx = &ctx
	mmSignData.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSignData
}

// ExpectDataParam2 sets up expected param data for SecretRepository.SignData
func (mmSignData *mSecretRepositoryMockSignData) ExpectDataParam2(data string) *mSecretRepositoryMockSignData {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("SecretRepositoryMock.SignData mock is already set by Set")
	}

	if mmSignData.defaultExpectation == nil {
		mmSignData.defaultExpectation = &SecretRepositoryMockSignDataExpectation{}
	}

	if mmSignData.defaultExpectation.params != nil {
		mmSignData.mock.t.Fatalf("SecretRepositoryMock.SignData mock is already set by Expect")
	}

	if mmSignData.defaultExpectation.paramPtrs == nil {
		mmSignData.defaultExpectation.paramPtrs = &SecretRepositoryMockSignDataParamPtrs{}
	}
	mmSignData.defaultExpectation.paramPtrs.data = &data
	mmSignData.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmSignData
}

// Inspect accepts an inspector function that has same arguments as the SecretRepository.SignData
func (mmSignData *mSecretRepositoryMockSignData) Inspect(f func(ctx context.Context, data string)) *mSecretRepositoryMockSignData {
	if mmSignData.mock.inspectFuncSignData != nil {
		mmSignData.mock.t.Fatalf("Inspect function is already set for SecretRepositoryMock.SignData")
	}

	mmSignData.mock.inspectFuncSignData = f

	return mmSignData
}

// Return sets up results that will be returned by SecretRepository.SignData
func (mmSignData *mSecretRepositoryMockSignData) Return(signedData string, err error) *SecretRepositoryMock {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("SecretRepositoryMock.SignData mock is already set by Set")
	}

	if mmSignData.defaultExpectation == nil {
		mmSignData.defaultExpectation = &SecretRepositoryMockSignDataExpectation{mock: mmSignData.mock}
	}
	mmSignData.defaultExpectation.results = &SecretRepositoryMockSignDataResults{signedData, err}
	mmSignData.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSignData.mock
}

// Set uses given function f to mock the SecretRepository.SignData method
func (mmSignData *mSecretRepositoryMockSignData) Set(f func(ctx context.Context, data string) (signedData string, err error)) *SecretRepositoryMock {
	if mmSignData.defaultExpectation != nil {
		mmSignData.mock.t.Fatalf("Default expectation is already set for the SecretRepository.SignData method")
	}

	if len(mmSignData.expectations) > 0 {
		mmSignData.mock.t.Fatalf("Some expectations are already set for the SecretRepository.SignData method")
	}

	mmSignData.mock.funcSignData = f
	mmSignData.mock.funcSignDataOrigin = minimock.CallerInfo(1)
	return mmSignData.mock
}

// When sets expectation for the SecretRepository.SignData which will trigger the result defined by the following
// Then helper
func (mmSignData *mSecretRepositoryMockSignData) When(ctx context.Context, data string) *SecretRepositoryMockSignDataExpectation {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("SecretRepositoryMock.SignData mock is already set by Set")
	}

	expectation := &SecretRepositoryMockSignDataExpectation{
		mock:               mmSignData.mock,
		params:             &SecretRepositoryMockSignDataParams{ctx, data},
		expectationOrigins: SecretRepositoryMockSignDataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSignData.expectations = append(mmSignData.expectations, expectation)
	return expectation
}

// Then sets up SecretRepository.SignData return parameters for the expectation previously defined by the When method
func (e *SecretRepositoryMockSignDataExpectation) Then(signedData string, err error) *SecretRepositoryMock {
	e.results = &SecretRepositoryMockSignDataResults{signedData, err}
	return e.mock
}

// Times sets number of times SecretRepository.SignData should be invoked
func (mmSignData *mSecretRepositoryMockSignData) Times(n uint64) *mSecretRepositoryMockSignData {
	if n == 0 {
		mmSignData.mock.t.Fatalf("Times of SecretRepositoryMock.SignData mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSignData.expectedInvocations, n)
	mmSignData.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSignData
}

func (mmSignData *mSecretRepositoryMockSignData) invocationsDone() bool {
	if len(mmSignData.expectations) == 0 && mmSignData.defaultExpectation == nil && mmSignData.mock.funcSignData == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSignData.mock.afterSignDataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSignData.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SignData implements mm_auth.SecretRepository
func (mmSignData *SecretRepositoryMock) SignData(ctx context.Context, data string) (signedData string, err error) {
	mm_atomic.AddUint64(&mmSignData.beforeSignDataCounter, 1)
	defer mm_atomic.AddUint64(&mmSignData.afterSignDataCounter, 1)

	mmSignData.t.Helper()

	if mmSignData.inspectFuncSignData != nil {
		mmSignData.inspectFuncSignData(ctx, data)
	}

	mm_params := SecretRepositoryMockSignDataParams{ctx, data}

	// Record call args
	mmSignData.SignDataMock.mutex.Lock()
	mmSignData.SignDataMock.callArgs = append(mmSignData.SignDataMock.callArgs, &mm_params)
	mmSignData.SignDataMock.mutex.Unlock()

	for _, e := range mmSignData.SignDataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.signedData, e.results.err
		}
	}

	if mmSignData.SignDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignData.SignDataMock.defaultExpectation.Counter, 1)
		mm_want := mmSignData.SignDataMock.defaultExpectation.params
		mm_want_ptrs := mmSignData.SignDataMock.defaultExpectation.paramPtrs

		mm_got := SecretRepositoryMockSignDataParams{ctx, data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSignData.t.Errorf("SecretRepositoryMock.SignData got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignData.SignDataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmSignData.t.Errorf("SecretRepositoryMock.SignData got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignData.SignDataMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignData.t.Errorf("SecretRepositoryMock.SignData got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSignData.SignDataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignData.SignDataMock.defaultExpectation.results
		if mm_results == nil {
			mmSignData.t.Fatal("No results are set for the SecretRepositoryMock.SignData")
		}
		return (*mm_results).signedData, (*mm_results).err
	}
	if mmSignData.funcSignData != nil {
		return mmSignData.funcSignData(ctx, data)
	}
	mmSignData.t.Fatalf("Unexpected call to SecretRepositoryMock.SignData. %v %v", ctx, data)
	return
}

// SignDataAfterCounter returns a count of finished SecretRepositoryMock.SignData invocations
func (mmSignData *SecretRepositoryMock) SignDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignData.afterSignDataCounter)
}

// SignDataBeforeCounter returns a count of SecretRepositoryMock.SignData invocations
func (mmSignData *SecretRepositoryMock) SignDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignData.beforeSignDataCounter)
}

// Calls returns a list of arguments used in each call to SecretRepositoryMock.SignData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignData *mSecretRepositoryMockSignData) Calls() []*SecretRepositoryMockSignDataParams {
	mmSignData.mutex.RLock()

	argCopy := make([]*SecretRepositoryMockSignDataParams, len(mmSignData.callArgs))
	copy(argCopy, mmSignData.callArgs)

	mmSignData.mutex.RUnlock()

	return argCopy
}

// MinimockSignDataDone returns true if the count of the SignData invocations corresponds
// the number of defined expectations
func (m *SecretRepositoryMock) MinimockSignDataDone() bool {
	if m.SignDataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SignDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SignDataMock.invocationsDone()
}

// MinimockSignDataInspect logs each unmet expectation
func (m *SecretRepositoryMock) MinimockSignDataInspect() {
	for _, e := range m.SignDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SecretRepositoryMock.SignData at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSignDataCounter := mm_atomic.LoadUint64(&m.afterSignDataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SignDataMock.defaultExpectation != nil && afterSignDataCounter < 1 {
		if m.SignDataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SecretRepositoryMock.SignData at\n%s", m.SignDataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SecretRepositoryMock.SignData at\n%s with params: %#v", m.SignDataMock.defaultExpectation.expectationOrigins.origin, *m.SignDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignData != nil && afterSignDataCounter < 1 {
		m.t.Errorf("Expected call to SecretRepositoryMock.SignData at\n%s", m.funcSignDataOrigin)
	}

	if !m.SignDataMock.invocationsDone() && afterSignDataCounter > 0 {
		m.t.Errorf("Expected %d calls to SecretRepositoryMock.SignData at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SignDataMock.expectedInvocations), m.SignDataMock.expectedInvocationsOrigin, afterSignDataCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SecretRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetKIDInspect()

			m.MinimockPublicKeysInspect()

			m.MinimockSignDataInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SecretRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SecretRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetKIDDone() &&
		m.MinimockPublicKeysDone() &&
		m.MinimockSignDataDone()
}
