// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/service/auth.tokenStorage -o token_storage_mock.go -n TokenStorageMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TokenStorageMock implements mm_auth.tokenStorage
type TokenStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGet          func(ctx context.Context, key string) (a1 any, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, key string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mTokenStorageMockGet

	funcStore          func(ctx context.Context, key string, value any, ttl int64) (err error)
	funcStoreOrigin    string
	inspectFuncStore   func(ctx context.Context, key string, value any, ttl int64)
	afterStoreCounter  uint64
	beforeStoreCounter uint64
	StoreMock          mTokenStorageMockStore
}

// NewTokenStorageMock returns a mock for mm_auth.tokenStorage
func NewTokenStorageMock(t minimock.Tester) *TokenStorageMock {
	m := &TokenStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetMock = mTokenStorageMockGet{mock: m}
	m.GetMock.callArgs = []*TokenStorageMockGetParams{}

	m.StoreMock = mTokenStorageMockStore{mock: m}
	m.StoreMock.callArgs = []*TokenStorageMockStoreParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTokenStorageMockGet struct {
	optional           bool
	mock               *TokenStorageMock
	defaultExpectation *TokenStorageMockGetExpectation
	expectations       []*TokenStorageMockGetExpectation

	callArgs []*TokenStorageMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenStorageMockGetExpectation specifies expectation struct of the tokenStorage.Get
type TokenStorageMockGetExpectation struct {
	mock               *TokenStorageMock
	params             *TokenStorageMockGetParams
	paramPtrs          *TokenStorageMockGetParamPtrs
	expectationOrigins TokenStorageMockGetExpectationOrigins
	results            *TokenStorageMockGetResults
	returnOrigin       string
	Counter            uint64
}

// TokenStorageMockGetParams contains parameters of the tokenStorage.Get
type TokenStorageMockGetParams struct {
	ctx context.Context
	key string
}

// TokenStorageMockGetParamPtrs contains pointers to parameters of the tokenStorage.Get
type TokenStorageMockGetParamPtrs struct {
	ctx *context.Context
	key *string
}

// TokenStorageMockGetResults contains results of the tokenStorage.Get
type TokenStorageMockGetResults struct {
	a1  any
	err error
}

// TokenStorageMockGetOrigins contains origins of expectations of the tokenStorage.Get
type TokenStorageMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mTokenStorageMockGet) Optional() *mTokenStorageMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for tokenStorage.Get
func (mmGet *mTokenStorageMockGet) Expect(ctx context.Context, key string) *mTokenStorageMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TokenStorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &TokenStorageMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("TokenStorageMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &TokenStorageMockGetParams{ctx, key}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for tokenStorage.Get
func (mmGet *mTokenStorageMockGet) ExpectCtxParam1(ctx context.Context) *mTokenStorageMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TokenStorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &TokenStorageMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("TokenStorageMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &TokenStorageMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectKeyParam2 sets up expected param key for tokenStorage.Get
func (mmGet *mTokenStorageMockGet) ExpectKeyParam2(key string) *mTokenStorageMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TokenStorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &TokenStorageMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("TokenStorageMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &TokenStorageMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key
	mmGet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the tokenStorage.Get
func (mmGet *mTokenStorageMockGet) Inspect(f func(ctx context.Context, key string)) *mTokenStorageMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for TokenStorageMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by tokenStorage.Get
func (mmGet *mTokenStorageMockGet) Return(a1 any, err error) *TokenStorageMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TokenStorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &TokenStorageMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &TokenStorageMockGetResults{a1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the tokenStorage.Get method
func (mmGet *mTokenStorageMockGet) Set(f func(ctx context.Context, key string) (a1 any, err error)) *TokenStorageMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the tokenStorage.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the tokenStorage.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the tokenStorage.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mTokenStorageMockGet) When(ctx context.Context, key string) *TokenStorageMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TokenStorageMock.Get mock is already set by Set")
	}

	expectation := &TokenStorageMockGetExpectation{
		mock:               mmGet.mock,
		params:             &TokenStorageMockGetParams{ctx, key},
		expectationOrigins: TokenStorageMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up tokenStorage.Get return parameters for the expectation previously defined by the When method
func (e *TokenStorageMockGetExpectation) Then(a1 any, err error) *TokenStorageMock {
	e.results = &TokenStorageMockGetResults{a1, err}
	return e.mock
}

// Times sets number of times tokenStorage.Get should be invoked
func (mmGet *mTokenStorageMockGet) Times(n uint64) *mTokenStorageMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of TokenStorageMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mTokenStorageMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_auth.tokenStorage
func (mmGet *TokenStorageMock) Get(ctx context.Context, key string) (a1 any, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key)
	}

	mm_params := TokenStorageMockGetParams{ctx, key}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := TokenStorageMockGetParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("TokenStorageMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("TokenStorageMock.Get got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("TokenStorageMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the TokenStorageMock.Get")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key)
	}
	mmGet.t.Fatalf("Unexpected call to TokenStorageMock.Get. %v %v", ctx, key)
	return
}

// GetAfterCounter returns a count of finished TokenStorageMock.Get invocations
func (mmGet *TokenStorageMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of TokenStorageMock.Get invocations
func (mmGet *TokenStorageMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to TokenStorageMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mTokenStorageMockGet) Calls() []*TokenStorageMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*TokenStorageMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *TokenStorageMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *TokenStorageMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenStorageMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenStorageMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenStorageMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to TokenStorageMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenStorageMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mTokenStorageMockStore struct {
	optional           bool
	mock               *TokenStorageMock
	defaultExpectation *TokenStorageMockStoreExpectation
	expectations       []*TokenStorageMockStoreExpectation

	callArgs []*TokenStorageMockStoreParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenStorageMockStoreExpectation specifies expectation struct of the tokenStorage.Store
type TokenStorageMockStoreExpectation struct {
	mock               *TokenStorageMock
	params             *TokenStorageMockStoreParams
	paramPtrs          *TokenStorageMockStoreParamPtrs
	expectationOrigins TokenStorageMockStoreExpectationOrigins
	results            *TokenStorageMockStoreResults
	returnOrigin       string
	Counter            uint64
}

// TokenStorageMockStoreParams contains parameters of the tokenStorage.Store
type TokenStorageMockStoreParams struct {
	ctx   context.Context
	key   string
	value any
	ttl   int64
}

// TokenStorageMockStoreParamPtrs contains pointers to parameters of the tokenStorage.Store
type TokenStorageMockStoreParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *any
	ttl   *int64
}

// TokenStorageMockStoreResults contains results of the tokenStorage.Store
type TokenStorageMockStoreResults struct {
	err error
}

// TokenStorageMockStoreOrigins contains origins of expectations of the tokenStorage.Store
type TokenStorageMockStoreExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originValue string
	originTtl   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStore *mTokenStorageMockStore) Optional() *mTokenStorageMockStore {
	mmStore.optional = true
	return mmStore
}

// Expect sets up expected params for tokenStorage.Store
func (mmStore *mTokenStorageMockStore) Expect(ctx context.Context, key string, value any, ttl int64) *mTokenStorageMockStore {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Set")
	}

	if mmStore.defaultExpectation == nil {
		mmStore.defaultExpectation = &TokenStorageMockStoreExpectation{}
	}

	if mmStore.defaultExpectation.paramPtrs != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by ExpectParams functions")
	}

	mmStore.defaultExpectation.params = &TokenStorageMockStoreParams{ctx, key, value, ttl}
	mmStore.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStore.expectations {
		if minimock.Equal(e.params, mmStore.defaultExpectation.params) {
			mmStore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStore.defaultExpectation.params)
		}
	}

	return mmStore
}

// ExpectCtxParam1 sets up expected param ctx for tokenStorage.Store
func (mmStore *mTokenStorageMockStore) ExpectCtxParam1(ctx context.Context) *mTokenStorageMockStore {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Set")
	}

	if mmStore.defaultExpectation == nil {
		mmStore.defaultExpectation = &TokenStorageMockStoreExpectation{}
	}

	if mmStore.defaultExpectation.params != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Expect")
	}

	if mmStore.defaultExpectation.paramPtrs == nil {
		mmStore.defaultExpectation.paramPtrs = &TokenStorageMockStoreParamPtrs{}
	}
	mmStore.defaultExpectation.paramPtrs.ctx = &ctx
	mmStore.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStore
}

// ExpectKeyParam2 sets up expected param key for tokenStorage.Store
func (mmStore *mTokenStorageMockStore) ExpectKeyParam2(key string) *mTokenStorageMockStore {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Set")
	}

	if mmStore.defaultExpectation == nil {
		mmStore.defaultExpectation = &TokenStorageMockStoreExpectation{}
	}

	if mmStore.defaultExpectation.params != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Expect")
	}

	if mmStore.defaultExpectation.paramPtrs == nil {
		mmStore.defaultExpectation.paramPtrs = &TokenStorageMockStoreParamPtrs{}
	}
	mmStore.defaultExpectation.paramPtrs.key = &key
	mmStore.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmStore
}

// ExpectValueParam3 sets up expected param value for tokenStorage.Store
func (mmStore *mTokenStorageMockStore) ExpectValueParam3(value any) *mTokenStorageMockStore {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Set")
	}

	if mmStore.defaultExpectation == nil {
		mmStore.defaultExpectation = &TokenStorageMockStoreExpectation{}
	}

	if mmStore.defaultExpectation.params != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Expect")
	}

	if mmStore.defaultExpectation.paramPtrs == nil {
		mmStore.defaultExpectation.paramPtrs = &TokenStorageMockStoreParamPtrs{}
	}
	mmStore.defaultExpectation.paramPtrs.value = &value
	mmStore.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmStore
}

// ExpectTtlParam4 sets up expected param ttl for tokenStorage.Store
func (mmStore *mTokenStorageMockStore) ExpectTtlParam4(ttl int64) *mTokenStorageMockStore {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Set")
	}

	if mmStore.defaultExpectation == nil {
		mmStore.defaultExpectation = &TokenStorageMockStoreExpectation{}
	}

	if mmStore.defaultExpectation.params != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Expect")
	}

	if mmStore.defaultExpectation.paramPtrs == nil {
		mmStore.defaultExpectation.paramPtrs = &TokenStorageMockStoreParamPtrs{}
	}
	mmStore.defaultExpectation.paramPtrs.ttl = &ttl
	mmStore.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmStore
}

// Inspect accepts an inspector function that has same arguments as the tokenStorage.Store
func (mmStore *mTokenStorageMockStore) Inspect(f func(ctx context.Context, key string, value any, ttl int64)) *mTokenStorageMockStore {
	if mmStore.mock.inspectFuncStore != nil {
		mmStore.mock.t.Fatalf("Inspect function is already set for TokenStorageMock.Store")
	}

	mmStore.mock.inspectFuncStore = f

	return mmStore
}

// Return sets up results that will be returned by tokenStorage.Store
func (mmStore *mTokenStorageMockStore) Return(err error) *TokenStorageMock {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Set")
	}

	if mmStore.defaultExpectation == nil {
		mmStore.defaultExpectation = &TokenStorageMockStoreExpectation{mock: mmStore.mock}
	}
	mmStore.defaultExpectation.results = &TokenStorageMockStoreResults{err}
	mmStore.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStore.mock
}

// Set uses given function f to mock the tokenStorage.Store method
func (mmStore *mTokenStorageMockStore) Set(f func(ctx context.Context, key string, value any, ttl int64) (err error)) *TokenStorageMock {
	if mmStore.defaultExpectation != nil {
		mmStore.mock.t.Fatalf("Default expectation is already set for the tokenStorage.Store method")
	}

	if len(mmStore.expectations) > 0 {
		mmStore.mock.t.Fatalf("Some expectations are already set for the tokenStorage.Store method")
	}

	mmStore.mock.funcStore = f
	mmStore.mock.funcStoreOrigin = minimock.CallerInfo(1)
	return mmStore.mock
}

// When sets expectation for the tokenStorage.Store which will trigger the result defined by the following
// Then helper
func (mmStore *mTokenStorageMockStore) When(ctx context.Context, key string, value any, ttl int64) *TokenStorageMockStoreExpectation {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("TokenStorageMock.Store mock is already set by Set")
	}

	expectation := &TokenStorageMockStoreExpectation{
		mock:               mmStore.mock,
		params:             &TokenStorageMockStoreParams{ctx, key, value, ttl},
		expectationOrigins: TokenStorageMockStoreExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStore.expectations = append(mmStore.expectations, expectation)
	return expectation
}

// Then sets up tokenStorage.Store return parameters for the expectation previously defined by the When method
func (e *TokenStorageMockStoreExpectation) Then(err error) *TokenStorageMock {
	e.results = &TokenStorageMockStoreResults{err}
	return e.mock
}

// Times sets number of times tokenStorage.Store should be invoked
func (mmStore *mTokenStorageMockStore) Times(n uint64) *mTokenStorageMockStore {
	if n == 0 {
		mmStore.mock.t.Fatalf("Times of TokenStorageMock.Store mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStore.expectedInvocations, n)
	mmStore.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStore
}

func (mmStore *mTokenStorageMockStore) invocationsDone() bool {
	if len(mmStore.expectations) == 0 && mmStore.defaultExpectation == nil && mmStore.mock.funcStore == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStore.mock.afterStoreCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStore.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Store implements mm_auth.tokenStorage
func (mmStore *TokenStorageMock) Store(ctx context.Context, key string, value any, ttl int64) (err error) {
	mm_atomic.AddUint64(&mmStore.beforeStoreCounter, 1)
	defer mm_atomic.AddUint64(&mmStore.afterStoreCounter, 1)

	mmStore.t.Helper()

	if mmStore.inspectFuncStore != nil {
		mmStore.inspectFuncStore(ctx, key, value, ttl)
	}

	mm_params := TokenStorageMockStoreParams{ctx, key, value, ttl}

	// Record call args
	mmStore.StoreMock.mutex.Lock()
	mmStore.StoreMock.callArgs = append(mmStore.StoreMock.callArgs, &mm_params)
	mmStore.StoreMock.mutex.Unlock()

	for _, e := range mmStore.StoreMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStore.StoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStore.StoreMock.defaultExpectation.Counter, 1)
		mm_want := mmStore.StoreMock.defaultExpectation.params
		mm_want_ptrs := mmStore.StoreMock.defaultExpectation.paramPtrs

		mm_got := TokenStorageMockStoreParams{ctx, key, value, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStore.t.Errorf("TokenStorageMock.Store got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStore.StoreMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmStore.t.Errorf("TokenStorageMock.Store got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStore.StoreMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmStore.t.Errorf("TokenStorageMock.Store got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStore.StoreMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmStore.t.Errorf("TokenStorageMock.Store got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStore.StoreMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStore.t.Errorf("TokenStorageMock.Store got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStore.StoreMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStore.StoreMock.defaultExpectation.results
		if mm_results == nil {
			mmStore.t.Fatal("No results are set for the TokenStorageMock.Store")
		}
		return (*mm_results).err
	}
	if mmStore.funcStore != nil {
		return mmStore.funcStore(ctx, key, value, ttl)
	}
	mmStore.t.Fatalf("Unexpected call to TokenStorageMock.Store. %v %v %v %v", ctx, key, value, ttl)
	return
}

// StoreAfterCounter returns a count of finished TokenStorageMock.Store invocations
func (mmStore *TokenStorageMock) StoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStore.afterStoreCounter)
}

// StoreBeforeCounter returns a count of TokenStorageMock.Store invocations
func (mmStore *TokenStorageMock) StoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStore.beforeStoreCounter)
}

// Calls returns a list of arguments used in each call to TokenStorageMock.Store.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStore *mTokenStorageMockStore) Calls() []*TokenStorageMockStoreParams {
	mmStore.mutex.RLock()

	argCopy := make([]*TokenStorageMockStoreParams, len(mmStore.callArgs))
	copy(argCopy, mmStore.callArgs)

	mmStore.mutex.RUnlock()

	return argCopy
}

// MinimockStoreDone returns true if the count of the Store invocations corresponds
// the number of defined expectations
func (m *TokenStorageMock) MinimockStoreDone() bool {
	if m.StoreMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StoreMock.invocationsDone()
}

// MinimockStoreInspect logs each unmet expectation
func (m *TokenStorageMock) MinimockStoreInspect() {
	for _, e := range m.StoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenStorageMock.Store at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStoreCounter := mm_atomic.LoadUint64(&m.afterStoreCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StoreMock.defaultExpectation != nil && afterStoreCounter < 1 {
		if m.StoreMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenStorageMock.Store at\n%s", m.StoreMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenStorageMock.Store at\n%s with params: %#v", m.StoreMock.defaultExpectation.expectationOrigins.origin, *m.StoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStore != nil && afterStoreCounter < 1 {
		m.t.Errorf("Expected call to TokenStorageMock.Store at\n%s", m.funcStoreOrigin)
	}

	if !m.StoreMock.invocationsDone() && afterStoreCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenStorageMock.Store at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StoreMock.expectedInvocations), m.StoreMock.expectedInvocationsOrigin, afterStoreCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TokenStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetInspect()

			m.MinimockStoreInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TokenStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TokenStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDone() &&
		m.MinimockStoreDone()
}
