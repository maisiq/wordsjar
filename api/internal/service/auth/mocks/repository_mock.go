// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-words-jar/internal/service/auth.Repository -o repository_mock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-words-jar/internal/models"
)

// RepositoryMock implements mm_auth.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddUser          func(ctx context.Context, user models.User) (err error)
	funcAddUserOrigin    string
	inspectFuncAddUser   func(ctx context.Context, user models.User)
	afterAddUserCounter  uint64
	beforeAddUserCounter uint64
	AddUserMock          mRepositoryMockAddUser

	funcUser          func(ctx context.Context, username string) (u1 models.User, err error)
	funcUserOrigin    string
	inspectFuncUser   func(ctx context.Context, username string)
	afterUserCounter  uint64
	beforeUserCounter uint64
	UserMock          mRepositoryMockUser
}

// NewRepositoryMock returns a mock for mm_auth.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddUserMock = mRepositoryMockAddUser{mock: m}
	m.AddUserMock.callArgs = []*RepositoryMockAddUserParams{}

	m.UserMock = mRepositoryMockUser{mock: m}
	m.UserMock.callArgs = []*RepositoryMockUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddUserExpectation
	expectations       []*RepositoryMockAddUserExpectation

	callArgs []*RepositoryMockAddUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddUserExpectation specifies expectation struct of the Repository.AddUser
type RepositoryMockAddUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddUserParams
	paramPtrs          *RepositoryMockAddUserParamPtrs
	expectationOrigins RepositoryMockAddUserExpectationOrigins
	results            *RepositoryMockAddUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddUserParams contains parameters of the Repository.AddUser
type RepositoryMockAddUserParams struct {
	ctx  context.Context
	user models.User
}

// RepositoryMockAddUserParamPtrs contains pointers to parameters of the Repository.AddUser
type RepositoryMockAddUserParamPtrs struct {
	ctx  *context.Context
	user *models.User
}

// RepositoryMockAddUserResults contains results of the Repository.AddUser
type RepositoryMockAddUserResults struct {
	err error
}

// RepositoryMockAddUserOrigins contains origins of expectations of the Repository.AddUser
type RepositoryMockAddUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUser *mRepositoryMockAddUser) Optional() *mRepositoryMockAddUser {
	mmAddUser.optional = true
	return mmAddUser
}

// Expect sets up expected params for Repository.AddUser
func (mmAddUser *mRepositoryMockAddUser) Expect(ctx context.Context, user models.User) *mRepositoryMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &RepositoryMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.paramPtrs != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by ExpectParams functions")
	}

	mmAddUser.defaultExpectation.params = &RepositoryMockAddUserParams{ctx, user}
	mmAddUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUser.expectations {
		if minimock.Equal(e.params, mmAddUser.defaultExpectation.params) {
			mmAddUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUser.defaultExpectation.params)
		}
	}

	return mmAddUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddUser
func (mmAddUser *mRepositoryMockAddUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &RepositoryMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.params != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Expect")
	}

	if mmAddUser.defaultExpectation.paramPtrs == nil {
		mmAddUser.defaultExpectation.paramPtrs = &RepositoryMockAddUserParamPtrs{}
	}
	mmAddUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddUser
}

// ExpectUserParam2 sets up expected param user for Repository.AddUser
func (mmAddUser *mRepositoryMockAddUser) ExpectUserParam2(user models.User) *mRepositoryMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &RepositoryMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.params != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Expect")
	}

	if mmAddUser.defaultExpectation.paramPtrs == nil {
		mmAddUser.defaultExpectation.paramPtrs = &RepositoryMockAddUserParamPtrs{}
	}
	mmAddUser.defaultExpectation.paramPtrs.user = &user
	mmAddUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmAddUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddUser
func (mmAddUser *mRepositoryMockAddUser) Inspect(f func(ctx context.Context, user models.User)) *mRepositoryMockAddUser {
	if mmAddUser.mock.inspectFuncAddUser != nil {
		mmAddUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddUser")
	}

	mmAddUser.mock.inspectFuncAddUser = f

	return mmAddUser
}

// Return sets up results that will be returned by Repository.AddUser
func (mmAddUser *mRepositoryMockAddUser) Return(err error) *RepositoryMock {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &RepositoryMockAddUserExpectation{mock: mmAddUser.mock}
	}
	mmAddUser.defaultExpectation.results = &RepositoryMockAddUserResults{err}
	mmAddUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUser.mock
}

// Set uses given function f to mock the Repository.AddUser method
func (mmAddUser *mRepositoryMockAddUser) Set(f func(ctx context.Context, user models.User) (err error)) *RepositoryMock {
	if mmAddUser.defaultExpectation != nil {
		mmAddUser.mock.t.Fatalf("Default expectation is already set for the Repository.AddUser method")
	}

	if len(mmAddUser.expectations) > 0 {
		mmAddUser.mock.t.Fatalf("Some expectations are already set for the Repository.AddUser method")
	}

	mmAddUser.mock.funcAddUser = f
	mmAddUser.mock.funcAddUserOrigin = minimock.CallerInfo(1)
	return mmAddUser.mock
}

// When sets expectation for the Repository.AddUser which will trigger the result defined by the following
// Then helper
func (mmAddUser *mRepositoryMockAddUser) When(ctx context.Context, user models.User) *RepositoryMockAddUserExpectation {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Set")
	}

	expectation := &RepositoryMockAddUserExpectation{
		mock:               mmAddUser.mock,
		params:             &RepositoryMockAddUserParams{ctx, user},
		expectationOrigins: RepositoryMockAddUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddUser.expectations = append(mmAddUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddUserResults{err}
	return e.mock
}

// Times sets number of times Repository.AddUser should be invoked
func (mmAddUser *mRepositoryMockAddUser) Times(n uint64) *mRepositoryMockAddUser {
	if n == 0 {
		mmAddUser.mock.t.Fatalf("Times of RepositoryMock.AddUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUser.expectedInvocations, n)
	mmAddUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUser
}

func (mmAddUser *mRepositoryMockAddUser) invocationsDone() bool {
	if len(mmAddUser.expectations) == 0 && mmAddUser.defaultExpectation == nil && mmAddUser.mock.funcAddUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUser.mock.afterAddUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUser implements mm_auth.Repository
func (mmAddUser *RepositoryMock) AddUser(ctx context.Context, user models.User) (err error) {
	mm_atomic.AddUint64(&mmAddUser.beforeAddUserCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUser.afterAddUserCounter, 1)

	mmAddUser.t.Helper()

	if mmAddUser.inspectFuncAddUser != nil {
		mmAddUser.inspectFuncAddUser(ctx, user)
	}

	mm_params := RepositoryMockAddUserParams{ctx, user}

	// Record call args
	mmAddUser.AddUserMock.mutex.Lock()
	mmAddUser.AddUserMock.callArgs = append(mmAddUser.AddUserMock.callArgs, &mm_params)
	mmAddUser.AddUserMock.mutex.Unlock()

	for _, e := range mmAddUser.AddUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddUser.AddUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUser.AddUserMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUser.AddUserMock.defaultExpectation.params
		mm_want_ptrs := mmAddUser.AddUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddUser.t.Errorf("RepositoryMock.AddUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUser.AddUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmAddUser.t.Errorf("RepositoryMock.AddUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUser.AddUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUser.t.Errorf("RepositoryMock.AddUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUser.AddUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUser.AddUserMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUser.t.Fatal("No results are set for the RepositoryMock.AddUser")
		}
		return (*mm_results).err
	}
	if mmAddUser.funcAddUser != nil {
		return mmAddUser.funcAddUser(ctx, user)
	}
	mmAddUser.t.Fatalf("Unexpected call to RepositoryMock.AddUser. %v %v", ctx, user)
	return
}

// AddUserAfterCounter returns a count of finished RepositoryMock.AddUser invocations
func (mmAddUser *RepositoryMock) AddUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.afterAddUserCounter)
}

// AddUserBeforeCounter returns a count of RepositoryMock.AddUser invocations
func (mmAddUser *RepositoryMock) AddUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.beforeAddUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUser *mRepositoryMockAddUser) Calls() []*RepositoryMockAddUserParams {
	mmAddUser.mutex.RLock()

	argCopy := make([]*RepositoryMockAddUserParams, len(mmAddUser.callArgs))
	copy(argCopy, mmAddUser.callArgs)

	mmAddUser.mutex.RUnlock()

	return argCopy
}

// MinimockAddUserDone returns true if the count of the AddUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddUserDone() bool {
	if m.AddUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUserMock.invocationsDone()
}

// MinimockAddUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddUserInspect() {
	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUserCounter := mm_atomic.LoadUint64(&m.afterAddUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserMock.defaultExpectation != nil && afterAddUserCounter < 1 {
		if m.AddUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddUser at\n%s", m.AddUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddUser at\n%s with params: %#v", m.AddUserMock.defaultExpectation.expectationOrigins.origin, *m.AddUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUser != nil && afterAddUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddUser at\n%s", m.funcAddUserOrigin)
	}

	if !m.AddUserMock.invocationsDone() && afterAddUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUserMock.expectedInvocations), m.AddUserMock.expectedInvocationsOrigin, afterAddUserCounter)
	}
}

type mRepositoryMockUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserExpectation
	expectations       []*RepositoryMockUserExpectation

	callArgs []*RepositoryMockUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUserExpectation specifies expectation struct of the Repository.User
type RepositoryMockUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUserParams
	paramPtrs          *RepositoryMockUserParamPtrs
	expectationOrigins RepositoryMockUserExpectationOrigins
	results            *RepositoryMockUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUserParams contains parameters of the Repository.User
type RepositoryMockUserParams struct {
	ctx      context.Context
	username string
}

// RepositoryMockUserParamPtrs contains pointers to parameters of the Repository.User
type RepositoryMockUserParamPtrs struct {
	ctx      *context.Context
	username *string
}

// RepositoryMockUserResults contains results of the Repository.User
type RepositoryMockUserResults struct {
	u1  models.User
	err error
}

// RepositoryMockUserOrigins contains origins of expectations of the Repository.User
type RepositoryMockUserExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUser *mRepositoryMockUser) Optional() *mRepositoryMockUser {
	mmUser.optional = true
	return mmUser
}

// Expect sets up expected params for Repository.User
func (mmUser *mRepositoryMockUser) Expect(ctx context.Context, username string) *mRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{}
	}

	if mmUser.defaultExpectation.paramPtrs != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by ExpectParams functions")
	}

	mmUser.defaultExpectation.params = &RepositoryMockUserParams{ctx, username}
	mmUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUser.expectations {
		if minimock.Equal(e.params, mmUser.defaultExpectation.params) {
			mmUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUser.defaultExpectation.params)
		}
	}

	return mmUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.User
func (mmUser *mRepositoryMockUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &RepositoryMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUser
}

// ExpectUsernameParam2 sets up expected param username for Repository.User
func (mmUser *mRepositoryMockUser) ExpectUsernameParam2(username string) *mRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &RepositoryMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.username = &username
	mmUser.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.User
func (mmUser *mRepositoryMockUser) Inspect(f func(ctx context.Context, username string)) *mRepositoryMockUser {
	if mmUser.mock.inspectFuncUser != nil {
		mmUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.User")
	}

	mmUser.mock.inspectFuncUser = f

	return mmUser
}

// Return sets up results that will be returned by Repository.User
func (mmUser *mRepositoryMockUser) Return(u1 models.User, err error) *RepositoryMock {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{mock: mmUser.mock}
	}
	mmUser.defaultExpectation.results = &RepositoryMockUserResults{u1, err}
	mmUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUser.mock
}

// Set uses given function f to mock the Repository.User method
func (mmUser *mRepositoryMockUser) Set(f func(ctx context.Context, username string) (u1 models.User, err error)) *RepositoryMock {
	if mmUser.defaultExpectation != nil {
		mmUser.mock.t.Fatalf("Default expectation is already set for the Repository.User method")
	}

	if len(mmUser.expectations) > 0 {
		mmUser.mock.t.Fatalf("Some expectations are already set for the Repository.User method")
	}

	mmUser.mock.funcUser = f
	mmUser.mock.funcUserOrigin = minimock.CallerInfo(1)
	return mmUser.mock
}

// When sets expectation for the Repository.User which will trigger the result defined by the following
// Then helper
func (mmUser *mRepositoryMockUser) When(ctx context.Context, username string) *RepositoryMockUserExpectation {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	expectation := &RepositoryMockUserExpectation{
		mock:               mmUser.mock,
		params:             &RepositoryMockUserParams{ctx, username},
		expectationOrigins: RepositoryMockUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUser.expectations = append(mmUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.User return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUserExpectation) Then(u1 models.User, err error) *RepositoryMock {
	e.results = &RepositoryMockUserResults{u1, err}
	return e.mock
}

// Times sets number of times Repository.User should be invoked
func (mmUser *mRepositoryMockUser) Times(n uint64) *mRepositoryMockUser {
	if n == 0 {
		mmUser.mock.t.Fatalf("Times of RepositoryMock.User mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUser.expectedInvocations, n)
	mmUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUser
}

func (mmUser *mRepositoryMockUser) invocationsDone() bool {
	if len(mmUser.expectations) == 0 && mmUser.defaultExpectation == nil && mmUser.mock.funcUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUser.mock.afterUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// User implements mm_auth.Repository
func (mmUser *RepositoryMock) User(ctx context.Context, username string) (u1 models.User, err error) {
	mm_atomic.AddUint64(&mmUser.beforeUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUser.afterUserCounter, 1)

	mmUser.t.Helper()

	if mmUser.inspectFuncUser != nil {
		mmUser.inspectFuncUser(ctx, username)
	}

	mm_params := RepositoryMockUserParams{ctx, username}

	// Record call args
	mmUser.UserMock.mutex.Lock()
	mmUser.UserMock.callArgs = append(mmUser.UserMock.callArgs, &mm_params)
	mmUser.UserMock.mutex.Unlock()

	for _, e := range mmUser.UserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmUser.UserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUser.UserMock.defaultExpectation.Counter, 1)
		mm_want := mmUser.UserMock.defaultExpectation.params
		mm_want_ptrs := mmUser.UserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUserParams{ctx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUser.t.Errorf("RepositoryMock.User got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUser.UserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmUser.t.Errorf("RepositoryMock.User got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUser.UserMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUser.t.Errorf("RepositoryMock.User got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUser.UserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUser.UserMock.defaultExpectation.results
		if mm_results == nil {
			mmUser.t.Fatal("No results are set for the RepositoryMock.User")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmUser.funcUser != nil {
		return mmUser.funcUser(ctx, username)
	}
	mmUser.t.Fatalf("Unexpected call to RepositoryMock.User. %v %v", ctx, username)
	return
}

// UserAfterCounter returns a count of finished RepositoryMock.User invocations
func (mmUser *RepositoryMock) UserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.afterUserCounter)
}

// UserBeforeCounter returns a count of RepositoryMock.User invocations
func (mmUser *RepositoryMock) UserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.beforeUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.User.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUser *mRepositoryMockUser) Calls() []*RepositoryMockUserParams {
	mmUser.mutex.RLock()

	argCopy := make([]*RepositoryMockUserParams, len(mmUser.callArgs))
	copy(argCopy, mmUser.callArgs)

	mmUser.mutex.RUnlock()

	return argCopy
}

// MinimockUserDone returns true if the count of the User invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserDone() bool {
	if m.UserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserMock.invocationsDone()
}

// MinimockUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserInspect() {
	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.User at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserCounter := mm_atomic.LoadUint64(&m.afterUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserMock.defaultExpectation != nil && afterUserCounter < 1 {
		if m.UserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.User at\n%s", m.UserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.User at\n%s with params: %#v", m.UserMock.defaultExpectation.expectationOrigins.origin, *m.UserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUser != nil && afterUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.User at\n%s", m.funcUserOrigin)
	}

	if !m.UserMock.invocationsDone() && afterUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.User at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserMock.expectedInvocations), m.UserMock.expectedInvocationsOrigin, afterUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddUserInspect()

			m.MinimockUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddUserDone() &&
		m.MinimockUserDone()
}
